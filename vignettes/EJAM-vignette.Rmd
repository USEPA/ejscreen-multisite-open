---
title: "Basics of using EJAM in RStudio"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Basics of using EJAM in RStudio}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
knitr::opts_chunk$set(eval = FALSE)
# https://r-pkgs.org/vignettes.html
```

## Quickstart

### Summary of Demographics and Environment near 100 Sites

```{r echo=TRUE}
# In R/RStudio, clone/install EJAM package and related ones from https://github.com/USEPA/EJAM, etc.
library(EJAM)

x <- ejamit(testpoints_n(100),1) # 1 mile radius
mapfast(x$results_bysite)
```

### Interactively point to your file with lat,lon coordinates, without shiny web app

```{r}
x <- ejamit(cutoff = 2) #  2 mile radius
```

### Specify all sites in 1 industrial sector

```{r}
naics_from_any("paint and coating", children = T)
x <- ejamit(frs_from_naics("paint and coating"),1)
head(latlon_from_naics(325510)) # has about 1,000 facilities
```

### Specify sites by facility registry ID

```{r}
EJAM::frs_from_siteid(c(110071293460, 110000333826))
```

### Specify sites by facility 

```{r}
EJAM::latlon_from_programid(c("XJW000012435", "00768SRTRSROAD1"))
```

### Specify sites by EPA regulatory program or EPA database

```{r}
EJAM::latlon_from_program("CAMDBS")
```


## *Developer note on building and updating this vignette*

- *Note this vignette needs to be updated - some function names have changed since it was drafted.*
- *See important info at <https://r-pkgs.org/vignettes.html#sec-vignettes-how-built>*
- *Vignette at EJAM\vignettes\EJAM-vignette.html  uses devtools::document() to build it.*
- *See <https://docs.ropensci.org/postdoc/> for a quick easy way to create html help on a pkg. postdoc::render_package_manual('PKGNAME')*

## Accessing and using the code/ data/ app

The app is not on a server. The R package is still in active development, but a current version can be installed from the github USEPA github repository. It can be installed locally as an R package, and the data or functions can be used even without launching the shiny app interface. This is work in progress - only the lat/lon upload may be working right now, for example, not the NAICS/FRS queries.

## Installing EJAM

You can install the development version of EJAM by cloning it from the repository:

<https://github.com/USEPA/EJAM>

## See the [README](https://github.com/USEPA/EJAM#readme "github.com/USEPA/EJAM#readme") if you need a basic intro and broad overview

You can find it here: <https://github.com/USEPA/EJAM#readme>

## Run the Shiny app on your own computer, in RStudio

Launch the web app with run_app() instead of shiny's runApp() because this shiny app is also an R package based on the golem package framework.

```{r run_app}
library(EJAM)
run_app()
```

## See Documentation of Functions and Data

See this vignette and help documentation for the package overall, and individual functions and datasets.

```{r help, eval=FALSE, include=FALSE}
?EJAM
# or 
help("EJAM", package='EJAM')
```

## **Get proximity analysis via R script or console (not shiny app)**

### Install other R packages

Essential packages only available on the [USEPA github](https://github.com/USEPA/EJAM "github.com/USEPA/EJAM") (not CRAN) are:

-   [EJAM](https://github.com/USEPA/EJAM#readme "github.com/USEPA/EJAM")
-   [EJAMblockdata](https://github.com/USEPA/EJAMblockdata#readme "github.com/USEPA/EJAMblockdata#readme")
-   [EJAMfrsdata](https://github.com/USEPA/EJAMfrsdata#readme "github.com/USEPA/EJAMfrsdata")
-   [EJAMejscreenapi](https://github.com/USEPA/EJAMejscreenapi#readme "github.com/USEPA/EJAMejscreenapi")
-   [EJAMbatch.summarizer](https://github.com/USEPA/EJAMbatch.summarizer#readme "github.com/USEPA/EJAMbatch.summarizer")

Not essential:

-   [EJAMejscreendata](https://github.com/USEPA/EJAMejscreendata#readme "github.com/USEPA/EJAMejscreendata")

### Create the index of where blocks are, to be able to quickly find those nearby a given site

During development of this package, at least, this index is built when the package is loaded, automatically, by the .onLoad() function in the file EJAM/R/aaa_onLoad_create_quad_tree_index.R THIS IS SLOW - It takes a few seconds. This (seemingly) must be done for each session? One cannot save it as .rda and just load via a pkg since it is like a pointer to the index in RAM or something like that.

```{r BUILD_INDEX}
# One could manually rebuild the index (if quaddata were updated, for example),
#  like this:
localtree <- SearchTrees::createTree(
  EJAMblockdata::quaddata, treeType = "quad", dataType = "point"
)
```

### Specify points (where you want to center the circular buffers)

#### NAICS Codes to Specify Facilities in one Industrial Sector

Quick map of EPA-regulated facilities in one industrial category

```{r}
mapfast(mysites <- frs_from_naics("smelt")) # slow the 1st time as it lazyloads frs dataset
```

(but note that FRS lacks NAICS for most facilities!)

Table of facilities in an industry, plus links to each facility in ECHO and EJScreen

```{r}
industryword <- "chemical manuf"
#  industryword <- "smelt"
mysites <- frs_from_naics(industryword, children=FALSE)[,1:5]
regids <- mysites$REGISTRY_ID
link1 <- url_echo_facility_webpage(regids, as_html = T)
link2 <- url_ejscreen_report(lat = mysites$lat, lon = mysites$lon, distance = 3, as_html = T)
link3 <- url_ejscreenmap(lat = mysites$lat, lon = mysites$lon,  as_html = T)
link4 <- url_ejscreen_acs_report(lat = mysites$lat, lon = mysites$lon, distance = 3, as_html = T)
# # same:
# my_industry <- naics_from_any("chemical manuf",children = F)[,.(code,name)]
# mysites <- frs_from_naics(my_industry$code)[,1:5]
mysites <- cbind(`ECHO report` = link1, 
                 `EJScreen Report` = link2, `EJScreen Map` = link3, `ACS Report` = link4,
                 mysites)
print(
  DT::datatable(
    mysites[1:min(nrow(mysites), 1500) ], # >2k rows is too much for client-side DataTables
    escape = FALSE,
    caption = paste0(nrow(mysites), ' FACILITIES HAVE NAICS MATCHING QUERY TERM "', industryword, '"'),
    filter = "top"
  )
)
```

Map of facilities in an industry, plus popups with links to each facility in ECHO and EJScreen

```{r}
EJAMejscreenapi::mapfast(mysites)
```

NAICS/industry categories

```{r}
naics_categories()
naics_from_any(naics_categories(3))[order(name),.(name,code)][1:10,]
naics_from_any(naics_categories(3))[order(code),.(code,name)][1:10,]

# See a data table of facilities in one industry
industryword <- "pulp"
frs_from_naics(naics_from_any(industryword)$code)[,1:4]
```

Search using industry codes or text in industry names

```{r}
naics_from_any("plastics and rubber") 
naics_from_any(326)
naics_from_any(326, children = T)[,.(code,name)]
naics_from_any("pig") 
naics_from_any("pig ") # space after g

# a OR b,  a AND b,  etc.
a = naics_from_any("plastics")
b = naics_from_any("rubber")
fintersect(a,b)[,.(name,code)] #  a AND b
funion(a,b)[,.(name,code)]     #  a OR  b
naics_subcodes_from_code(funion(a,b)[,code])[,.(name,code)]   #  plus children
naics_from_any(funion(a,b)[,code], children=T)[,.(name,code)] #  same
```

A NAICS code can have many "children" or subcategories under it

```{r}
NROW(naics_from_any("chem"))
#[1] 20
NROW(naics_from_any("chem", children = T))
#[1] 104

  NROW(frs_from_naics(naics_from_any("chem")$code))
# [1] 4907
 NROW(frs_from_naics(naics_from_any("chem", children = T)$code))
# [1] 13543
```

#### Use lat/lon point data

Enter lat and lon to specify points

```{r}
sitepoints2  <- data.frame(
  lon = c(-92.1, -91.8), 
  lat = c(34.8799123, 30.2906971), 
  siteid = 1:2
)
```

Use lat/lon coordinates in a table like a spreadsheet - xlsx or csv file

The first row should be column names including lat and lon, or something that can be interpreted as that - see latlon_infer()

```{r eval=FALSE, include=TRUE}
testjunk <- file.path(tempdir(), 'testjunk.csv')
write.csv(data.frame(LONG = c(-92.1, -91.8), Latitude = c(34.8, 30.2), siteid = 1:2), file = testjunk, row.names = FALSE)
sitepoints2 <- latlon_from_anything(testjunk)
sitepoints2
```

Use test points in examples that comes with the package

```{r testpoints, eval=TRUE, include=TRUE}
EJAM::testpoints_100_dt |> head(2) # data.table, in this package
sitepoints100 <- data.table::copy(EJAM::testpoints_100_dt)  # [1:5, ]
head(sitepoints100, 3)
```

Create random test data points

```{r}
p1k <- testpoints_n(1000)
mapfast(p1k)

mapfast(testpoints_n(300, ST_of_blockgroup = c('LA','TX')) )
```

### Specify radius for circular buffer, and other key parameters

```{r}
radius <- 3 # radius (miles).  5 km = 3.1 miles, 10 km = 6.2 miles
```




### Key Functions in EJAM

-   **ejamit()** provides results in just one function, by using getblocksnearby() and doaggregate():

-   **getblocksnearby()** takes a set of points (e.g., facilities) and finds the Census blocks near each. Sample input is in testpoints_100_dt, and sample output is in sites2blocks_example.

-   **doaggregate()** takes the list of blocks near each point, joins it to blockgroup indicators like from EJScreen, and aggregates at each buffered point as well as for the overall set of unique blocks (residents). Sample input is in sites2blocks_example.

### Get results in one step

```{r}
## This function just combines getblocksnearby() and doaggregate()
sitepoints <- testpoints_1000
# elapsed <- system.time({
began = Sys.time()
  out2 <- ejamit(
    sitepoints =  sitepoints  ,
    cutoff = radius
  )
  speedreport(began, Sys.time(),n = NROW(sitepoints))
# })
# print(elapsed)

```

Explore results in map and table

```{r}
names(out2)
cbind(as.list(out2$results_overall))
cbind(overall = as.list( out2$results_overall[ , ..names_d]))
cbind(overall = as.list( out2$results_overall[ , ..names_d_subgroups]))

## Site by site results in map or table:
 
mapfast(out2$results_bysite, radius = radius)

DT::datatable(out2$results_bysite)

```

See summary stats about the indicators

```{r}
outsum <-  batch.summarize(
  data.frame(out2$results_bysite), 
  data.frame(out2$results_bysite)
)

round(outsum$rows[,names_d],2)
round(outsum$rows[,names_d_pctile],2)

```




### Get granular results step by step, and view details

#### getblocksnearby() will find residents/blocks that are within specified distance

About \< 1 second for 100 sites, but a few seconds for 1,000 sites, or roughly 500k / hour for this step

```{r}
sitepoints <- data.table::copy(EJAM::testpoints_100_dt) 
# or 
# sitepoints <- testpoints_n(100,"block") # random points
elapsed <- system.time({
  
  sites2blocks <- EJAM::getblocksnearby(
    sitepoints = sitepoints,
    cutoff = radius,
    quadtree = localtree
  )
  
}) # end of timed function
print(elapsed)
sites2blocks
```

#### Map of the blocks found nearby

```{r}
plotblocksnearby(testpoints_n(1), radius = 3)
```

#### View detailed diagnostics or stats on the intermediate result:

-   what blocks are near each site
-   how far are they
-   how many blocks are typically near a given site (population density varies a lot)
-   how many sites are near a block (residents who have more than 1 site near them)

```{r}
## Also could use this example intermediate step dataset 
## of 99 sites, with 11,567 nearby blocks:
# sites2blocks <- data.table::copy(sites2blocks_example)
sitepoints <- data.table::copy(EJAM::testpoints_100_dt) 
sites2blocks <- EJAM::getblocksnearby(sitepoints,radius,quadtree = localtree)
names(sites2blocks)
getblocks_summarize_blocks_per_site(sites2blocks) # print() shows more info returned invisibly
getblocks_diagnostics(sites2blocks)
# Use data.table package here

# Very few blocks are within a radius of 1/4 mile.
# Hundreds are often within 1 mile, but sometimes there are only a handful or even zero.
s2b_stats <- sites2blocks[ , .(
  avgDistance = round(mean(distance), 2),
  blocksfound = .N, 
  blocks_within_1mile = sum(distance <= 1),
  blocks_within_0.75   = sum(distance <= 0.75),
  blocks_within_0.25  = sum(distance <= 0.25)
), by = 'siteid'][order(blocksfound), ]
setorder(s2b_stats, siteid)
head(s2b_stats)

# CDF of how many blocks are nearby a site
plot(sort(s2b_stats$blocks_within_1mile), main="How many blocks are near each facility?", ylab="# of blocks (whose internal point is) within 1 mile of each facility", xlab=paste0(nrow(s2b_stats), " facilities ranked by # of blocks nearby"))
abline(h=quantile(s2b_stats$blocks_within_1mile, probs = (0:4)* 0.25))
abline(h=mean(s2b_stats$blocks_within_1mile), col="red")

# Histogram of how many blocks are nearby a site
hist(sites2blocks[,.N,by="siteid"][,N],20, xlab = "How many blocks are nearby?", ylab="Frequency (# of sites)", main = "A given site may have zero to hundreds of blocks nearby", sub="A typical site in this example has about 100 blocks nearby")

s2b_stats[,PGM_SYS_ACRNMS := NULL] # remove verbose column
DT::datatable(s2b_stats)
# more summaries showing there may be only 1 block or several hundred blocks within 1 mile
quantile(s2b_stats$blocks_within_1mile, probs = (0:4)* 0.25)
t(summary(s2b_stats)) 

# map the sites with popups about how many blocks were found near each
if (!('siteid' %in% names(sitepoints))) {sitepoints$siteid <- seq.int(length.out = NROW(sitepoints))}
s2b_stats <- merge(sitepoints, s2b_stats, by = "siteid")
EJAMejscreenapi::mapfast(s2b_stats, radius = radius)

# A 1 mile radius is huge within a dense urban area
EJAMejscreenapi::mapfast(s2b_stats[87:88,], radius = radius)

# Within a 1 mile radius, the blocks found tend to be about 2/3 of a mile from the site at the center.
summary(s2b_stats$avgDistance)
```

See map of all the block points nearby (i.e, inside the circular buffer surrounding a site)

```{r}
x <- merge( sites2blocks, blockpoints )
setnames(x, 'lat', 'blocklat')
setnames(x, 'lon', 'blocklon')
x <- merge(sitepoints, x, by = "siteid")
x[,PGM_SYS_ACRNMS := NULL]
x
bplot=function(x,n, ... ) {plot(x$blocklon[x$siteid==n], x$blocklat[x$siteid==n], ... ); points(x$lon[x$siteid==n], x$lat[x$siteid==n] , col="red")}
# for (i in 1:20) {
bplot(x, sample(1:nrow(sitepoints),1)) # plots a random site surrounded by nearby block points
# }
```

#### doaggregate() will summarize indicators within each buffer and overall

```{r}
# out <- doaggregate(sites2blocks_example)

elapsed <- system.time({
  out <- suppressWarnings( 
    doaggregate(sites2blocks = sites2blocks) 
  )
}) 
print(elapsed)

names(out)
dim(out$results_bysite)
```

#### See indicators aggregated over all people across all sites

```{r}
## view output of batch run aggregation ####
cbind(overall = as.list( out$results_overall))

## To see just some subset of indicators, like Environmental only:
cbind(overall = as.list( out$results_overall[ , ..names_e]))
cbind(overall = as.list( out$results_overall[ , ..names_d]))
cbind(overall = as.list( out$results_overall[ , ..names_d_subgroups]))
cbind(overall = as.list( out$results_overall[ , ..names_e_pctile]))
cbind(overall = as.list( out$results_overall[ , ..names_d_pctile]))
cbind(overall = as.list( out$results_overall[ , ..names_ej_pctile]))
```

#### Histogram of indicators distribution over all people across all sites

```{r}
hist(out2$results_bysite$pctile.traffic.score,10, xlab="Local traffic scores (expressed as a percentile)", ylab="count of sites in each bin, out of 1,000 sites", freq = TRUE, main="Actual distribution of indicators nearby, as percentiles, vs flat line = USA overall");abline(h=nrow(out2$results_bysite)/10)
```

#### Compare to results from EJScreen API

```{r}
sitepoints <- testpoints_1000_dt
outapi <- EJAMejscreenapi::ejscreenapi_plus(sitepoints[1:5, ], radius = radius)
cbind(as.list(outapi[1, ]))

setdiff( names(outapi), names(out2$results_overall))
cat("----------------\n")
setdiff_yx( names(outapi), names(out2$results_overall))
# links to report or map are named differently.
# us and state averages are there but us ones named with us. prefix in api not ejam
# EJ pctiles, statename,  REGION, etc. might not be provided in EJAM output.
# ratios counts of denominators, demog subgroups, etc. are in EJAM only.  
```
