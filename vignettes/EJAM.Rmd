---
title: "EJAM - basic usage in RStudio"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{EJAM - basic usage in RStudio}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# *EJAM package basics*

## *To run the Shiny app on your own computer, in RStudio*

```{r setup}
library(EJAM)
#  run_app()
```

## ***To get proximity analysis via R script or interactively in console***

-   *note: DEMOG SUBGROUPS ARE NOT IN LOOKUP TABLES OF PERCENTILES YET, AND NEED TO BE ADDED.*

-   *note: state.pctile. is all NA values so far until State percentiles dataset is added*

### Get datasets and functions

```{r}
library(EJAM) 
# Get Census 2000 blocks, with lat lon population weights etc.
library(EJAMblockdata)    
# Get EPA Facility Registry System data with lat lon for each regulated site
library(EJAMfrsdata)   
library(data.table)
# library(EJAMejscreendata) 
#   is not needed since EJAM pkg has versions of the key parts,
#   using friendlier variable names and some extra columns of info and race ethnic subgroups
# data("blockwts") 
#   is not needed - it should lazy load as needed from EJAMblockdata::blockwts
```

### Create the index of where blocks are, to be able to quickly find those nearby a given site

THIS IS SLOW - takes a few seconds. This (seemingly) must be done for each session? One cannot save it as .rda and just load via a pkg?

```{r}
system.time({
  localtree <- SearchTrees::createTree(
    EJAMblockdata::quaddata, treeType = "quad", dataType = "point"
  )
})
```

### Use some test points as an example

```{r}
  EJAM::points100example |> head(2) # data in this package
```

```{r}
sitepoints <- data.table::copy(EJAM::points100example) # [1:5, ]
  # Note the 1st point was far outside the US and returned no data if using Census 2010 blocks.
  sitepoints[ , siteid := .I]  # .I JUST NUMBERS THE SITES
  # rename since lat/lon are used in this pkg
  data.table::setnames(sitepoints, 'LAT', 'lat')  
  data.table::setnames(sitepoints, 'LONG', 'lon')
  data.table::setkey(sitepoints) #,  c('siteid', 'lat', 'lon'))
  head(sitepoints,2)
```

### Specify radius for circular buffer, and other key parameters

```{r}
  radius <- 1 # radius (miles).  5km = 3.1 miles
  # Expand distance searched, when a facility has no census block centroid within selected buffer distance.
  avoidorphans <- TRUE
  # max distance to expand search to, if avoidorphans=TRUE
  maxcutoff <- 31.07 # 50 km
```

### The function getblocksnearby_and_doaggregate() provides results in just one function (or see further below for each step separately)

```{r}
  # This function just combines getblocksnearby() and doaggregate()
#   STILL TESTING THIS
  # elapsed <- system.time({
  #   out2 <- getblocksnearby_and_doaggregate(
  #     sitepoints =  sitepoints,
  #     cutoff = radius,
  #     maxcutoff = maxcutoff,
  #     avoidorphans = avoidorphans,
  #     quadtree = localtree
  #   )
  # })
  # print(elapsed)
  
```

### To see the two steps separately:

### getblocksnearby() will find residents/blocks that are within specified distance

About \< 1 second for 100 sites, but a few seconds for 1,000 sites, or roughly 500k / hour for this step

```{r}
elapsed <- system.time({
  sites2blocks <- EJAM::getblocksnearby(
    sitepoints =  sitepoints,
    cutoff = radius,
    maxcutoff = maxcutoff,
    avoidorphans = avoidorphans,
    quadtree = localtree
  )
}) # end of timed function
print(elapsed)
```

### View some diagnostics or stats on the intermediate result: what blocks are near each site, and how far are they, etc.

```{r}
names(sites2blocks)
summarize_blocks_per_site(sites2blocks) # print() shows more info returned invisibly
summarize_sites_per_block(sites2blocks) # print() shows more info returned invisibly
summarize_blockcount(sites2blocks)

sites2blocks[ , .(blockcount=.N, avgDistance=round(mean(distance),1), blocks_within_0.5=sum(distance<0.5), blocks_within_0.25=sum(distance<0.25)), by='siteid'][order(blockcount),]

```

### doaggregate() will summarize indicators within each buffer and overall

```{r}
  elapsed <- system.time({
    out <- doaggregate(sites2blocks = sites2blocks)
  }) 
  print(elapsed)
  
  names(out)
```

### See indicators aggregated over all people across all sites

```{r}
  cbind(prettyNum((out$results_overall[ , ..names_all])))
  
  # To see just some subset of indicators, like Environmental only:
  # cbind(prettyNum((out$results_overall[ , ..names_e])))
  # cbind(prettyNum((out$results_overall[ , ..names_d])))
  # cbind(prettyNum((out$results_overall[ , ..names_d_subgroups])))
  # cbind(prettyNum((out$results_overall[ , ..names_e_pctile])))
  # cbind(prettyNum((out$results_overall[ , ..names_d_pctile])))
  # cbind(prettyNum((out$results_overall[ , ..names_ej_pctile])))
  
  # view output of batch run aggregation ####
  # cbind(prettyNum((out$results_overall))) 

```
