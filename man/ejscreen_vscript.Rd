% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ejscreen_vs_ejam_.R
\name{ejscreen_vscript}
\alias{ejscreen_vscript}
\title{EJAM/EJSCREEN comparisons - for interactive RStudio use
The best starting point for comparisons of single-site EJScreen API results and EJAM multisite results.}
\usage{
ejscreen_vscript(
  defdir = ".",
  n,
  newpts,
  pts = NULL,
  radius = NULL,
  fips = NULL,
  shapefile = NULL,
  savedejscreentableoutput,
  x100fix = TRUE,
  x100varnames = names_pct_as_fraction_ejamit
)
}
\arguments{
\item{defdir}{folder}

\item{n}{how many points}

\item{newpts}{logical, if need new set of random locations}

\item{pts}{data.frame of points with columns lat,lon}

\item{radius}{miles}

\item{fips}{vector of fips codes if relevant}

\item{shapefile}{not implemented, except in the sense that newpts can be
specified to be cities, which are analyzed using shapefiles in EJAM,
but as fips in ejscreenapi. Select new, shape (city) options in interactive mode.}

\item{savedejscreentableoutput}{is a data.table from ejscreenit()$table}
}
\value{
a list of data frames, with names
EJSCREEN, EJAM, EJSCREEN_shown, EJAM_shown, same_shown,
ratio, diff, absdiff, pctdiff, abspctdiff

diff is EJAM - EJSCREEN

ratio is EJAM / EJSCREEN

pctdiff is ratio - 1

abs is absolute value

For each data.frame, colnames are indicators like pop, blockcount_near_site, etc.
and rows represent sites analyzed.
}
\description{
EJAM/EJSCREEN comparisons - for interactive RStudio use
The best starting point for comparisons of single-site EJScreen API results and EJAM multisite results.
}
\details{
THIS IS FOR INTERACTIVE RSTUDIO CONSOLE USE
TO RUN A SET OF POINTS THROUGH BOTH
EJScreen and the EJAM multisite tool
AND SAVE STATS ON THE DIFFERENCES

Also lets you use saved ejscreenapi results and input points
so you can iterate and rerun just the EJAM portion and compare to the saved benchmark data.
}
\examples{
vs = ejscreen_vscript(pts = testpoints_100, radius = 3)
ejscreen_vs_explain(vs, 1:2)

#'  # To filter that to just the ones where rounded pop disagrees
 table(vs$same_shown$pop)
 vspopoff <- lapply(vs, function(x) x[!vs$same_shown$pop, ])
 
##  To filter that to just the ones where blockcount was identical, 
#   to exclude that as source of difference
vs_blocksmatch = lapply(vs, function(df) df[vs$absdiff[, "blockcount_near_site"] == 0, ])
# vss = ejscreen_vs_ejam_summary(vs )
vssb = ejscreen_vs_ejam_summary(vs_blocksmatch)
# vss[vss$indicator \%in\% names_these, c(1,7,8)]
vssb[vssb$indicator \%in\% names_these, c(1,7,8)]
x = vssb[vssb$indicator \%in\% c('pop', names_these), c(1,7,8)] 
x[order(x$pct.of.sites.agree.within.tol), ]

xx = cbind(indicator = vssb$indicator[vssb$indicator \%in\% c('pop', names_these)],
 round(vssb[vssb$indicator \%in\% c('pop', names_these),
  c('pct.of.sites.agree.within.tol', 'max.abs.diff', 'median.abs.diff')], 0))
xx[xx$pct.of.sites.agree.within.tol < 100, ]

}
\seealso{
Relies on \code{\link[=ejscreen_vs_ejam]{ejscreen_vs_ejam()}} \code{\link[=ejscreen_vs_ejam_alreadyrun]{ejscreen_vs_ejam_alreadyrun()}} \code{\link[=ejscreen_vs_explain]{ejscreen_vs_explain()}}
}
\keyword{internal}
