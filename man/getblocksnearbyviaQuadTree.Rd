% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/getblocksnearbyviaQuadTree.R
\name{getblocksnearbyviaQuadTree}
\alias{getblocksnearbyviaQuadTree}
\title{Find nearby blocks using Quad Tree data structure for speed, NO PARALLEL PROCESSING}
\usage{
getblocksnearbyviaQuadTree(
  sitepoints,
  radius = 3,
  maxradius = 31.07,
  avoidorphans = TRUE,
  report_progress_every_n = 500,
  quadtree
)
}
\arguments{
\item{sitepoints}{data.table with columns siteid, lat, lon giving point locations of sites or facilities around which are circular buffers}

\item{radius}{in miles, defining circular buffer around a site point}

\item{maxradius}{miles distance (max distance to check if not even 1 block point is within radius)}

\item{avoidorphans}{logical If TRUE, then where not even 1 BLOCK internal point is within radius of a SITE,
it keeps looking past radius, up to maxradius, to find nearest 1 BLOCK.
What EJScreen does in that case is report NA, right? So,
does EJAM really need to report stats on residents presumed to be within radius,
if no block centroid is within radius?
Best estimate might be to report indicators from nearest block centroid which is
probably almost always the one your site is sitting inside of,
but ideally would adjust total count to be a fraction of blockwt based on
what is area of circular buffer as fraction of area of block it is apparently inside of.

Note that if creating a proximity score, by contrast, you instead want to find nearest 1 SITE if none within radius of this BLOCK.}

\item{report_progress_every_n}{Reports progress to console after every n points,
mostly for testing, but a progress bar feature might be useful unless this is super fast.}

\item{quadtree}{(a pointer to the large quadtree object)
created from the SearchTree package example:
SearchTrees::createTree( quaddata, treeType = "quad", dataType = "point")
Takes about 2-5 seconds to create this each time it is needed.
It can be automatically created when the package is attached via the .onAttach() function}
}
\description{
Given a set of points and a specified radius in miles,
this function quickly finds all the US Census blocks near each point.
}
\details{
For each point, it uses the specified search radius and finds the distance to
every block within the circle defined by the radius.
Each block is defined by its Census-provided internal point, by latitude and longitude.

Results are the sites2blocks table that would be used by doaggregate(),
with distance in miles as one output column of data.table.
Adjusts distance to avg resident in block when it is very small relative to block size,
the same way EJScreen adjusts distances in creating proximity scores.

Each point can be the location of a regulated facility or other type of site, and
the blocks are a high-resolution source of information about where
residents live.

Finding which blocks have their internal points in a circle provides
a way to quickly estimate what fraction of a block group is
inside the circular buffer more accurately and more quickly than
areal apportionment of block groups would provide.
}
\seealso{
\code{\link[=ejamit]{ejamit()}} \code{\link[=getblocksnearby]{getblocksnearby()}} \code{\link[=getblocksnearbyviaQuadTree]{getblocksnearbyviaQuadTree()}} \code{\link[=getblocksnearbyviaQuadTree_Clustered]{getblocksnearbyviaQuadTree_Clustered()}} \code{\link[=getblocksnearbyviaQuadTree2]{getblocksnearbyviaQuadTree2()}}
}
