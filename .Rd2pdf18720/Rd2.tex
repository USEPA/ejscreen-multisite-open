\nonstopmode{}
\documentclass[a4paper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8]{inputenc} % @SET ENCODING@
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `EJAM'}}
\par\bigskip{\large \today}
\end{center}
\inputencoding{utf8}
\ifthenelse{\boolean{Rd@use@hyper}}{\hypersetup{pdftitle = {EJAM: EJAM Environmental Justice Analysis Multisite tool}}}{}
\begin{description}
\raggedright{}
\item[Title]\AsIs{EJAM Environmental Justice Analysis Multisite tool}
\item[Version]\AsIs{2.2.1}
\item[Author]\AsIs{Mark Corrales}
\item[Maintainer]\AsIs{Mark Corrales }\email{corrales.mark@epa.gov}\AsIs{}
\item[License]\AsIs{MIT + file LICENSE.md}
\item[Description]\AsIs{Tools for summarizing environmental and demographic indicators 
(such as those in EJScreen) for residents living near any one of a number of 
specific sites. It uses quad tree search/indexing of block locations, data.table, etc.
to provide very fast identification of nearby blocks, distances, and 
aggregation of indicators within each distance. It can be uses as a web app, with the user interface provided by R shiny.}
\item[URL]\AsIs{}\url{https://github.com/USEPA/EJAM}\AsIs{}
\item[Depends]\AsIs{R (>= 2.10),
aws.s3,
EJAMbatch.summarizer,
EJAMejscreenapi,
shinyBS}
\item[Imports]\AsIs{attempt,
collapse,
config (>= 0.3.1),
data.table,
DBI,
doSNOW,
dplyr,
DT,
foreach,
ggplot2,
ggridges,
glue,
golem (>= 0.3.3),
hrbrthemes,
htmltools,
leaflet,
magrittr,
methods,
openxlsx,
pdist,
pkgload,
readxl,
rhandsontable,
rmarkdown,
RMySQL,
SearchTrees,
shinydisconnect,
sf,
shiny (>= 1.7.2),
shinycssloaders,
shinyjs,
sp,
tidyr,
tidyverse,
viridis}
\item[Suggests]\AsIs{knitr,
spelling,
testthat (>= 3.0.0)}
\item[Config/testthat/edition]\AsIs{3}
\item[Encoding]\AsIs{UTF-8}
\item[LazyData]\AsIs{true}
\item[Language]\AsIs{en-US}
\item[VignetteBuilder]\AsIs{knitr}
\item[RoxygenNote]\AsIs{7.2.3}
\item[Roxygen]\AsIs{list(markdown = TRUE)}
\item[Config/testthat/parallel]\AsIs{true}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{.onAttach}{.onAttach - Do slow initialization steps - Download data, load key data into RAM, create index to all US blocks Note this duplicates some code in global.R, and see source code here to adjust settings.}{.onAttach}
%
\begin{Description}\relax
.onAttach - Do slow initialization steps - Download data, load key data into RAM, create index to all US blocks
Note this duplicates some code in global.R, and see source code here to adjust settings.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.onAttach(libname, pkgname)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{libname}] na

\item[\code{pkgname}] na
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Does this even happen if connect server runs app as a regular shiny app without loading all?
In what order? see app.R too ***
\end{Details}
\inputencoding{utf8}
\HeaderA{all\_equal\_functions}{all\_equal\_functions - UTILITY - check different versions of function with same name in 2 packages used by dupenames() to check different versions of function with same name in 2 packages}{all.Rul.equal.Rul.functions}
%
\begin{Description}\relax
all\_equal\_functions - UTILITY - check different versions of function with same name in 2 packages
used by dupenames() to check different versions of function with same name in 2 packages
\end{Description}
%
\begin{Usage}
\begin{verbatim}
all_equal_functions(
  fun = "latlon_infer",
  package1 = "EJAM",
  package2 = "EJAMejscreenapi"
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{fun}] quoted name of function, like "latlon\_infer"

\item[\code{package1}] quoted name of package, like "EJAM"

\item[\code{package2}] quoted name of package, like "EJAMejscreenapi"
\end{ldescription}
\end{Arguments}
%
\begin{Value}
TRUE or FALSE
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{dupenames()}{dupenames}} \code{\LinkA{all.equal.function()}{all.equal.function}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{app\_run\_EJAM}{app\_run\_EJAM - identical to run\_app(), just an alias}{app.Rul.run.Rul.EJAM}
\aliasA{run\_app}{app\_run\_EJAM}{run.Rul.app}
%
\begin{Description}\relax
launch Shiny web app from RStudio
\end{Description}
%
\begin{Usage}
\begin{verbatim}
app_run_EJAM(
  onStart = NULL,
  options = list(),
  enableBookmarking = "server",
  uiPattern = "/",
  ...
)
\end{verbatim}
\end{Usage}
\inputencoding{utf8}
\HeaderA{app\_server}{app\_server - EJAM app server}{app.Rul.server}
%
\begin{Description}\relax
app\_server - EJAM app server
\end{Description}
%
\begin{Usage}
\begin{verbatim}
app_server(input, output, session)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{input, output, session}] Internal parameters for shiny.
DO NOT REMOVE.
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{avg.in.us}{avg.in.us (DATA) national averages of key indicators, for convenience}{avg.in.us}
%
\begin{Description}\relax
also available via \LinkA{usastats}{usastats} and created by /data-raw/datacreate\_avg.in.us
\end{Description}
\inputencoding{utf8}
\HeaderA{bgej}{bgej (DATA) EJScreen EJ Indexes for Census block groups}{bgej}
%
\begin{Description}\relax
bgej (DATA) EJScreen EJ Indexes for Census block groups
\end{Description}
%
\begin{Details}\relax
\begin{itemize}

\item{} As of 08/2023 it was the EJScreen 2.2 version of data, which used ACS 2017-2021.

\end{itemize}


Each year this should be re-created as for the latest version.

See \url{https://www.epa.gov/ejscreen}
\end{Details}
\inputencoding{utf8}
\HeaderA{bgpts}{bgpts (DATA) lat lon of popwtd center of blockgroup, and count of blocks per block group}{bgpts}
%
\begin{Description}\relax
This is just a list of US block groups and how many blocks are in each...
It also has the lat and lon roughly of each blockgroup
\end{Description}
%
\begin{Details}\relax
The point used for each bg is the Census 2020 population weighted mean
of the blocks' internal points. It gives an approximation of where people live
and where each bg is, which is useful for some situations.

\begin{alltt}
  As of 8/2023 it is the EJScreen 2.2 version of data, which uses ACS 2017-2021
  and Census 2020. it has all US States, DC, PR, but not  "AS" "GU" "MP" "VI"
  
  How lat lon were estimated:

 # Now, for Census 2020 blocks, create pop wtd centroids lat lon for each block group #### 
 #  using  blockwts and   blockpoints
 
 bgpts_blocks <- copy(blockpoints) # not essential but ok to make sure we do not change blockpoints itself by reference in data.table operations
 # all.equal(bgpts$blockid , blockwts$blockid)
 bgpts_blocks[ , bgid    := blockwts$bgid]
 bgpts_blocks[ , blockwt := blockwts$blockwt]
 # get pop wtd mean of lat, and same for lon, by bgid
 bgpts <- bgpts_blocks[ , lapply(.SD, FUN = function(x) stats::weighted.mean(x, w = blockwt, na.rm = TRUE)), .SDcols = c('lat', 'lon') , by = 'bgid']
 rm( bgpts_blocks)
 # add the bgfips column, so it has bgfips, bgid, lat, lon
 # all.equal(bgpts$bgid,bgid2fips$bgid)
 bgpts[ , bgfips := bgid2fips$bgfips]
 # setnames(bgpts, 'bgfips', 'FIPS')
 
 # BUT NOTE this census2020 block table has PR but lacks "AS" "GU" "MP" "VI" ####
 # > uniqueN( blockid2fips[,substr(blockfips,1,2)])
 # [1] 52
 # length(unique(EJSCREEN_Full_with_AS_CNMI_GU_VI$ST_ABBREV)) # which is in the package EJAMejscreendata
 # [1] 56
 #   dim(bgejam)
 # [1] 242,940    155
 #   dim(bg22)
 # [1] 242,335    157
 #
 # so how do we get latlon for bg in as/gu/mp/vi ?  ?####
 
 # view those block group points on a map (plot only a subset which is enough)
 sam <- sample(seq_along(bgpts$bgid),5000) 
 plot(x = bgpts$lon[sam], y = bgpts$lat[sam], pch = '.')
 
 # view one state, florida, where 12 are the 1st 2 digits of the FIPS:
 # bgpts[bgid2fips[substr(bgfips,1,2) == '12', ], on = 'bgid']
 xx='12'
 mystate <- bgpts[bgid2fips[substr(bgfips, 1, 2) == xx, ], on = 'bgid'][ , .(lon, lat)] 
 plot(mystate, pch = '.')
 rm(mystate, xx)
 
    
  How blockcounts were done: 
   
 need  data.table pkg
  bg_blockcounts <- blockwts[ , .(blockcount = uniqueN(.SD)), by=bgid]
  sum(bg_blockcounts$blockcount == 1)
    # [1] 1874 blockgroups have only 1 block
  sum(bg_blockcounts$blockcount == 1000)  the max is 1000 blocks in a bg
    # # [1] 22
  round(100*table(bg_blockcounts[blockcount <20, blockcount]) / nrow(bg_blockcounts) ,1)
    # about 1 to 3 
    #   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19 
    # 0.8 1.2 1.3 1.4 1.5 2.1 2.2 2.4 2.6 2.8 2.8 3.0 3.0 2.9 3.0 2.9 2.8 2.7 2.5 
    all.equal(bgpts$bgid, bg_blockcounts$bgid)
  bgpts[ , blockcount := bg_blockcounts$blockcount]
  dim(bgpts)   
      # 242335  x    5
  usethis::use_data(bgpts) # saved for EJAM package
  
  \end{alltt}

\end{Details}
\inputencoding{utf8}
\HeaderA{bg\_cenpop2020}{bg\_cenpop2020 (DATA) data.table with all US Census 2020 block groups, Census 2020 population count, and lat/lon of Census2020-population-weighted centroid of block group}{bg.Rul.cenpop2020}
%
\begin{Description}\relax
bg\_cenpop2020 (DATA) data.table with all US Census 2020 block groups, Census 2020 population count,
and lat/lon of Census2020-population-weighted centroid of block group
\end{Description}
%
\begin{Details}\relax
also see attributes(bg\_cenpop2020) for source URL and date
\end{Details}
%
\begin{SeeAlso}\relax
\LinkA{blockgroupstats}{blockgroupstats}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{blockgroupstats}{blockgroupstats (DATA) EJScreen demographic and environmental indicators for Census block groups}{blockgroupstats}
%
\begin{Description}\relax
The EJScreen dataset (demographic, environmental indicators).

For EJ Indexes, see \LinkA{bgej}{bgej}
\end{Description}
%
\begin{Details}\relax
\begin{itemize}

\item{} As of 08/2023 it was the EJScreen 2.2 version of data, which used ACS 2017-2021.

\end{itemize}


Each year this should be re-created as for the latest version.
See attributes(blockgroupstats)

It is a data.table of US Census blockgroups (not blocks).
With PR, and Island Areas

See \url{https://www.epa.gov/ejscreen}

Column names include bgfips, bgid (for join to blockwt\$bgid), pop, pctlowinc, etc.
\end{Details}
\inputencoding{utf8}
\HeaderA{censusplaces}{censusplaces (DATA) Census FIPS and other basic info on 41,414 cities/towns/places}{censusplaces}
%
\begin{Description}\relax
This is just a list of US cities and similar places defined by Census
\end{Description}
%
\begin{Details}\relax
from (https://www2.census.gov/geo/docs/reference/codes/PLACElist.txt)
Column names:  "EPA\_REGION" "STATE" "ST\_FIPS" "COUNTY" "CO\_FIPS" "PLACE" "PL\_FIPS"
\end{Details}
\inputencoding{utf8}
\HeaderA{colcounter}{colcounter - Count columns with Value (at or) above (or below) threshold}{colcounter}
%
\begin{Description}\relax
colcounter - Count columns with Value (at or) above (or below) threshold
\end{Description}
%
\begin{Usage}
\begin{verbatim}
colcounter(
  x,
  threshold,
  or.tied = TRUE,
  na.rm = TRUE,
  below = FALSE,
  one.cut.per.col = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] Data.frame or matrix of numbers to be compared to threshold value.

\item[\code{threshold}] numeric threshold value to compare to

\item[\code{or.tied}] if TRUE, include ties (value in x equals threshold)

\item[\code{na.rm}] if TRUE, used by colcounter to count only the non-NA columns in given row

\item[\code{below}] if TRUE, count x below threshold not above threshold

\item[\code{one.cut.per.col}] if FALSE, compare 1 threshold to all of x.
If TRUE, specify one threshold per column.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector of counts as long as NROW(x)
\end{Value}
%
\begin{SeeAlso}\relax
colcounter\_summary\_all() colcounter\_summary() colcounter\_summary\_cum() colcounter\_summary\_pct() colcounter\_summary\_cum\_pct() tablefixed()
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
 pdata <- data.frame(a=rep(80,4),b=rep(93,4), col3=c(49,98,100,100))
  ### pdata <- EJAM::blockgroupstats[ , names_e_pctile]
  ## or ## pdata <- ejscreen package file bg22[ , ejscreen package file names.e.pctile]
 pcuts <-  5 * (0:20)  # <- as.vector(keystats_e['highcut', ])
colcounter_summary(        pdata, pcuts)
colcounter_summary_pct(    pdata, pcuts)
colcounter_summary_cum(    pdata, pcuts)
colcounter_summary_cum_pct(pdata, pcuts)
colcounter_summary_cum_pct(pdata, 5 * (10:20))

x80 <- colcounter(pdata, threshold = 80, or.tied = T)
x95 <- colcounter(pdata, threshold = 95, or.tied = T)
table(x95)
tablefixed(x95, NCOL(pdata))
cbind(at80=tablefixed(x80, NCOL(pdata)), at95=tablefixed(x95, NCOL(pdata)))
  
## End(Not run)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{colcounter\_summary}{colcounter\_summary - Summarize how many rows have N columns at or above (or below) various thresholds? Like colcounter or cols.above.count but will handle multiple thresholds to compare to each indicator, etc. Table of counts, percents, cumulative counts, cumulative percents of places with N, or at least N, of the indicators at or above the benchmark(s)}{colcounter.Rul.summary}
%
\begin{Description}\relax
colcounter\_summary - Summarize how many rows have N columns at or above (or below) various thresholds?
Like colcounter or cols.above.count
but will handle multiple thresholds to compare to each indicator, etc.
Table of counts, percents, cumulative counts, cumulative percents
of places with N, or at least N, of the indicators
at or above the benchmark(s)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
colcounter_summary(
  x,
  thresholdlist,
  or.tied = TRUE,
  na.rm = TRUE,
  below = FALSE,
  one.cut.per.col = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] Data.frame or matrix of numbers to be compared to threshold value,
like percentiles for example.

\item[\code{thresholdlist}] vector of numeric threshold values to compare to

\item[\code{or.tied}] if TRUE, include ties (value in x equals threshold)

\item[\code{na.rm}] if TRUE, used by \code{\LinkA{colcounter()}{colcounter}} to count only the non-NA columns in given row

\item[\code{below}] if TRUE, count x below threshold not above threshold

\item[\code{one.cut.per.col}] if FALSE, compare each threshold to all of x.
If TRUE, specify one threshold to use for each column.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A table of frequency counts
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{colcounter\_summary\_all()}{colcounter.Rul.summary.Rul.all}} \code{\LinkA{colcounter\_summary()}{colcounter.Rul.summary}} \code{\LinkA{colcounter\_summary\_cum()}{colcounter.Rul.summary.Rul.cum}} \code{\LinkA{colcounter\_summary\_pct()}{colcounter.Rul.summary.Rul.pct}} \code{\LinkA{colcounter\_summary\_cum\_pct()}{colcounter.Rul.summary.Rul.cum.Rul.pct}}

\code{\LinkA{tablefixed()}{tablefixed}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
 pdata <- data.frame(a=rep(80,4),b=rep(93,4), col3=c(49,98,100,100))
  ### pdata <- EJAM::blockgroupstats[ , names_e_pctile]
 pcuts <-  5 * (0:20)  # <- as.vector(keystats_e['highcut', ])
colcounter_summary(        pdata, pcuts)
colcounter_summary_pct(    pdata, pcuts)
colcounter_summary_cum(    pdata, pcuts)
colcounter_summary_cum_pct(pdata, pcuts)
colcounter_summary_cum_pct(pdata, 5 * (10:20))
a3 <- colcounter_summary_all(    pdata, pcuts)

x80 <- colcounter(pdata, threshold = 80, or.tied = T)
x95 <- colcounter(pdata, threshold = 95, or.tied = T)
table(x95)
tablefixed(x95, NCOL(pdata))
cbind(at80=tablefixed(x80, NCOL(pdata)), at95=tablefixed(x95, NCOL(pdata)))
  
## End(Not run)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{colcounter\_summary\_all}{colcounter\_summary\_all - Summarize count (and percent) of rows with exactly (and at least) N cols >= various thresholds}{colcounter.Rul.summary.Rul.all}
%
\begin{Description}\relax
Wraps 4 functions to return 4 tables:
using colcounter\_summary(), colcounter\_summary\_pct(),
colcounter\_summary\_cum(), colcounter\_summary\_cum\_pct()
\end{Description}
%
\begin{Usage}
\begin{verbatim}
colcounter_summary_all(x, thresholdlist, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] Data.frame or matrix of numbers to be compared to threshold value,
like percentiles for example.

\item[\code{thresholdlist}] vector of numeric threshold values to compare to

\item[\code{...}] passed to the 4 functions
like or.tied=TRUE, na.rm=TRUE, below=FALSE, one.cut.per.col=FALSE
\end{ldescription}
\end{Arguments}
%
\begin{SeeAlso}\relax
colcounter\_summary\_all() colcounter\_summary() colcounter\_summary\_cum() colcounter\_summary\_pct() colcounter\_summary\_cum\_pct()
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
    # df <-  bg22[ , names.ej.pctile]
 df <- data.frame(a=rep(80,4),b=rep(93,4), col3=c(49,98,100,100))
 bench <- 5 * (0:20)
 a3 <- colcounter_summary_all(df, bench)
 a3[,'95',]
 a3[,,'cum_pct']
 a3['0',,]; a3[1,,]
 a3[dim(a3)[1],,]
 # a3['12',,]; a3[13,,]

 barplot(colcounter_summary_cum_pct(pdata, pcuts)[ , '80'],
    ylab='% of places', xlab='# of indicators at/above threshold',
    main='% of places with at least N/12 indicators >=80th percentile')

 barplot(colcounter_summary(pdata, pcuts)[2:13 , '95'],
    ylab='# of places', xlab='# of indicators at/above threshold',
    main='# of places with exactly N/12 indicators >=95th percentile')

  # pdata <- ejscreen package file bg22[ , names.e.pctile]
  colcounter_summary_cum_pct(pdata,c(50,80,90,95))
  xs <- 1:12
  plot(x=xs, y=colcounter_summary_cum_pct(pdata, 50)[xs+1],
   type='b', col='gray', ylim=c(0, 100),
    main='% of places with at least x/12 indicators >=Nth percentile',
     ylab='% of places', xlab='# of indicators')
  points(xs, colcounter_summary_cum_pct(pdata, 80)[xs+1], type='b', col='blue')
  points(xs, colcounter_summary_cum_pct(pdata, 90)[xs+1], type='b', col='orange')
  points(xs, colcounter_summary_cum_pct(pdata, 95)[xs+1], type='b', col='red')
  legend(x = 'topright', legend = paste0('>= ', c(50, 80, 90, 95),'th percentile'),
   fill = c('gray', 'blue', 'orange', 'red'))

  # pdata <- bg22[ ,  names.ej.pctile]
  colcounter_summary_cum_pct(pdata,c(50,80,90,95))
  xs <- 1:12
  plot(x=xs, y=colcounter_summary_cum_pct(pdata, 50)[xs+1], 
    type='b', col='gray', ylim=c(0, 40),
    main='% of places with at least x/12 indicators >=Nth percentile', ylab='% of places', 
    xlab='# of indicators')
  points(xs, colcounter_summary_cum_pct(pdata, 80)[xs+1], type='b', col='blue')
  points(xs, colcounter_summary_cum_pct(pdata, 90)[xs+1], type='b', col='orange')
  points(xs, colcounter_summary_cum_pct(pdata, 95)[xs+1], type='b', col='red')
  legend(x = 'topright', legend = paste0('>= ', c(50, 80, 90, 95),'th percentile'), 
    fill = c('gray', 'blue', 'orange', 'red'))

## End(Not run)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{colcounter\_summary\_cum}{colcounter\_summary\_cum - Summarize how many rows have AT LEAST N columns at or above (or below) various thresholds See colcounter\_summary() for more info and examples.}{colcounter.Rul.summary.Rul.cum}
%
\begin{Description}\relax
colcounter\_summary\_cum - Summarize how many rows have AT LEAST N columns at or above (or below) various thresholds
See colcounter\_summary() for more info and examples.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
colcounter_summary_cum(
  x,
  thresholdlist,
  or.tied = TRUE,
  na.rm = TRUE,
  below = FALSE,
  one.cut.per.col = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] Data.frame or matrix of numbers to be compared to threshold value,
like percentiles for example.

\item[\code{thresholdlist}] vector of numeric threshold values to compare to

\item[\code{or.tied}] if TRUE, include ties (value in x equals threshold)

\item[\code{na.rm}] if TRUE, used by colcounter to count only the non-NA columns in given row

\item[\code{below}] if TRUE, count x below threshold not above threshold

\item[\code{one.cut.per.col}] if FALSE, compare each threshold to all of x.
If TRUE, specify one threshold to use for each column.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A table of cumulative frequency counts
\end{Value}
%
\begin{SeeAlso}\relax
colcounter\_summary\_all() colcounter\_summary() colcounter\_summary\_cum() colcounter\_summary\_pct() colcounter\_summary\_cum\_pct()
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{colcounter\_summary\_cum\_pct}{colcounter\_summary\_cum\_pct - Summarize what percent of rows have AT LEAST N columns at or above (or below) various thresholds}{colcounter.Rul.summary.Rul.cum.Rul.pct}
%
\begin{Description}\relax
colcounter\_summary\_cum\_pct - Summarize what percent of rows have AT LEAST N columns at or above (or below) various thresholds
\end{Description}
%
\begin{Usage}
\begin{verbatim}
colcounter_summary_cum_pct(x, thresholdlist, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] Data.frame or matrix of numbers to be compared to threshold value,
like percentiles for example.

\item[\code{thresholdlist}] vector of numeric threshold values to compare to

\item[\code{...}] passed to colcounter\_summary\_cum()
like or.tied=TRUE, na.rm=TRUE, below=FALSE, one.cut.per.col=FALSE
\end{ldescription}
\end{Arguments}
%
\begin{SeeAlso}\relax
colcounter\_summary\_all() colcounter\_summary() colcounter\_summary\_cum() colcounter\_summary\_pct() colcounter\_summary\_cum\_pct()
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{colcounter\_summary\_pct}{colcounter\_summary\_pct - Summarize what percent of rows have N columns at or above (or below) various thresholds}{colcounter.Rul.summary.Rul.pct}
%
\begin{Description}\relax
colcounter\_summary\_pct - Summarize what percent of rows have N columns at or above (or below) various thresholds
\end{Description}
%
\begin{Usage}
\begin{verbatim}
colcounter_summary_pct(x, thresholdlist, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] Data.frame or matrix of numbers to be compared to threshold value,
like percentiles for example.

\item[\code{thresholdlist}] vector of numeric threshold values to compare to

\item[\code{...}] passed to colcounter\_summary()
like or.tied=TRUE, na.rm=TRUE, below=FALSE, one.cut.per.col=FALSE
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
See examples for colcounter\_summary\_cum\_pct()
\end{Details}
%
\begin{SeeAlso}\relax
colcounter\_summary\_all() colcounter\_summary() colcounter\_summary\_cum() colcounter\_summary\_pct() colcounter\_summary\_cum\_pct()
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{counties\_as\_sites}{counties\_as\_sites - Analyze US Counties as if they were sites, to get EJ indicators summary for each county}{counties.Rul.as.Rul.sites}
%
\begin{Description}\relax
counties\_as\_sites - Analyze US Counties as if they were sites, to get EJ indicators summary for each county
\end{Description}
%
\begin{Usage}
\begin{verbatim}
counties_as_sites(fips)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{fips}] County FIPS vector (ideally as character not numeric values)
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This function provides one row per blockgroup.
\code{\LinkA{getblocksnearby\_from\_fips()}{getblocksnearby.Rul.from.Rul.fips}} provides one row per block.
\end{Details}
%
\begin{Value}
data.table with one row per blockgroup in these counties, or
all pairs of county fips - bgid, and a unique siteid assigned to each county
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{getblocksnearby\_from\_fips()}{getblocksnearby.Rul.from.Rul.fips}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
 counties_as_sites(c('01001','72153'))
 # Largest US Counties by ACS Population Totals:
 blockgroupstats[ , .(ST = ST[1], countypop = sum(pop)),
  by=.(FIPS = substr(bgfips,1,5))][order(-countypop),][1:20, .(
  CountyPopulation = prettyNum(countypop, big.mark = ","), FIPS, ST)]
 
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{count\_sites\_with\_n\_high\_scores}{count\_sites\_with\_n\_high\_scores}{count.Rul.sites.Rul.with.Rul.n.Rul.high.Rul.scores}
%
\begin{Description}\relax
count\_sites\_with\_n\_high\_scores
\end{Description}
%
\begin{Usage}
\begin{verbatim}
count_sites_with_n_high_scores(
  scores,
  thresholds = c(1.01, 1.5, 2, 3, 5, 10),
  xwide = c("statewide", "nationwide")[1]
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{scores}] score

\item[\code{thresholds}] thresholds

\item[\code{xwide}] xwide
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{dataload\_from\_aws}{dataload\_from\_aws - utility to load datasets from AWS DMAP Data Commons, into memory}{dataload.Rul.from.Rul.aws}
%
\begin{Description}\relax
dataload\_from\_aws - utility to load datasets from AWS DMAP Data Commons, into memory
\end{Description}
%
\begin{Usage}
\begin{verbatim}
dataload_from_aws(
  varnames = c("bgid2fips", "blockid2fips", "blockpoints", "blockwts", "quaddata"),
  ext = c(".arrow", ".rda")[2],
  fun = c("arrow::read_ipc_file", "load")[2],
  envir = globalenv(),
  mybucket = "dmap-data-commons-oa",
  mybucketfolder = "EJAM",
  folder_local_source = "~/../Downloads",
  justchecking = FALSE,
  check_server_even_if_justchecking = TRUE,
  testing = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{varnames}] character vector of the quoted names of the data objects like blockwts or quaddata

\item[\code{envir}] e.g., globalenv() or parent.frame()

\item[\code{mybucket}] where in AWS, like

\item[\code{mybucketfolder}] where in AWS, like EJAM

\item[\code{folder\_local\_source}] path of folder (not ending in forward slash) to
look in for locally saved copies during development
to avoid waiting for download from a server.

\item[\code{justchecking}] set to TRUE to get object size (and confirm file is accessible/exists)

\item[\code{check\_server\_even\_if\_justchecking}] set this to TRUE to stop checking server to see if files are there
when justchecking = TRUE. But server is always checked if justchecking = FALSE.

\item[\code{testing}] only for testing
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
See source code for details.

*** IF in interactive() mode, tries dataload\_from\_local() first
during development to avoid slow downloads.

Also see \url{https://shiny.posit.co/r/articles/improve/scoping/}

Does it require credentials?

Use dataload\_from\_aws(justchecking=TRUE),

or datapack("EJAM") to get info,

or tables(),

or object.size(quaddata)

NOTE: blockid2fips is HUGE in memory, and is used only in
state\_from\_blocktable() and state\_from\_blockid(), which are not always needed by the app,
so maybe should not load this unless/until needed?

blockid2fips is roughly 600 MB in RAM because it stores 8 million block FIPS as text.

List 9/2023 was:
\begin{itemize}

\item{} blockid2fips (20 MB on disk, approx 600 MB RAM !!)
\item{} quaddata (168 MB on disk, 218 MB RAM)
\item{} blockpoints (86 MB on disk, 156 MB RAM)
\item{} blockwts (31 MB on disk, 125 MB RAM)
\item{} bgid2fips (18 MB RAM)

\end{itemize}

\end{Details}
%
\begin{Value}
nothing - just loads data into environment (unless justchecking=T)
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{datapack()}{datapack}} \code{\LinkA{dataload\_from\_aws()}{dataload.Rul.from.Rul.aws}} \code{\LinkA{dataload\_from\_package()}{dataload.Rul.from.Rul.package}} \code{\LinkA{indexblocks()}{indexblocks}} \code{\LinkA{.onAttach()}{.onAttach}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{dataload\_from\_entirefolder}{dataload\_from\_entirefolder loads into global environment all .rda files found in specified folder}{dataload.Rul.from.Rul.entirefolder}
%
\begin{Description}\relax
dataload\_from\_entirefolder
loads into global environment all .rda files found in specified folder
\end{Description}
%
\begin{Usage}
\begin{verbatim}
dataload_from_entirefolder(folder = "./data")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{folder}] path
\end{ldescription}
\end{Arguments}
%
\begin{Value}
nothing. just loads to global envt
\end{Value}
\inputencoding{utf8}
\HeaderA{dataload\_from\_local}{dataload\_from\_local utility for R analysts/developers to store large block data locally instead of redownloading from AWS}{dataload.Rul.from.Rul.local}
%
\begin{Description}\relax
dataload\_from\_local
utility for R analysts/developers to store large block data locally instead of redownloading from AWS
\end{Description}
%
\begin{Usage}
\begin{verbatim}
dataload_from_local(
  varnames = c(c("blockwts", "quaddata", "blockpoints", "blockid2fips", "bgid2fips",
    "bgej"), c("frs", "frs_by_programid", "frs_by_naics", "frs_by_sic", "frs_by_mact")),
  ext = c(".arrow", ".rda")[1],
  fun = c("arrow::read_ipc_file", "load")[1],
  envir = globalenv(),
  folder_local_source = "~/../Downloads",
  justchecking = FALSE,
  testing = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{varnames}] use defaults

\item[\code{ext}] use defaults

\item[\code{fun}] use defaults

\item[\code{envir}] use defaults

\item[\code{folder\_local\_source}] Your local folder path

\item[\code{justchecking}] use defaults

\item[\code{testing}] use defaults
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
rm(bgid2fips, blockid2fips, blockpoints, blockwts, quaddata)

dataload\_from\_local(folder\_local\_source = '.')
\end{Details}
%
\begin{Value}
vector of paths to files (as derived from varnames) that were
actually found in folder\_local\_source,
but only for those not already in memory, so it is
just the ones loaded from disk because not already in memory and found on disk locally.
\end{Value}
\inputencoding{utf8}
\HeaderA{dataload\_from\_package}{dataload\_from\_package - utility to load a couple of datasets using data immediately instead of relying on lazy loading}{dataload.Rul.from.Rul.package}
%
\begin{Description}\relax
dataload\_from\_package - utility to load a couple of datasets using data immediately instead of relying on lazy loading
\end{Description}
%
\begin{Usage}
\begin{verbatim}
dataload_from_package(
  olist = c("blockgroupstats", "usastats", "statestats"),
  envir = globalenv()
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{olist}] vector of strings giving names of objects to load using data().
This could also include other large datasets that are slow to lazyload but not always needed:
"frs", "frs\_by\_programid ", "frs\_by\_naics", etc.

\item[\code{envir}] the environment into which they should be loaded
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
See also read\_builtin() function from the readr package!

Default is to load some but not all the datasets into memory immediately.
\LinkA{blockgroupstats}{blockgroupstats}, \LinkA{usastats}{usastats}, \LinkA{statestats}{statestats}, and some others are always essential to EJAM, but
\LinkA{frs}{frs} and \LinkA{frs\_by\_programid}{frs.Rul.by.Rul.programid} are huge datasets (and \LinkA{frs\_by\_sic}{frs.Rul.by.Rul.sic} and \LinkA{frs\_by\_naics}{frs.Rul.by.Rul.naics})
and not always used - only to find regulated facilities by ID, etc.
The frs-related datasets here can be roughly 1.5 GB in RAM, perhaps.
\end{Details}
%
\begin{Value}
Nothing
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{datapack()}{datapack}} \code{\LinkA{dataload\_from\_aws()}{dataload.Rul.from.Rul.aws}} \code{\LinkA{dataload\_from\_package()}{dataload.Rul.from.Rul.package}} \code{\LinkA{indexblocks()}{indexblocks}} \code{\LinkA{.onAttach()}{.onAttach}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
  x <- datapack("EJAM")
  subset(x, x$size >= 0.1) # at least 100 KB
  grep("names_", x$Item, value = T, ignore.case = T, invert = T) # most were like names_d, etc.
  ls()
  data("avg.in.us", package="EJAM") # lazy load an object into memory and make it visible to user
  ls()
  rm(avg.in.us, x)
  
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{dataload\_from\_pins}{dataload\_from\_pins - download / load datasets from pin board}{dataload.Rul.from.Rul.pins}
%
\begin{Description}\relax
dataload\_from\_pins - download / load datasets from pin board
\end{Description}
%
\begin{Usage}
\begin{verbatim}
dataload_from_pins(
  varnames = c(c("blockwts", "blockpoints", "blockid2fips"), "quaddata"),
  boardfolder = "Mark",
  auth = "auto",
  server = "https://rstudio-connect.dmap-stage.aws.epa.gov",
  envir = globalenv(),
  justchecking = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{varnames}] character vector of names of R objects to get from board

\item[\code{boardfolder}] if needed to specify a different folder than default

\item[\code{auth}] See help documentation for \code{\LinkA{pins::board\_connect()}{pins::board.Rul.connect()}}

\item[\code{server}] if needed to specify a server other than default (which might be
stored in envt variable CONNECT\_SERVER or be registered via the rsconnect package).
Note if auth = "envvar" then it looks for CONNECT\_SERVER to get name of server which
needs to be the full url starting with https:// - see help for board\_connect

\item[\code{envir}] if needed to specify environment other than default

\item[\code{justchecking}] can set to TRUE to just see a list of what pins are stored in that board
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This does work:

board <- pins::board\_connect(auth = "rsconnect")

assuming that credentials are set up for the user doing this.

This does work:

board <- pins::board\_connect(auth = 'manual', server = Sys.getenv("CONNECT\_SERVER"), key = Sys.getenv("CONNECT\_API\_KEY"))

if   Sys.setenv(CONNECT\_SERVER = "https://rstudio-connect.dmap-stage.aws.epa.gov")

and if  CONNECT\_API\_KEY  was set to the API key created already.
\end{Details}
%
\begin{Value}
a vector of names of objects downloaded if justchecking = FALSE, which excludes those
already in environment so not re-downloaded and excludes those not found in pin board.
If justchecking = TRUE, returns vector of names of ALL objects found in pin board,
regardless of whether they are already in the environment, and
regardless of whether they were specified among varnames.
\end{Value}
\inputencoding{utf8}
\HeaderA{datapack}{datapack - See info about the data sets in one or more packages - internal utility function Wrapper for data() and gets memory size of objects and silently returns a data.frame}{datapack}
%
\begin{Description}\relax
datapack - See info about the data sets in one or more packages - internal utility function
Wrapper for data() and gets memory size of objects and silently returns a data.frame
\end{Description}
%
\begin{Usage}
\begin{verbatim}
datapack(pkg = ejampackages, len = 30, sortbysize = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{pkg}] a character vector giving the package(s) to look in for data sets

\item[\code{len}] Only affects what is printed to console - specifies the
number of characters to limit Title to, making it easier to see in the console.

\item[\code{sortbysize}] if TRUE, sort by increasing size of object, within each package, not alpha.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
do not rely on this much - it was a quick utility. it also creates and leaves in global envt
objects in packages
\end{Details}
%
\begin{Value}
data.frame with Item and Title as columns
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
 datapack("datasets")
 datapack("MASS")
 y = datapack("EJAM")
 x = datapack(c("EJAM", "EJAMejscreenapi", "EJAMbatch.summarizer"))
 x[order(x$Package, x$Item), 1:3]
 tail(x[ , 1:3], 20)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{datawrite\_to\_aws}{datawrite\_to\_aws -  NOT YET WORKING - AccessDenied Write object(s) like a dataset to DMAP Data Commons, formatted as .arrow or .rda}{datawrite.Rul.to.Rul.aws}
%
\begin{Description}\relax
datawrite\_to\_aws -  NOT YET WORKING - AccessDenied
Write object(s) like a dataset to DMAP Data Commons, formatted as .arrow or .rda
\end{Description}
%
\begin{Usage}
\begin{verbatim}
datawrite_to_aws(
  varnames = c("bgid2fips", "blockid2fips", "blockpoints", "blockwts", "quaddata"),
  ext = c(".arrow", ".rda")[2],
  fun = c("arrow::write_ipc_file", "save")[2],
  mybucket = "dmap-data-commons-oa",
  mybucketfolder = "EJAM",
  justchecking = TRUE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{varnames}] vector of object names to upload

\item[\code{ext}] file .extension appropriate to the format and fun, like ".rda" or ".arrow"

\item[\code{fun}] function to use, but as a character string, like "arrow::write\_ipc\_file"
but fun is ignored if ext=".rda" since it then just uses s3save()

\item[\code{mybucket}] do not need to change

\item[\code{mybucketfolder}] do not need to change

\item[\code{justchecking}] set this to FALSE to actually upload instead of
just viewing in console the commands to be used, to test/check this
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
mybucket <-  'dmap-data-commons-oa' \#

bucket\_contents <- data.table::rbindlist(

\begin{alltt}get_bucket(bucket = mybucket, prefix = "EJAM"),

fill = TRUE
  
)
\end{alltt}


bucket\_contents
\end{Details}
%
\begin{Value}
the paths of the objects on server
\end{Value}
\inputencoding{utf8}
\HeaderA{datawrite\_to\_local}{datawrite\_to\_local Write large object(s) like EJAM datasets to local disk for convenience during app/pkg development, formatted as .arrow or .rda}{datawrite.Rul.to.Rul.local}
%
\begin{Description}\relax
datawrite\_to\_local
Write large object(s) like EJAM datasets to local disk for convenience during app/pkg development, formatted as .arrow or .rda
\end{Description}
%
\begin{Usage}
\begin{verbatim}
datawrite_to_local(
  varnames = c("bgid2fips", "blockid2fips", "blockpoints", "blockwts", "quaddata"),
  ext = c(".arrow", ".rda")[1],
  folder_local_source = "~/../Downloads",
  fun = c("arrow::write_ipc_file", "save")[1],
  justchecking = F,
  overwrite = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{varnames}] vector of object names

\item[\code{ext}] file .extension appropriate to the format, ".rda" or ".arrow"

\item[\code{folder\_local\_source}] path to local folder without slash at end

\item[\code{fun}] function to use, but as a character string, like "arrow::write\_ipc\_file"
but fun is ignored if ext=".rda" since it then just uses save()

\item[\code{justchecking}] set this to FALSE to actually save instead of
just seeing in console info or the commands to be used, to test/check this

\item[\code{overwrite}] Set to TRUE to overwrite file if it exists already, with new copy.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
the paths of the objects as requested to be saved whether or not actually done
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{datawrite\_to\_aws()}{datawrite.Rul.to.Rul.aws}}  \code{\LinkA{datawrite\_to\_local()}{datawrite.Rul.to.Rul.local}} \code{\LinkA{dataload\_from\_local()}{dataload.Rul.from.Rul.local}} \code{\LinkA{dataload\_from\_aws()}{dataload.Rul.from.Rul.aws}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
  # datawrite_to_local(ext = ".arrow", folder_local_source = ".", justchecking = F, overwrite = T) 
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{distance\_by\_group}{distance\_by\_group - Avg distance of each demog group (of multiple groups) Same as \code{\LinkA{plot\_distance\_mean\_by\_group()}{plot.Rul.distance.Rul.mean.Rul.by.Rul.group}} but no plot by default}{distance.Rul.by.Rul.group}
%
\begin{Description}\relax
distance\_by\_group - Avg distance of each demog group (of multiple groups)
Same as \code{\LinkA{plot\_distance\_mean\_by\_group()}{plot.Rul.distance.Rul.mean.Rul.by.Rul.group}} but no plot by default
\end{Description}
%
\begin{Usage}
\begin{verbatim}
distance_by_group(
  results_bybg_people,
  demogvarname = NULL,
  demoglabel = NULL,
  returnwhat = "table",
  graph = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{results\_bybg\_people}] data.table from doaggregate()\$results\_bybg\_people

\item[\code{demogvarname}] vector of column names like "pctlowinc" etc.

\item[\code{demoglabel}] vector of labels like "Low Income Residents" etc.

\item[\code{returnwhat}] If returnwhat is "table", invisibly returns a
data.frame with group, ratio, avg\_distance\_for\_group, avg\_distance\_for\_nongroup.
If returnwhat is "plotfilename" then it returns the full path including filename of a .png in a tempdir
If returnwhat is "plot" then it returns the plot object as needed for table\_xls\_format() ?
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
see examples in \code{\LinkA{plot\_distance\_cdf\_by\_group()}{plot.Rul.distance.Rul.cdf.Rul.by.Rul.group}}
\end{Details}
%
\begin{Value}
see parameter returnwhat
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{distance\_by\_group()}{distance.Rul.by.Rul.group}}

\code{\LinkA{distance\_by\_group\_plot()}{distance.Rul.by.Rul.group.Rul.plot}}  \code{\LinkA{plot\_distance\_cdf\_by\_group()}{plot.Rul.distance.Rul.cdf.Rul.by.Rul.group}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
 y <- ejamit(testpoints_100, radius = 3)
 plot_distance_mean_by_group(y$results_bybg_people) # or distance_mean_by_group() synonym
 print(distance_by_group(y$results_bybg_people, 
   demogvarname = 'pctlowinc', demoglabel = 'Low Income'))
 distance_by_group_plot(y$results_bybg_people, 
   demogvarname = 'pctlowinc', demoglabel = 'Low Income')
 xyz = plot_distance_cdf_by_group(y$results_bybg_people) #  
 tail(round(xyz,3))
 tail(xyz[xyz$pctwa <= 0.501, ]) #  Median distance to nearest site here 
   for White Alone is 2.15 miles, but >60% of Black Alone have a site that close.
 tail(xyz[xyz$pctba <= 0.501, ]) #  Median distance to nearest site here 
   for Black Alone is 1.85 miles
 round(tail(xyz[xyz$dist <=1, ]), 3) #  11% of White have a site within 1 mile, 
   compared to 18.7% of Asian who do.
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{distance\_by\_group1}{distance\_by\_group1  -  JUST ONE GROUP Get average distance for ONE demographic group versus everyone else}{distance.Rul.by.Rul.group1}
%
\begin{Description}\relax
distance\_by\_group1  -  JUST ONE GROUP
Get average distance for ONE demographic group versus everyone else
\end{Description}
%
\begin{Usage}
\begin{verbatim}
distance_by_group1(
  results_bybg_people,
  demogvarname = "Demog.Index",
  demoglabel = demogvarname
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{results\_bybg\_people}] data.table from doaggregate()\$results\_bybg\_people

\item[\code{demogvarname}] e.g., "pctlowinc"

\item[\code{demoglabel}] e.g., "Low Income Residents"
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Note on Avg Distance and range of distances in each Demog group, \& \%D as function of distance:

We have info on each blockgroup near each site, which means some small \% of those bgs are duplicated in this table:

\begin{alltt}results_bybg_people
\end{alltt}


Mostly we want overall (not by site) to know avg and cum distrib of distances in each demog,

(and also \%D as a function of continuous distance),

and for those stats we would want to take only unique blockgroups from here,
using the shorter distance, so the distribution of distances does not doublecount people.

But we might also want to see that distribution of distances by D for just 1 site?

And we might also want to see the \%D as a function of continuous distance at just 1 site?

So to retain flexibility doaggregate() reports all instances of blockgroup-site pairings.
\end{Details}
%
\begin{Value}
list of 2 numbers: avg\_distance\_for\_group and avg\_distance\_for\_nongroup
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{plot\_distance\_mean\_by\_group()}{plot.Rul.distance.Rul.mean.Rul.by.Rul.group}}  \code{\LinkA{distance\_by\_group()}{distance.Rul.by.Rul.group}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
 y <- ejamit(testpoints_100, radius = 3)
 plot_distance_mean_by_group(y$results_bybg_people) # or distance_mean_by_group() synonym
 print(distance_by_group(y$results_bybg_people, 
   demogvarname = 'pctlowinc', demoglabel = 'Low Income'))
 distance_by_group_plot(y$results_bybg_people, 
   demogvarname = 'pctlowinc', demoglabel = 'Low Income')
 xyz = plot_distance_cdf_by_group(y$results_bybg_people) #  
 tail(round(xyz,3))
 tail(xyz[xyz$pctwa <= 0.501, ]) #  Median distance to nearest site here 
   for White Alone is 2.15 miles, but >60% of Black Alone have a site that close.
 tail(xyz[xyz$pctba <= 0.501, ]) #  Median distance to nearest site here 
   for Black Alone is 1.85 miles
 round(tail(xyz[xyz$dist <=1, ]), 3) #  11% of White have a site within 1 mile, 
   compared to 18.7% of Asian who do.
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{distance\_by\_group\_by\_site}{distance\_by\_group\_by\_site - DRAFT FUNCTION}{distance.Rul.by.Rul.group.Rul.by.Rul.site}
%
\begin{Description}\relax
distance\_by\_group\_by\_site - DRAFT FUNCTION
\end{Description}
%
\begin{Usage}
\begin{verbatim}
distance_by_group_by_site(bybg)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{bybg}] such as \code{\LinkA{ejamit()}{ejamit}}\$results\_bybg\_people
\end{ldescription}
\end{Arguments}
%
\begin{Value}
table of ratios, one col per site, one row per indicator
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{plot\_distance\_cdf\_by\_group()}{plot.Rul.distance.Rul.cdf.Rul.by.Rul.group}} \code{\LinkA{plot\_distance\_mean\_by\_group()}{plot.Rul.distance.Rul.mean.Rul.by.Rul.group}} \code{\LinkA{distance\_by\_group()}{distance.Rul.by.Rul.group}} \code{\LinkA{distance\_mean\_by\_group()}{distance.Rul.mean.Rul.by.Rul.group}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{distance\_by\_group\_plot}{distance\_by\_group\_plot or plot\_distance\_cdf\_by\_group}{distance.Rul.by.Rul.group.Rul.plot}
%
\begin{Description}\relax
distance\_by\_group\_plot or plot\_distance\_cdf\_by\_group
\end{Description}
%
\begin{Usage}
\begin{verbatim}
distance_by_group_plot(...)
\end{verbatim}
\end{Usage}
%
\begin{Value}
see returnwhat parameter
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{distance\_by\_group()}{distance.Rul.by.Rul.group}} \code{\LinkA{ejamit()}{ejamit}} for examples
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
 y <- ejamit(testpoints_100, radius = 3)
 plot_distance_mean_by_group(y$results_bybg_people) # or distance_mean_by_group() synonym
 print(distance_by_group(y$results_bybg_people, 
   demogvarname = 'pctlowinc', demoglabel = 'Low Income'))
 distance_by_group_plot(y$results_bybg_people, 
   demogvarname = 'pctlowinc', demoglabel = 'Low Income')
 xyz = plot_distance_cdf_by_group(y$results_bybg_people) #  
 tail(round(xyz,3))
 tail(xyz[xyz$pctwa <= 0.501, ]) #  Median distance to nearest site here 
   for White Alone is 2.15 miles, but >60% of Black Alone have a site that close.
 tail(xyz[xyz$pctba <= 0.501, ]) #  Median distance to nearest site here 
   for Black Alone is 1.85 miles
 round(tail(xyz[xyz$dist <=1, ]), 3) #  11% of White have a site within 1 mile, 
   compared to 18.7% of Asian who do.
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{distance\_cdf\_by\_group\_plot}{distance\_cdf\_by\_group\_plot - SLOW - needs to be optimized Plot a graphic showing cumulative shares of ONLY ONE demographic group that are within each distance}{distance.Rul.cdf.Rul.by.Rul.group.Rul.plot}
%
\begin{Description}\relax
distance\_cdf\_by\_group\_plot - SLOW - needs to be optimized
Plot a graphic showing cumulative shares of ONLY ONE demographic group that are within each distance
\end{Description}
%
\begin{Usage}
\begin{verbatim}
distance_cdf_by_group_plot(
  results_bybg_people,
  radius_miles = round(max(results_bybg_people$distance_min_avgperson, na.rm = T), 1),
  demogvarname = "Demog.Index",
  demoglabel = demogvarname,
  color1 = "red",
  color2 = "black"
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{results\_bybg\_people}] data.table from doaggregate()\$results\_bybg\_people

\item[\code{radius\_miles}] miles radius that was max distance analyzed

\item[\code{demogvarname}] name of column in results\_bybg\_people, e.g., "pctlowinc"

\item[\code{demoglabel}] friendly text name for labelling graphic, like "Low income residents"

\item[\code{color1}] color like "red" for demographic group of interest

\item[\code{color2}] color like "gray" for everyone else
\end{ldescription}
\end{Arguments}
%
\begin{Value}
invisibly returns full table of sorted distances of blockgroups, cumulative count of demog group at that block group's distance,
and cumulative count of everyone else in that block group
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{distance\_by\_group()}{distance.Rul.by.Rul.group}} \code{\LinkA{getblocksnearbyviaQuadTree()}{getblocksnearbyviaQuadTree}} for examples
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
 y <- ejamit(testpoints_100, radius = 3)
 plot_distance_mean_by_group(y$results_bybg_people) # or distance_mean_by_group() synonym
 print(distance_by_group(y$results_bybg_people, 
   demogvarname = 'pctlowinc', demoglabel = 'Low Income'))
 distance_by_group_plot(y$results_bybg_people, 
   demogvarname = 'pctlowinc', demoglabel = 'Low Income')
 xyz = plot_distance_cdf_by_group(y$results_bybg_people) #  
 tail(round(xyz,3))
 tail(xyz[xyz$pctwa <= 0.501, ]) #  Median distance to nearest site here 
   for White Alone is 2.15 miles, but >60% of Black Alone have a site that close.
 tail(xyz[xyz$pctba <= 0.501, ]) #  Median distance to nearest site here 
   for Black Alone is 1.85 miles
 round(tail(xyz[xyz$dist <=1, ]), 3) #  11% of White have a site within 1 mile, 
   compared to 18.7% of Asian who do.
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{distance\_mean\_by\_group}{distance\_mean\_by\_group - Avg distance of each demog group (of multiple groups) Same as \code{\LinkA{plot\_distance\_mean\_by\_group()}{plot.Rul.distance.Rul.mean.Rul.by.Rul.group}} but no plot by default}{distance.Rul.mean.Rul.by.Rul.group}
%
\begin{Description}\relax
distance\_mean\_by\_group - Avg distance of each demog group (of multiple groups)
Same as \code{\LinkA{plot\_distance\_mean\_by\_group()}{plot.Rul.distance.Rul.mean.Rul.by.Rul.group}} but no plot by default
\end{Description}
%
\begin{Usage}
\begin{verbatim}
distance_mean_by_group(
  results_bybg_people,
  demogvarname = NULL,
  demoglabel = NULL,
  returnwhat = "table",
  graph = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{results\_bybg\_people}] data.table from doaggregate()\$results\_bybg\_people

\item[\code{demogvarname}] vector of column names like "pctlowinc" etc.

\item[\code{demoglabel}] vector of labels like "Low Income Residents" etc.

\item[\code{returnwhat}] If returnwhat is "table", invisibly returns a
data.frame with group, ratio, avg\_distance\_for\_group, avg\_distance\_for\_nongroup.
If returnwhat is "plotfilename" then it returns the full path including filename of a .png in a tempdir
If returnwhat is "plot" then it returns the plot object as needed for table\_xls\_format() ?
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Note that the ratio shown is a ratio of distance among others to distance of a given group,
so values below 1 mean the given demographic group lives closer to facilities.
A value of 0.85 would mean the group is only 85\% as far from a site as everyone else.

Note it is in miles assuming input was in miles, and the distance for each resident is
actually the average distance of all residents within their Census block (not block group),
and when a site is very close to the block internal point (like a centroid)
relative to the size of the block, the distance to the average resident in the block is
estimated as 90 percent of the effective radius, which is what the radius of the block
would be if it were the same area in square meters or miles but circular in shape.
This is the approach used in EJScreen to estimate average proximity of a block resident in
cases where the block is extremely close to the site or the site may actually be inside the block,
or exactly on top of the internal point of the block, in which case zero would not be an
appropriate estimate of the distance, hence this adjustment is made in EJAM getblocksnearby()
\end{Details}
%
\begin{Value}
see parameter returnwhat
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{distance\_by\_group()}{distance.Rul.by.Rul.group}}

\code{\LinkA{distance\_by\_group\_plot()}{distance.Rul.by.Rul.group.Rul.plot}}  \code{\LinkA{plot\_distance\_cdf\_by\_group()}{plot.Rul.distance.Rul.cdf.Rul.by.Rul.group}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
 y <- ejamit(testpoints_100, radius = 3)
 plot_distance_mean_by_group(y$results_bybg_people) # or distance_mean_by_group() synonym
 print(distance_by_group(y$results_bybg_people, 
   demogvarname = 'pctlowinc', demoglabel = 'Low Income'))
 distance_by_group_plot(y$results_bybg_people, 
   demogvarname = 'pctlowinc', demoglabel = 'Low Income')
 xyz = plot_distance_cdf_by_group(y$results_bybg_people) #  
 tail(round(xyz,3))
 tail(xyz[xyz$pctwa <= 0.501, ]) #  Median distance to nearest site here 
   for White Alone is 2.15 miles, but >60% of Black Alone have a site that close.
 tail(xyz[xyz$pctba <= 0.501, ]) #  Median distance to nearest site here 
   for Black Alone is 1.85 miles
 round(tail(xyz[xyz$dist <=1, ]), 3) #  11% of White have a site within 1 mile, 
   compared to 18.7% of Asian who do.
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{distance\_via\_surfacedistance}{distance\_via\_surfacedistance Convert surface distance to actual distance}{distance.Rul.via.Rul.surfacedistance}
%
\begin{Description}\relax
\begin{alltt}\bsl{}preformatted\{
    Just a simple formula:
   earthRadius_miles <- 3959
   angle_rad <- x/earthRadius_miles
   # Calculate  radius * cord length
   return( earthRadius_miles * 2*sin(angle_rad/2) )
   \}
\end{alltt}

\end{Description}
%
\begin{Usage}
\begin{verbatim}
distance_via_surfacedistance(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] surface distance in miles
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{doaggregate}{doaggregate - Summarize indicators in each buffer (given the blocks in each buffer and indicators for each block)}{doaggregate}
%
\begin{Description}\relax
This updated 2023 code takes a set of facilities and the set of blocks that are near each,
(as identified previously, in other code that has identified which blocks are nearby)
and combines those with indicator scores for block groups.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
doaggregate(
  sites2blocks,
  sites2states_or_latlon = NA,
  radius = NULL,
  countcols = NULL,
  popmeancols = NULL,
  calculatedcols = NULL,
  testing = FALSE,
  include_ejindexes = FALSE,
  updateProgress = NULL,
  need_proximityscore = FALSE,
  calculate_ratios = TRUE,
  silentinteractive = TRUE,
  called_by_ejamit = FALSE,
  subgroups_type = "nh",
  extra_demog = TRUE,
  infer_sitepoints = FALSE,
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{sites2blocks}] data.table of distances in miles between all sites (facilities) and
nearby Census block internal points, with columns siteid, blockid, distance,
created by getblocksnearby  function.
See \LinkA{sites2blocks\_example10pts\_1miles}{sites2blocks.Rul.example10pts.Rul.1miles} aka \LinkA{testoutput\_getblocksnearby\_10pts\_1miles}{testoutput.Rul.getblocksnearby.Rul.10pts.Rul.1miles} dataset in package, as input to this function

\item[\code{sites2states\_or\_latlon}] data.table or just data.frame, with columns siteid (each unique one in sites2blocks) and ST (2-character State abbreviation) or lat and lon

\item[\code{radius}] Optional radius in miles to limit analysis to. By default this function uses
all the distances that were provided in the output of getblocksnearby(),
and reports radius estimated as rounded max of distance values in inputs to doaggregate.
But there may be cases where you want to run getblocksnearby() once for 10 miles, say,
on a very long list of sites (1,000 or more, say), and then get summary results for
1, 3, 5, and 10 miles without having to redo the getblocksnearby() part for each radius.
This lets you just run getblocksnearby() once for the largest radius, and then query those
results to get doaggregate() to summarize at any distance that is less than or equal to the
original radius analyzed by getblocksnearby().

\item[\code{countcols}] character vector of names of variables  to aggregate within a buffer
using a sum of counts, like, for example, the number of people for whom a
poverty ratio is known, the count of which is the exact denominator needed
to correctly calculate percent low income.

\item[\code{popmeancols}] character vector of names of variables to aggregate within a buffer
using population weighted mean.

\item[\code{calculatedcols}] character vector of names of variables to aggregate within a buffer
using formulas that have to be specified.

\item[\code{testing}] used while testing this function

\item[\code{include\_ejindexes}] whether to calculate EJ Indexes and return that information

\item[\code{updateProgress}] progress bar function used for shiny app

\item[\code{need\_proximityscore}] whether to calculate proximity scores

\item[\code{calculate\_ratios}] whether to calculate and return ratio of each indicator to its US and State overall mean

\item[\code{silentinteractive}] Set to TRUE to see results in RStudio console.
Set to FALSE to prevent long output showing in console in RStudio when in interactive mode

\item[\code{called\_by\_ejamit}] Set to TRUE by ejamit() to suppress some outputs even if ejamit(silentinteractive=F)

\item[\code{subgroups\_type}] Optional (uses default). Set this to
"nh" for non-hispanic race subgroups as in Non-Hispanic White Alone, nhwa and others in names\_d\_subgroups\_nh;
"alone" for EJScreen v2.2 style race subgroups as in    White Alone, wa and others in names\_d\_subgroups\_alone;
"both" for both versions. Possibly another option is "original" or "default" but work in progress.

\item[\code{extra\_demog}] if should include more indicators from v2.2 report on language etc.

\item[\code{infer\_sitepoints}] set to TRUE to try to infer the lat,lon of each site around which the blocks in sites2blocks were found.
lat,lon of each site will be approximated as average of nearby blocks, although a more accurate slower way would
be to use reported distance of each of 3 of the furthest block points and triangulate

\item[\code{...}] more to pass to another function? Not used currently.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
For all examples, see \code{\LinkA{getblocksnearbyviaQuadTree()}{getblocksnearbyviaQuadTree}}

This function aggregates the blockgroup scores to create a summary of each indicator,
as a raw score and US percentile and State percentile,
in each buffer (i.e., near each facility):
\begin{itemize}

\item{} \strong{SUMS OF COUNTS}: for population count, or number of households or Hispanics, etc.
\item{} \strong{POPULATION-WEIGHTED MEANS}: for  Environmental indicators.

\emph{\strong{EJ Indexes}:} The way EJScreen
does this is apparently finding the pop wtd mean of EJ Index raw scores,
not the EJ Index formula applied to the summarized demographic score and aggregated envt number.
\item{} \strong{CALCULATED BY FORMULA}: Buffer or overall score calculated via formulas using aggregated counts,
such as percent low income = sum of counts low income / sum of counts of denominator,
which in this case is the count of those for whom the poverty ratio is known.
\item{} \strong{LOOKED UP}: Aggregated scores are converted into percentile terms via lookup tables (US or State version).

\end{itemize}


This function requires the following datasets:
\begin{itemize}

\item{} blockwts: data.table with these columns: blockid , bgid, blockwt
\item{} quaddata data.table used to create localtree, a quad tree index of block points
(and localtree that is created when package is loaded)
\item{} blockgroupstats - A data.table (such as EJScreen demographic and environmental data by blockgroup?)

\end{itemize}

\end{Details}
%
\begin{Value}
list with named elements:
\begin{itemize}

\item{} \strong{\code{results\_overall}}   one row data.table, like results\_by\_site, but just one row with
aggregated results for all unique residents.
\item{} \strong{\code{results\_by\_site}}   results for individual sites (buffers) - a data.table of results,
one row per siteid, one column per indicator
\item{} \strong{results\_bybg\_people}  results for each block group, to allow for showing the distribution of each
indicator across everyone within each demographic group.
\item{} \strong{longnames}  descriptive long names for the indicators in the above outputs
\item{} \strong{count\_of\_blocks\_near\_multiple\_sites}  additional detail

\end{itemize}

\end{Value}
%
\begin{SeeAlso}\relax
\LinkA{ejamit}{ejamit}   \code{\LinkA{getblocksnearby()}{getblocksnearby}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{dupenames}{dupenames - UTILITY - check conflicting exported function or data names}{dupenames}
%
\begin{Description}\relax
See what same-named objects (functions or data) are exported by some (installed) packages
\end{Description}
%
\begin{Usage}
\begin{verbatim}
dupenames(
  pkg = EJAM::ejampackages,
  sortbypkg = FALSE,
  compare.functions = TRUE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{pkg}] one or more package names as vector of strings.
If "all" it checks all installed pkgs, but takes very very long potentially.

\item[\code{sortbypkg}] If TRUE, just returns same thing but sorted by package name

\item[\code{compare.functions}] If TRUE, sends to console inf about whether body and formals
of the functions are identical between functions of same name from different packages.
Only checks the first 2 copies, not any additional ones (where 3+ pkgs use same name)
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
utility to find same-named exported objects (functions or datasets) within source code
of 2+ packages, and see what is on search path, for dev renaming / moving functions/ packages
\end{Details}
%
\begin{Value}
data.frame with columns Package, Object name (or NA if no dupes)
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{all\_equal\_functions()}{all.Rul.equal.Rul.functions}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{dupeRfiles}{dupeRfiles - UTILITY - check conflicting sourcefile names}{dupeRfiles}
%
\begin{Description}\relax
See what same-named .R files are in 2 sourcecode folders
\end{Description}
%
\begin{Usage}
\begin{verbatim}
dupeRfiles(folder1 = "../EJAM/R", folder2 = "./R")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{folder1}] path to other folder with R source files

\item[\code{folder2}] path to a folder with R source files, defaults to "./R"
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
useful for shiny app that is not a package,
as ejamlite and EJAMejscreenapi had copies of some EJAM files.

See \code{\LinkA{dupenames()}{dupenames}} for when they are all packages.
\end{Details}
\inputencoding{utf8}
\HeaderA{ejam2excel}{ejam2excel - alias for table\_xls\_from\_ejam()}{ejam2excel}
%
\begin{Description}\relax
ejam2excel - alias for table\_xls\_from\_ejam()
\end{Description}
%
\begin{Usage}
\begin{verbatim}
ejam2excel(
  ejamitout,
  fname = NULL,
  save_now = TRUE,
  overwrite = TRUE,
  launchexcel = FALSE,
  interactive_console = TRUE,
  ok2plot = TRUE,
  in.testing = FALSE,
  in.analysis_title = "EJAM analysis",
  react.v1_summary_plot = NULL,
  radius_or_buffer_in_miles = NULL,
  buffer_desc = "Selected Locations",
  radius_or_buffer_description =
    "Miles radius of circular buffer (or distance used if buffering around polygons)",
  hyperlink_colnames = c("EJScreen Report", "EJScreen Map", "ECHO report"),
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{ejamitout}] output of \code{\LinkA{ejamit()}{ejamit}}

\item[\code{fname}] optional name or full path and name of file to save locally, like "out.xlsx"

\item[\code{save\_now}] optional logical, whether to save as a .xlsx file locally or just return workbook object
that can later be written to .xlsx file using \code{\LinkA{openxlsx::saveWorkbook()}{openxlsx::saveWorkbook()}}

\item[\code{overwrite}] optional logical, passed to \code{\LinkA{openxlsx::saveWorkbook()}{openxlsx::saveWorkbook()}}

\item[\code{launchexcel}] optional logical, passed to \code{\LinkA{table\_xls\_format()}{table.Rul.xls.Rul.format}}, whether to launch browser to see spreadsheet immediately

\item[\code{interactive\_console}] optional - should set to FALSE when used in code or server. If TRUE,
prompts RStudio user interactively asking where to save the downloaded file

\item[\code{ok2plot}] optional logical, passed to  \code{\LinkA{table\_xls\_format()}{table.Rul.xls.Rul.format}}, whether safe to try and plot or set FALSE if debugging plot problems

\item[\code{in.testing}] optional logical

\item[\code{in.analysis\_title}] optional title as character string

\item[\code{react.v1\_summary\_plot}] optional - a plot object

\item[\code{radius\_or\_buffer\_in\_miles}] optional radius in miles

\item[\code{radius\_or\_buffer\_description}] optional text phrase describing places analyzed

\item[\code{hyperlink\_colnames}] optional names of columns with URLs

\item[\code{...}] optional additional parameters passed to \code{\LinkA{table\_xls\_format()}{table.Rul.xls.Rul.format}}, such as
heatmap\_colnames, heatmap\_cuts, heatmap\_colors, etc.
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{ejamit}{ejamit - Get complete EJ analysis (demographic and environmental indicators) near a list of locations}{ejamit}
%
\begin{Description}\relax
This is the main function in EJAM for users who want to use EJAM from RStudio.
It does essentially what the webapp does to analyze/summarize near a set of points.
See help("EJAM")
\end{Description}
%
\begin{Usage}
\begin{verbatim}
ejamit(
  sitepoints,
  radius = 3,
  maxradius = 31.07,
  avoidorphans = FALSE,
  quadtree = NULL,
  quiet = TRUE,
  parallel = FALSE,
  fips = NULL,
  shapefile_folder = NULL,
  in_shiny = FALSE,
  need_blockwt = TRUE,
  countcols = NULL,
  popmeancols = NULL,
  calculatedcols = NULL,
  testing = FALSE,
  include_ejindexes = FALSE,
  updateProgress = NULL,
  need_proximityscore = FALSE,
  calculate_ratios = TRUE,
  silentinteractive = FALSE,
  called_by_ejamit = TRUE,
  subgroups_type = "nh",
  extra_demog = TRUE,
  infer_sitepoints = FALSE,
  threshold1 = 90
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{sitepoints}] data.table with columns siteid, lat, lon giving point locations of sites or facilities around which are circular buffers

\item[\code{radius}] in miles, defining circular buffer around a site point

\item[\code{maxradius}] miles distance (max distance to check if not even 1 block point is within radius)

\item[\code{avoidorphans}] logical If TRUE, then where not even 1 BLOCK internal point is within radius of a SITE,
it keeps looking past radius, up to maxradius, to find nearest 1 BLOCK.
What EJScreen does in that case is report NA, right?
So, does EJAM really need to report stats on residents presumed to be within radius,
if no block centroid is within radius?
Best estimate might be to report indicators from nearest block centroid
which is probably almost always the one your site is sitting inside of,
but ideally would adjust total count to be a fraction of blockwt
based on what is area of circular buffer as fraction of area of block it is apparently inside of.
Setting this to TRUE can produce unexpected results, which will not match EJScreen numbers.

Note that if creating a proximity score, by contrast, you
instead want to find nearest 1 SITE if none within radius of this BLOCK.

\item[\code{quadtree}] (a pointer to the large quadtree object) created using indexblocks() which uses the SearchTree package.
Takes about 2-5 seconds to create this each time it is needed.
It can be automatically created when the package is attached via the .onAttach() function

\item[\code{quiet}] Optional. set to TRUE to avoid message about using getblock\_diagnostics(),
which is relevant only if a user saved the output of this function.

\item[\code{parallel}] whether to use parallel processing in getblocksnearby() but may not be implemented yet.

\item[\code{fips}] optional FIPS code vector to provide if using FIPS instead of sitepoints to specify places to analyze,
such as a list of US Counties or tracts. Passed to \code{\LinkA{getblocksnearby\_from\_fips()}{getblocksnearby.Rul.from.Rul.fips}}

\item[\code{in\_shiny}] if fips parameter is used, passed to \code{\LinkA{getblocksnearby\_from\_fips()}{getblocksnearby.Rul.from.Rul.fips}}

\item[\code{need\_blockwt}] if fips parameter is used, passed to \code{\LinkA{getblocksnearby\_from\_fips()}{getblocksnearby.Rul.from.Rul.fips}}

\item[\code{countcols}] character vector of names of variables to aggregate within a buffer using a sum of counts,
like, for example, the number of people for whom a poverty ratio is known,
the count of which is the exact denominator needed to correctly calculate percent low income.

\item[\code{popmeancols}] character vector of names of variables to aggregate within a buffer using population weighted mean.

\item[\code{calculatedcols}] character vector of names of variables to aggregate within a buffer using formulas that have to be specified.

\item[\code{testing}] used while testing this function

\item[\code{include\_ejindexes}] whether to try to include EJ Indexes (assuming dataset is available) - passed to \code{\LinkA{doaggregate()}{doaggregate}}

\item[\code{updateProgress}] progress bar function used for shiny app

\item[\code{need\_proximityscore}] whether to calculate proximity scores

\item[\code{calculate\_ratios}] whether to calculate and return ratio of each indicator to US and State overall averages - passed to \code{\LinkA{doaggregate()}{doaggregate}}

\item[\code{silentinteractive}] to prevent long output showing in console in RStudio when in interactive mode,
passed to doaggregate() also. app server sets this to TRUE when calling doaggregate() but
ejamit() default is to set this to FALSE when calling doaggregate().

\item[\code{called\_by\_ejamit}] Set to TRUE by ejamit() to suppress some outputs even if ejamit(silentinteractive=F)

\item[\code{subgroups\_type}] Optional (uses default). Set this to "nh" for non-hispanic race subgroups
as in Non-Hispanic White Alone, nhwa and others in names\_d\_subgroups\_nh;
"alone" for EJScreen v2.2 style race subgroups as in White Alone, wa and others in names\_d\_subgroups\_alone;
"both" for both versions. Possibly another option is "original" or "default"

\item[\code{extra\_demog}] if should include more indicators from v2.2 report on language etc.

\item[\code{infer\_sitepoints}] set to TRUE to try to infer the lat,lon of each site around which the blocks in sites2blocks were found.
lat,lon of each site will be approximated as average of nearby blocks,
although a more accurate slower way would be to use reported distance of each of 3 of the furthest block points and triangulate

\item[\code{threshold1}] percentile like 80 or 90 or 95 to compare percentiles to
"alone" for groups like white alone (whether or not hispanic),
"both" may try to include both,
or possibly "original" or "default" might be added as options - passed to batch.summarize()
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list of tables of results
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{getblocksnearby()}{getblocksnearby}} \code{\LinkA{doaggregate()}{doaggregate}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
 # All in one step, using functions not shiny app:
 out <- ejamit(testpoints_100_dt, 2, quadtree=localtree)

 # Do not specify sitepoints and it will prompt you for a file,
 # if in RStudio in interactive mode!
 out <- ejamit(radius = 3)
 
  # Specify facilities or sites as points for test data, 
  # use 1000 test facility points from the R package 
  testsites <- testpoints_1000_dt
  # use facility points in an excel or csv file
  testsites <- latlon_from_anything(
   "./inst/testdata/testpoints_207_sites_with_signif_violations_NAICS_326_ECHO.csv")
  # use facility points from a random sample of EPA-regulated facilities
  testsites <- testpoints_n(1e3)  
  
  # Specify max distance from sites to look at (residents within X miles of site point)
  radius <- 3.1 # miles
  
  # Get summaries of all indicators near a set of points 
  out <- ejamit(testsites, radius)  
  # out <- ejamit("myfile.xlsx", 3.1)  
  
  # out2 <- ejscreenit(testpoints_05)
  
  # View results overall
  round(t(out$results_overall), 3.1)
  
  # View plots
  # plot_distance_avg_by_group(out)  
  # plot_distance_cdf_by_group(out)
  
  # View maps
  mapfast(out$results_bysite, radius = 3.1)
  
  # view results at a single site
  t(out$results_bysite[1, ])
  t(out$results_bysite[out$results_bysite$siteid == 2, ])
  
  
  # if doing just 1st step of ejamit() 
  #  get distance between each site and every nearby Census block
  s2b <- testdata_sites2blocks
  s2b <- getblocksnearby(testsites, radius = radius)
  s2b <- getblocksnearbyviaQuadTree(testsites, radius = radius)
  getblocks_diagnostics(s2b)
  plotblocksnearby(s2b)
   
  # if doing just 2d step of ejamit()
  #  get summaries of all indicators based on table of distances
  out <- doaggregate(s2b, testsites) # this works now and is simpler


## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{ejampackages}{ejampackages (DATA) list of names of key EJAM-related R packages}{ejampackages}
%
\begin{Description}\relax
ejampackages (DATA) list of names of key EJAM-related R packages
\end{Description}
\inputencoding{utf8}
\HeaderA{ejscreenit\_for\_ejam}{ejscreenit\_for\_ejam - DRAFT Wrapper for ejscreenit() from EJAMejscreenapi package, to use in EJAM app - NOT USED CURRENTLY}{ejscreenit.Rul.for.Rul.ejam}
%
\begin{Description}\relax
ejscreenit\_for\_ejam - DRAFT
Wrapper for ejscreenit() from EJAMejscreenapi package, to use in EJAM app - NOT USED CURRENTLY
\end{Description}
%
\begin{Usage}
\begin{verbatim}
ejscreenit_for_ejam(sitepoints, radius = 3, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{sitepoints}] table with lat and lon columns

\item[\code{radius}] in miles

\item[\code{...}] passed to ejscreenit() but not tested and probably should not use/ not needed
\end{ldescription}
\end{Arguments}
%
\begin{Value}
list of results from ejscreenit()
i.e., list of these: results\_bysite (data.table), map, plot, us.ratios
\end{Value}
\inputencoding{utf8}
\HeaderA{fips2countyname}{fips2countyname - Get county names from county FIPS codes Get county names from county FIPS codes}{fips2countyname}
%
\begin{Description}\relax
fips2countyname - Get county names from county FIPS codes
Get county names from county FIPS codes
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fips2countyname(fips, includestate = c("ST", "Statename", "")[1])
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{fips}] vector of US Census FIPS codes for Counties (5 digits each). can be string or numeric, with or without leading zeroes.

\item[\code{includestate}] can be ST, Statename, "", or TRUE to specify what if anything comes after county name and comma
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector of county names, optionally with comma and 2-character abbreviation or full state name.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
  # names of all counties in ME and NY
  fips2countyname(fips_counties_from_state_abbrev(c("ME", "NY")), includestate = "ST")
   fips_counties_from_state_abbrev(c("AK", "LA"))  
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fips2name}{fips2name - Get county or state names from county or state FIPS codes Get county or state names from county or state FIPS codes}{fips2name}
%
\begin{Description}\relax
fips2name - Get county or state names from county or state FIPS codes
Get county or state names from county or state FIPS codes
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fips2name(fips, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{fips}] vector of US Census FIPS codes for Counties (5 digits each) or States (2 digits).
Can be string or numeric, with or without leading zeroes.

\item[\code{...}] passed to fips2countyname() to control whether it appends something like , NY or , New York
after county name
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector of state and/or county names,
where county names optionally have comma and 2-character abbreviation or full state name.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
  fips2name(fips_counties_from_state_abbrev(c("AK", "LA"))  )
  fips2name(c(22, 02013))  # can have mix where some are a whole state and others are a county.
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fips2statename}{fips2statename - Get state names from any type of FIPS codes Get state names from any type of FIPS codes}{fips2statename}
%
\begin{Description}\relax
fips2statename - Get state names from any type of FIPS codes
Get state names from any type of FIPS codes
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fips2statename(fips)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{fips}] vector of FIPS
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector of state names
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
  cbind(fips_lead_zero(1:80), fips2state_abbrev(1:80), fips2statename(1:80))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fips2state\_abbrev}{fips2state\_abbrev - Get state abbreviations from any type of FIPS codes Get state abbreviations from any type of FIPS codes}{fips2state.Rul.abbrev}
%
\begin{Description}\relax
fips2state\_abbrev - Get state abbreviations from any type of FIPS codes
Get state abbreviations from any type of FIPS codes
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fips2state_abbrev(fips)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{fips}] vector of FIPS
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector of abbreviations like "NY", "LA", "DE", etc.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
  cbind(
    stfips    = fips_lead_zero(1:80), 
    ST     = fips2state_abbrev(1:80), 
    statename = fips2statename(1:80)
  )
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fips2state\_fips}{fips2state\_fips - Get state FIPS codes from any type of FIPS codes Get state FIPS codes from any type of FIPS codes}{fips2state.Rul.fips}
%
\begin{Description}\relax
fips2state\_fips - Get state FIPS codes from any type of FIPS codes
Get state FIPS codes from any type of FIPS codes
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fips2state_fips(fips)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{fips}] vector of FIPS
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Tells you which State contains each County (or tract or blockgroup or block)
\end{Details}
%
\begin{Value}
vector of State FIPS 2 characters each
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
  fips2state_fips(fips_counties_from_statename(c("Delaware", "Rhode Island")))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fipstype}{fipstype  -  identify what type of Census geography is each FIPS code (block, county, etc.)}{fipstype}
%
\begin{Description}\relax
fipstype  -  identify what type of Census geography is each FIPS code (block, county, etc.)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fipstype(fips)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{fips}] vector of one or more Census FIPS with or without leading zeroes, as strings or numeric
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector of types: "block", "blockgroup", "tract", "county", or "state"
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
 fips_counties_from_statename(c("Connecticut", "Delaware") )
 # [1] "09001" "09003" "09005" "09007" "09009" "09011" "09013" "09015" "10001" "10003" "10005"
 fipstype(9001)
 fipstype("10001")
 # note blockid2fips is a large file, but can be obtained via [dataload_from_pins()]
 ## Not run: 
 fipsexamples <- c(
   fips_state_from_statename("Alaska"),
   fips_counties_from_state_abbrev("DE")[1],
    substr(blockid2fips$blockfips[1],1,11),
    blockgroupstats$bgfips[1],
    blockid2fips$blockfips[1]
 )
 cbind(fipsexamples, type = fipstype(fipsexamples))

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fips\_bg\_from\_anyfips}{fips\_bg\_from\_anyfips - Get unique blockgroup fips in or containing specified fips of any type Convert any FIPS codes to the FIPS of all the blockgroups that are among or within or containing those FIPS}{fips.Rul.bg.Rul.from.Rul.anyfips}
%
\begin{Description}\relax
fips\_bg\_from\_anyfips - Get unique blockgroup fips in or containing specified fips of any type
Convert any FIPS codes to the FIPS of all the blockgroups that are
among or within or containing those FIPS
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fips_bg_from_anyfips(fips)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{fips}] vector of US FIPS codes, as character or numeric,
with or without their leading zeroes, each with as many characters
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This is a way to get a list of blockgroups, specified by state/county/tract or even block.

Takes a vector of one or more FIPS that could be State (2-digit), County (5-digit),
Tract (11-digit), or blockgroup (12 digit), or even block (15-digit fips).

Returns unique vector of FIPS of all US blockgroups (including DC and Puerto Rico)
that contain any specified blocks, are equal to any specified blockgroup fips,
or are contained within any provided tract/county/state FIPS.
\end{Details}
%
\begin{Value}
vector of blockgroup FIPS (or NA values) that may be much longer than the
vector of fips passed to this function.
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{fips\_lead\_zero()}{fips.Rul.lead.Rul.zero}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}

  # all blockgroups in one state
  fips_counties_from_state_abbrev("DE")
  fips_bg_from_anyfips( fips_counties_from_state_abbrev("DE") )
  
  blockgroupstats[,.N,by=substr(bgfips,1,2)]
  length(fips_bg_from_anyfips("72"))
  
  # all blockgroups in this one county
  fips_bg_from_anyfips(30001)
  fips_bg_from_anyfips("30001")
  
  # all blockgroups that contain any of these 6 blocks (i.e., just one bg)
  fips_bg_from_anyfips( blockid2fips$blockfips[1:6])
  
  # 2 counties
  fips_bg_from_anyfips(c(36009,36011))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fips\_counties\_from\_statefips}{fips\_counties\_from\_statefips - Get ALL county fips in specified states Get all county fips in specified states}{fips.Rul.counties.Rul.from.Rul.statefips}
%
\begin{Description}\relax
fips\_counties\_from\_statefips - Get ALL county fips in specified states
Get all county fips in specified states
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fips_counties_from_statefips(statefips)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{statefips}] vector of 2-digit state FIPS codes like c("10", "44", "44") or c(10,44)
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Very similar to list\_counties(state) from the tigris package.
\end{Details}
%
\begin{Value}
vector of 5-digit character string county FIPS of all unique counties in those states
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
  fips_counties_from_statefips(c(10,44,44))
  fips_counties_from_statefips("10")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fips\_counties\_from\_statename}{fips\_counties\_from\_statename - Get ALL county fips in specified states Get all county fips in specified states}{fips.Rul.counties.Rul.from.Rul.statename}
%
\begin{Description}\relax
fips\_counties\_from\_statename - Get ALL county fips in specified states
Get all county fips in specified states
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fips_counties_from_statename(statename)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{statename}] vector of state names like c("New York","Georgia")
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector of 5-digit character string county FIPS of all unique counties in those states
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
fips_counties_from_statename("Delaware")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fips\_counties\_from\_state\_abbrev}{fips\_counties\_from\_state\_abbrev - Get ALL county fips in specified states Get all county fips in specified states}{fips.Rul.counties.Rul.from.Rul.state.Rul.abbrev}
%
\begin{Description}\relax
fips\_counties\_from\_state\_abbrev - Get ALL county fips in specified states
Get all county fips in specified states
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fips_counties_from_state_abbrev(ST)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{ST}] vector of state abbreviations like c("NY","GA")
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector of 5-digit character string county FIPS of all unique counties in those states
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
  fips_counties_from_state_abbrev("DE")
  fips_counties_from_state_abbrev("RI", "RI")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fips\_from\_table}{fips\_from\_table - read and clean FIPS column from a table, after inferring which col it is Just read the codes in one column of a table obtained from something like read.csv, or excel, etc.}{fips.Rul.from.Rul.table}
%
\begin{Description}\relax
fips\_from\_table - read and clean FIPS column from a table, after inferring which col it is
Just read the codes in one column of a table obtained from something like read.csv, or excel, etc.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fips_from_table(fips_table, addleadzeroes = TRUE, inshiny = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{fips\_table}] data.frame or data.table of FIPS codes for counties, states, or tracts,
for example, in a column whose name can be interpreted as FIPS
(is one of the aliases like fips, countyfips, etc.)
Aliases are: c("FIPS", "fips", "fips\_code", "fipscode", "Fips", "statefips",
"countyfips", "ST\_FIPS", "st\_fips", "ST\_FIPS", "st\_fips", "FIPS.ST",
"FIPS.COUNTY", "FIPS.TRACT")

\item[\code{addleadzeroes}] whether to add leading zeroes where needed as for a State whose FIPS starts with "01"

\item[\code{inshiny}] used by server during shiny app
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a vector of fips codes
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{fips\_bg\_from\_anyfips()}{fips.Rul.bg.Rul.from.Rul.anyfips}} \code{\LinkA{fips\_lead\_zero()}{fips.Rul.lead.Rul.zero}} \code{\LinkA{getblocksnearby\_from\_fips()}{getblocksnearby.Rul.from.Rul.fips}} \code{\LinkA{fips\_from\_table()}{fips.Rul.from.Rul.table}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{fips\_lead\_zero}{fips\_lead\_zero Add leading zeroes to fips codes if missing, replace with NA if length invalid Note it does NOT VALIDATE FIPS - It does NOT check if FIPS is valid other than checking its length seems OK, i.e., it might be a state, county, tract, blockgroup, or block FIPS code.}{fips.Rul.lead.Rul.zero}
%
\begin{Description}\relax
fips\_lead\_zero
Add leading zeroes to fips codes if missing, replace with NA if length invalid
Note it does NOT VALIDATE FIPS -
It does NOT check if FIPS is valid other than checking its length seems OK,
i.e., it might be a state, county, tract, blockgroup, or block FIPS code.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fips_lead_zero(fips)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{fips}] vector of numeric or character US FIPS codes
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector of same length
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
fips_lead_zero(c(1,"01",1234,"1234","12345",123456))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fips\_st2eparegion}{fips\_st2eparegion - Get EPA Region number from state FIPS code Get EPA Region number from state FIPS code}{fips.Rul.st2eparegion}
%
\begin{Description}\relax
fips\_st2eparegion - Get EPA Region number from state FIPS code
Get EPA Region number from state FIPS code
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fips_st2eparegion(stfips)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{stfips}] vector of one or more state fips codes (numbers or as strings)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector of numbers representing US EPA Regions
\end{Value}
\inputencoding{utf8}
\HeaderA{fips\_state\_from\_statename}{fips\_state\_from\_statename - Get state fips for each state name Get state fips for each state name}{fips.Rul.state.Rul.from.Rul.statename}
%
\begin{Description}\relax
fips\_state\_from\_statename - Get state fips for each state name
Get state fips for each state name
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fips_state_from_statename(statename)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{statename}] vector of state names like c("New York","Georgia")
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector of 2-digit state FIPS codes like c("10", "44", "44"),
same length as input, so including any duplicates
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
  fips_state_from_statename("Delaware")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fips\_state\_from\_state\_abbrev}{fips\_state\_from\_state\_abbrev - Get state fips for each state abbrev Get state fips of each state abbrev}{fips.Rul.state.Rul.from.Rul.state.Rul.abbrev}
%
\begin{Description}\relax
fips\_state\_from\_state\_abbrev - Get state fips for each state abbrev
Get state fips of each state abbrev
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fips_state_from_state_abbrev(ST)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{ST}] vector of state abbreviations like c("NY","GA")
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector of 2-digit state FIPS codes like c("10", "44", "44"),
same length as input, so including any duplicates
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
fips_state_from_state_abbrev("DE", "DE", "RI")
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fixcolnames2related}{fixcolnames2related - get name of related avg, pctile, or ratio variable name Given names\_d, e.g., returns names\_d\_ratio\_to\_state\_avg}{fixcolnames2related}
%
\begin{Description}\relax
fixcolnames2related - get name of related avg, pctile, or ratio variable name
Given names\_d, e.g., returns names\_d\_ratio\_to\_state\_avg
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fixcolnames2related(
  namesnow,
  relatedtype = c("usavg", "stateavg", "uspctile", "statepctile", "usratio",
    "stateratio")
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{namesnow}] vector of one or more basic Envt or Demog indicator variable names
found in c(names\_e, names\_d, names\_d\_subgroups)

\item[\code{relatedtype}] One of "usavg", "stateavg", "uspctile", "statepctile", "usratio", "stateratio"
(but not any of the other values among
unique(map\_headernames\$vartype) since those give ambiguous answers).
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Given basic variable name(s) like "pctlowinc" or names\_e,
see what the related variable names are for storing the
US or State percentiles, averages, or ratios to averages
of the given variables.

Only works for variable names among these:

c(names\_e, names\_d, names\_d\_subgroups)
\end{Details}
%
\begin{Value}
vector as long as namesnow (or just returns namesnow if relatedtype is invalid)
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
names_d
fixcolnames2related(names_d, 'stateratio')
names_d_ratio_to_state_avg
fixcolnames2related(names_e, "stateavg")
fixcolnames2related(names_e, "usvag")
paste0("avg.", names_e)
fixcolnames2related(names_e, "usratio")
# names_ej # does not work with this as input
# fixcolnames2related(names_ej, "uspctile") # does not return names_ej_pctile
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{fixmapheadernamescolname}{fixmapheadernamescolname - utility to convert aliases to proper colnames of map\_headernames}{fixmapheadernamescolname}
%
\begin{Description}\relax
fixmapheadernamescolname - utility to convert aliases to proper colnames of map\_headernames
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fixmapheadernamescolname(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] character vector of colnames of map\_headernames, or aliases like "long"
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector where aliases are replaced with actual colnames and unmatched ones left as-is
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
  fixmapheadernamescolname(c('long', 'csv', 'api', 'r'))

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{frs}{frs (DATA) EPA Facility Registry Service table of regulated sites}{frs}
%
\begin{Description}\relax
This is a data.table snapshot version of the EPA FRS.
You can look up sites by REGISTRY\_ID in \LinkA{frs}{frs}, and get their location, etc.
\end{Description}
%
\begin{Details}\relax
This dataset can be updated by a package maintainer by using
frs\_update\_datasets() (which is not an exported function)

The definitions of active/inactive here are not quite the
same as used in ECHO. See attributes(frs) to see date created, etc.

Also, EJScreen has maps of EPA-regulated facilities of a few program types,
as provided here: \url{https://www.epa.gov/ejscreen/ejscreen-map-descriptions\#sites-reporting-to-epa}
\begin{alltt}

 As of November 2023
 
 Count of    all REGISTRY_ID rows:   7,441,086
 Count of unique REGISTRY_ID values: 4,705,744
 Clearly inactive unique IDs:        1,436,096
 Assumed   active unique IDs:        3,269,648

frs rows total:            3,456,042 
frs clearly inactive IDs:  1,436,096 
frs rows actives:          2,573,338 
frs_by_programid rows:     3,440,036 
frs_by_naics rows:           679,471 
frs_by_sic rows:           1,081,742

  Classes ‘data.table’ and 'data.frame':	 
  Retained only these columns for this package
  
  $ lat           : num  18.4 18.4 18.5 18.2 18.2 ...
  $ lon           : num  -66.1 -66.1 -66.8 -67.1 -67.2 ...
  $ REGISTRY_ID   : chr  "110000307668" "110000307695" "110000307739" "110000307757" ...
  $ PRIMARY_NAME  : chr  "HB FULLER COMPANY HBF PUERTO RICO" "RAMCO CHEMICALS INCORPORATED" 
  $ NAICS         : chr  "325520" "" "311119" "312120" ...
  $ SIC           : chr  "2842" "2048" "2047, 2048, 2091" ...
  $ PGM_SYS_ACRNMS: chr  "NCDB:I02#19880913A2001 2, RCRAINFO:PRD090122136
   
   \end{alltt}

\end{Details}
%
\begin{SeeAlso}\relax
\LinkA{frs\_by\_programid}{frs.Rul.by.Rul.programid}  \LinkA{frs\_by\_naics}{frs.Rul.by.Rul.naics} \LinkA{frs\_by\_sic}{frs.Rul.by.Rul.sic}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{frsprogramcodes}{frsprogramcodes DATA EPA programs listed in Facility Registry Service}{frsprogramcodes}
%
\begin{Description}\relax
\begin{alltt}data.frame

                                                              description     code
                                                              
1    National Pollutant Discharge Elimination System (NPDES) (ICIS-NPDES)    NPDES

2  The Integrated Compliance Information System (ICIS) for Air (ICIS-Air)      AIR

3    The Resource Conservation and Recovery Act (RCRA) Information System RCRAINFO

4                                   Risk Management Plan (RMP) facilities      RMP

5                      The Safe Drinking Water Information System (SDWIS)     SFDW

6                              The Superfund Enterprise Management System     SEMS

7                              Clean Air Markets Division Business System   CAMDBS

8                                        Toxics Release Inventory Program     TRIS

9                                        Greenhouse Gas Reporting Program   E-GGRT

10                                             Emissions Inventory System      EIS

11                                           Toxic Substances Control Act     TSCA
\end{alltt}

\end{Description}
%
\begin{Details}\relax
Created by script in /data-raw/
\end{Details}
%
\begin{SeeAlso}\relax
\LinkA{frs}{frs}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
  frs_by_programid[program %in% frsprogramcodes$code, .N, by=program]
  
  setkey(frs_by_programid,"program")
  frs_by_programid["TRIS",]
  
## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{frs\_by\_mact}{frs\_by\_mact (DATA) MACT NESHAP subpart(s) that each EPA-regulated site is subject to}{frs.Rul.by.Rul.mact}
%
\begin{Description}\relax
This is a data.table with one row per site -- MACT subpart pair,
so it has multiple rows for one site if the site is covered by multiple subparts. It has been joined with frs\_by\_programid to get latlons for matching facilities.
@details

There are about 112k rows here but only about 83k unique program IDs in this table,

which is from the ECHO data download of ICIS Air and AFS.

The programid column here should be found in the pgm\_sys\_id column in frs\_by\_programid,

but as of 6/14/23 only a little over half of them were found there, so this is work in progress

to be resolved.

table(frs\_by\_mact\$programid \%in\% frs\_by\_programid\$pgm\_sys\_id)

FALSE  TRUE

56497 55411

Also there are some typos in the downloaded dataset from ECHO/FRS, such as

"WOOD PERSERVING AREA SOURCES"
\end{Description}
%
\begin{SeeAlso}\relax
\LinkA{mact\_table}{mact.Rul.table} \LinkA{frs\_by\_programid}{frs.Rul.by.Rul.programid}  \LinkA{frs}{frs}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
 
  mact_table
  mact_table[order(mact_table$title),]
  mycodes <- c("BBBBBB", "OOOO")
  frs_by_mact[subpart %in% mycodes, ]
  mact_table[grepl("smelt", mact_table$title, ignore.case = T), ]
  frs_by_mact[grepl("smelt", title, ignore.case = T), ]
  # a single site can be covered by 19 categories
  frs_by_mact[, howmany := .N, by="programid"][order(howmany), ] 
  table(frs_by_mact[, howmany := .N, by="programid"][order(howmany), howmany])
  
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{frs\_by\_naics}{frs\_by\_naics (DATA) data.table of NAICS code(s) for each EPA-regulated site in Facility Registry Service}{frs.Rul.by.Rul.naics}
%
\begin{Description}\relax
This is the format with one row per site-NAICS pair,
so multiple rows for one site if it is in multiple NAICS.
@details

MOST SITES LACK NAICS INFO IN FRS! NAICS is missing for about 80 percent of these facilities.

frs here had about 2,571,750 unique REGISTRY\_ID values, but

frs\_by\_naics had only about 680,000 rows as of 4/1/2023,

about 562,000 unique REGISTRY\_ID values with

about 2,900 unique NAICS codes.

length(unique(frs\_by\_naics\$REGISTRY\_ID))

\code{length(unique(frs\_by\_naics[,REGISTRY\_ID]))}

\code{length(frs\_by\_naics[, unique(REGISTRY\_ID)])}

\code{frs\_by\_naics[,uniqueN(REGISTRY\_ID)]}

\begin{alltt} 561,999  as of 3/26/23 but early 2023 had been 564,770


    lat       lon  REGISTRY_ID  NAICS
\end{alltt}


1: 34.04722 -81.15136 110000854246 325211

2: 34.04722 -81.15136 110000854246 325220

3: 34.04722 -81.15136 110000854246 325222
\end{Description}
%
\begin{SeeAlso}\relax
\LinkA{frs}{frs} \code{\LinkA{frs\_from\_naics()}{frs.Rul.from.Rul.naics}} \code{\LinkA{naics\_categories()}{naics.Rul.categories}} \LinkA{frs\_by\_programid}{frs.Rul.by.Rul.programid} and see naics\_from\_any in EJAM pkg.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
 # NAICS is missing for about 80 percent of facilities
 `frs[ NAICS == "", .N] / frs[,.N] `
 # only about 562k facilities have some NAICS info
 `frs[ NAICS != "", .N]`
 `frs_by_naics[, uniqueN(REGISTRY_ID)]` # almost exactly matches the above
 
 dim(frs_by_naics) 
 # about 680k rows here, or pairs of 1 NAICS - 1 registry ID pair,
 #  since some IDs have 2 or more NAICS so appear as 2 or more rows here.
 
 # About 2,900 different NAICS codes appear here:
 `frs_by_naics[,  uniqueN(NAICS)]`
 `frs_by_naics[, .(sum(.N > 1)), by=NAICS][,sum(V1)]`
   #  2,457 NAICS codes are used to describe more than one Registry ID
  `frs_by_naics[, .(sum(.N == 1)), by=NAICS][,sum(V1)]`
   # [1] 425 NAICS codes appear only once, i.e., apply to only a single facility!
   
 # Which 2-digit NAICS are found here most often?
 `frs_by_naics[ , .N, keyby=substr(NAICS,1,2)]`
 `frs_by_naics[ , .N,   by=substr(NAICS,1,2)][order(N),]` # Most common is 33
 # Top 10 most common 3-digit NAICS here:
 `x = tail(frs_by_naics[ , .N,   by=.(n3 = substr(NAICS,1,3))][order(N), ],10)`
 `cbind(x, industry = rownames(naics_categories(3))[match(x$n3, naics_categories(3))])`
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{frs\_by\_programid}{frs\_by\_programid (DATA) data.table of Program System ID code(s) for each EPA-regulated site in the Facility Registry Service}{frs.Rul.by.Rul.programid}
%
\begin{Description}\relax
frs\_by\_programid (DATA) data.table of Program System ID code(s) for each EPA-regulated site in
the Facility Registry Service
\end{Description}
%
\begin{Details}\relax
Created by frs\_make\_programid\_lookup()  that was in EJAMfrsdata package

\begin{alltt}
   This is the format with one row per site-programid pair, 
   so multiple rows for one site if it is in multiple programs.

 > dim(frs_by_programid)
 [1] 3440451       5   as of 1/3/2023

nn=sample(1:nrow(frs_by_programid), 1); frs_by_programid[REGISTRY_ID == frs_by_programid$REGISTRY_ID[nn],]

             lat       lon  REGISTRY_ID  program         pgm_sys_id
     1: 40.21262 -100.6464 110040499724 AIRS/AFS         3114500040
     2: 40.21262 -100.6464 110040499724     NDEQ              87933
     3: 40.21262 -100.6464 110040499724      AIR NE0000003114500040
     
nn=sample(1:nrow(frs_by_programid), 1); frs_by_programid[REGISTRY_ID == frs_by_programid$REGISTRY_ID[nn],]

             lat       lon  REGISTRY_ID program   pgm_sys_id
     1: 47.00071 -120.5649 110037546493 WA-FSIS      1796553
     2: 47.00071 -120.5649 110037546493    ICIS   1800041945
     3: 47.00071 -120.5649 110037546493 WA-FSIS      7886103
  \end{alltt}

\end{Details}
%
\begin{SeeAlso}\relax
frs() frs\_by\_naics()
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{frs\_by\_sic}{frs\_by\_sic (DATA) data.table of SIC code(s) for each EPA-regulated site in Facility Registry Service}{frs.Rul.by.Rul.sic}
%
\begin{Description}\relax
This is the format with one row per site-SIC pair,
so multiple rows for one site if it is in multiple SIC.
\end{Description}
\inputencoding{utf8}
\HeaderA{frs\_from\_naics}{frs\_from\_naics - Use NAICS code or industry title text search to see FRS Facility Registry Service data on those EPA-regulated sites}{frs.Rul.from.Rul.naics}
%
\begin{Description}\relax
frs\_from\_naics - Use NAICS code or industry title text search to see FRS Facility Registry Service data on those EPA-regulated sites
\end{Description}
%
\begin{Usage}
\begin{verbatim}
frs_from_naics(naics_code_or_name, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{naics\_code\_or\_name}] 

\item[\code{...}] passed to \code{\LinkA{naics\_from\_any()}{naics.Rul.from.Rul.any}}
\end{ldescription}
\end{Arguments}
%
\begin{Value}
relevant rows of the data.table called frs, which has column names that are
"lat" "lon" "REGISTRY\_ID" "PRIMARY\_NAME" "NAICS" "PGM\_SYS\_ACRNMS"
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{siteid\_from\_naics()}{siteid.Rul.from.Rul.naics}} \code{\LinkA{naics\_from\_any()}{naics.Rul.from.Rul.any}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
  frs_from_naics("uranium")
  mapfast(frs_from_naics(naics_from_any("nuclear")$code))
  naics_from_any("silver")
  naics_from_name("silver")
  naics_from_any(212222 )
  frs_from_naics(21222)
  siteid_from_naics(21222)
  latlon_from_naics(21222)
  
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{frs\_from\_program}{frs\_from\_program - Use EPA Program acronym like TRIS to see FRS Facility Registry Service data on those EPA-regulated sites}{frs.Rul.from.Rul.program}
%
\begin{Description}\relax
Get data.table based on given FRS Program System CATEGORY.
Find all FRS sites in a program like RCRAINFO, TRIS, or others.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
frs_from_program(program)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{program}] vector of one or more EPA Program names used by FRS
\end{ldescription}
\end{Arguments}
%
\begin{Value}
relevant rows of the data.table called frs, which has column names that are
"lat" "lon" "REGISTRY\_ID" "PRIMARY\_NAME" "NAICS" "PGM\_SYS\_ACRNMS"
\end{Value}
\inputencoding{utf8}
\HeaderA{frs\_from\_programid}{frs\_from\_programid - Use EPA Program ID to see FRS Facility Registry Service data on those EPA-regulated sites}{frs.Rul.from.Rul.programid}
%
\begin{Description}\relax
frs\_from\_programid - Use EPA Program ID to see FRS Facility Registry Service data on those EPA-regulated sites
\end{Description}
%
\begin{Usage}
\begin{verbatim}
frs_from_programid(programid)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{siteid}] vector of one or more EPA Program ID codes used by FRS
\end{ldescription}
\end{Arguments}
%
\begin{Value}
relevant rows of the data.table called frs, which has column names that are
"lat" "lon" "REGISTRY\_ID" "PRIMARY\_NAME" "NAICS" "PGM\_SYS\_ACRNMS"
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
x=frs_from_programid(testids_program_sys_id)
  x
  mapfast(x)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{frs\_from\_regid}{frs\_from\_siteid - Use registry ID to see FRS Facility Registry Service data on those EPA-regulated sites}{frs.Rul.from.Rul.regid}
\aliasB{frs\_from\_siteid()}{frs\_from\_regid}{frs.Rul.from.Rul.siteid()}
%
\begin{Description}\relax
frs\_from\_siteid - Use registry ID to see FRS Facility Registry Service data on those EPA-regulated sites
\end{Description}
%
\begin{Usage}
\begin{verbatim}
frs_from_regid(siteid)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{siteid}] vector of one or more EPA Registry ID codes used by FRS
\end{ldescription}
\end{Arguments}
%
\begin{Value}
relevant rows of the data.table called frs, which has column names that are
"lat" "lon" "REGISTRY\_ID" "PRIMARY\_NAME" "NAICS" "PGM\_SYS\_ACRNMS"
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
frs_from_siteid(testids_registry_id)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{frs\_from\_sic}{frs\_from\_sic - Use SIC code or industry title text search to see FRS Facility Registry Service data on those EPA-regulated sites}{frs.Rul.from.Rul.sic}
%
\begin{Description}\relax
frs\_from\_sic - Use SIC code or industry title text search to see FRS Facility Registry Service data on those EPA-regulated sites
\end{Description}
%
\begin{Usage}
\begin{verbatim}
frs_from_sic(sic_code_or_name, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] passed to \code{\LinkA{naics\_from\_any()}{naics.Rul.from.Rul.any}}

\item[\code{naics\_code\_or\_name}] 
\end{ldescription}
\end{Arguments}
%
\begin{Value}
relevant rows of the data.table called frs, which has column names that are
"lat" "lon" "REGISTRY\_ID" "PRIMARY\_NAME" "NAICS" "SIC" "PGM\_SYS\_ACRNMS"
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{siteid\_from\_sic()}{siteid.Rul.from.Rul.sic}} \code{\LinkA{sic\_from\_any()}{sic.Rul.from.Rul.any}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
  frs_from_sic("glass")
  mapfast(frs_from_sic(sic_from_any("silver")$code))
  sic_from_any("silver")
  sic_from_name("silver")
  sic_from_any('0780')
  frs_from_sic('0780')
  siteid_from_sic('0780')
  latlon_from_sic('0780')
  
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{frs\_from\_siteid}{frs\_from\_siteid - Use registry ID to see FRS Facility Registry Service data on those EPA-regulated sites}{frs.Rul.from.Rul.siteid}
\aliasB{frs\_from\_regid()}{frs\_from\_siteid}{frs.Rul.from.Rul.regid()}
%
\begin{Description}\relax
frs\_from\_siteid - Use registry ID to see FRS Facility Registry Service data on those EPA-regulated sites
\end{Description}
%
\begin{Usage}
\begin{verbatim}
frs_from_siteid(siteid)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{siteid}] vector of one or more EPA Registry ID codes used by FRS
\end{ldescription}
\end{Arguments}
%
\begin{Value}
relevant rows of the data.table called frs, which has column names that are
"lat" "lon" "REGISTRY\_ID" "PRIMARY\_NAME" "NAICS" "PGM\_SYS\_ACRNMS"
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
frs_from_siteid(testids_registry_id)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{frs\_from\_sitename}{frs\_from\_sitename - Use site name text search to see FRS Facility Registry Service data on those EPA-regulated sites VERY SLOW search within PRIMARY\_NAME of facilities for matching text}{frs.Rul.from.Rul.sitename}
%
\begin{Description}\relax
frs\_from\_sitename - Use site name text search to see FRS Facility Registry Service data on those EPA-regulated sites
VERY SLOW search within PRIMARY\_NAME of facilities for matching text
\end{Description}
%
\begin{Usage}
\begin{verbatim}
frs_from_sitename(sitenames, ignore.case = TRUE, fixed = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{sitenames}] one or more strings in a vector, which can be regular expressions or query for exact match using fixed=TRUE

\item[\code{ignore.case}] logical, search is not case sensitive by default (unlike \code{\LinkA{grepl()}{grepl}} default)

\item[\code{fixed}] see \code{\LinkA{grepl()}{grepl}}, if set to TRUE it looks for only exact matches
\end{ldescription}
\end{Arguments}
%
\begin{Value}
relevant rows of the data.table called frs, which has column names that are
"lat" "lon" "REGISTRY\_ID" "PRIMARY\_NAME" "NAICS" "PGM\_SYS\_ACRNMS"
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
 # very slow
 x=frs_from_sitename
 nrow(x)
 head(x)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{frs\_is\_valid}{frs\_is\_valid - Validate FRS Registry ID list uploads}{frs.Rul.is.Rul.valid}
%
\begin{Description}\relax
Check for proper FRS facility id in uploaded data
\end{Description}
%
\begin{Usage}
\begin{verbatim}
frs_is_valid(frs_upload)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{frs\_upload}] upload frs registry IDs table converted to data frame
\end{ldescription}
\end{Arguments}
%
\begin{Value}
boolean value (valid or not valid)
\end{Value}
\inputencoding{utf8}
\HeaderA{getblocksnearby}{getblocksnearby - Fast way to find nearby points (distance to each Census block centroid near each site)}{getblocksnearby}
%
\begin{Description}\relax
Given a set of points and a specified radius,
this function quickly finds all the US Census blocks near each point.
For each point, it uses the specified radius distance and finds the distance to
every block within the circle defined by the radius.
Each block is defined by its Census-provided internal point, by latitude and longitude.

Each point can be the location of a regulated facility or other type of site, and
the blocks are a high-resolution source of information about where
residents live.

Finding which blocks have their internal points in a circle provides
a way to quickly estimate what fraction of a block group is
inside the circular buffer more accurately and more quickly than
areal apportionment of block groups would provide.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getblocksnearby(
  sitepoints,
  radius = 3,
  maxradius = 31.07,
  avoidorphans = FALSE,
  quadtree,
  quiet = FALSE,
  parallel = FALSE,
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{sitepoints}] data.table with columns siteid, lat, lon giving point locations of sites or facilities around which are circular buffers

\item[\code{radius}] in miles, defining circular buffer around a site point

\item[\code{maxradius}] miles distance (max distance to check if not even 1 block point is within radius)

\item[\code{avoidorphans}] logical If TRUE, then where not even 1 BLOCK internal point is within radius of a SITE,
it keeps looking past radius, up to maxradius, to find nearest 1 BLOCK.
What EJScreen does in that case is report NA, right? So,
does EJAM really need to report stats on residents presumed to be within radius,
if no block centroid is within radius?
Best estimate might be to report indicators from nearest block centroid which is
probably almost always the one your site is sitting inside of,
but ideally would adjust total count to be a fraction of blockwt based on
what is area of circular buffer as fraction of area of block it is apparently inside of.
Setting this to TRUE can produce unexpected results, which will not match EJScreen numbers.

Note that if creating a proximity score, by contrast, you instead want to find nearest 1 SITE if none within radius of this BLOCK.

\item[\code{quadtree}] (a pointer to the large quadtree object)
created using indexblocks() which uses the SearchTree package.
Takes about 2-5 seconds to create this each time it is needed.
It can be automatically created when the package is attached via the .onAttach() function

\item[\code{quiet}] Optional. set to TRUE to avoid message about using getblock\_diagnostics(),
which is relevant only if a user saved the output of this function.

\item[\code{...}] passed to \code{\LinkA{getblocksnearbyviaQuadTree()}{getblocksnearbyviaQuadTree}} or other such functions
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
See \code{\LinkA{ejamit()}{ejamit}} for examples.

getblocksnearby() is a wrapper redirecting to the right version, like \code{\LinkA{getblocksnearbyviaQuadTree()}{getblocksnearbyviaQuadTree}}
Census block "internal points" (defined by Census Bureau) are actually what it looks for,
and they are like centroids.
The blocks are pre-indexed for the whole USA, via the data object quadtree aka localtree
\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{ejamit()}{ejamit}}  \code{\LinkA{getblocksnearbyviaQuadTree()}{getblocksnearbyviaQuadTree}} \code{\LinkA{getblocksnearbyviaQuadTree\_Clustered()}{getblocksnearbyviaQuadTree.Rul.Clustered}} \code{\LinkA{getblocksnearbyviaQuadTree2()}{getblocksnearbyviaQuadTree2}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{getblocksnearby2}{getblocksnearby2 - Key buffering function - wrapper redirecting to the right version of getblocksnearby() DRAFT / WAS WORK IN PROGRESS}{getblocksnearby2}
%
\begin{Description}\relax
getblocksnearby2 - Key buffering function - wrapper redirecting to the right version of getblocksnearby()
DRAFT / WAS WORK IN PROGRESS
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getblocksnearby2(
  sitepoints,
  radius = 3,
  maxradius = 31.07,
  avoidorphans = FALSE,
  quadtree = is.null,
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{sitepoints}] see \code{\LinkA{getblocksnearbyviaQuadTree()}{getblocksnearbyviaQuadTree}} or other such functions

\item[\code{radius}] see \code{\LinkA{getblocksnearbyviaQuadTree()}{getblocksnearbyviaQuadTree}} or other such functions

\item[\code{maxradius}] see \code{\LinkA{getblocksnearbyviaQuadTree()}{getblocksnearbyviaQuadTree}} or other such functions

\item[\code{avoidorphans}] see \code{\LinkA{getblocksnearbyviaQuadTree()}{getblocksnearbyviaQuadTree}} or other such functions

\item[\code{quadtree}] a large quadtree object created from the SearchTree package example:
SearchTrees::createTree( quaddata, treeType = "quad", dataType = "point")

\item[\code{...}] see \code{\LinkA{getblocksnearbyviaQuadTree\_Clustered()}{getblocksnearbyviaQuadTree.Rul.Clustered}} or other such functions
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
For all examples, see \code{\LinkA{ejamit()}{ejamit}}

Like getblocksnearby() but tries to handle localtree and quadtree parameter differently
\begin{itemize}

\item{} not sure how to check if they are in the right environment.

\end{itemize}

\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{getblocksnearby()}{getblocksnearby}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{getblocksnearbyviaQuadTree}{getblocksnearbyviaQuadTree - Fast way to find nearby points (distance to each Census block centroid near each site)}{getblocksnearbyviaQuadTree}
%
\begin{Description}\relax
Given a set of points and a specified radius in miles,
this function quickly finds all the US Census blocks near each point.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getblocksnearbyviaQuadTree(
  sitepoints,
  radius = 3,
  maxradius = 31.07,
  avoidorphans = FALSE,
  report_progress_every_n = 500,
  quiet = FALSE,
  quadtree
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{sitepoints}] data.table with columns siteid, lat, lon giving point locations of sites or facilities around which are circular buffers

\item[\code{radius}] in miles, defining circular buffer around a site point

\item[\code{maxradius}] miles distance (max distance to check if not even 1 block point is within radius)

\item[\code{avoidorphans}] logical If TRUE, then where not even 1 BLOCK internal point is within radius of a SITE,
it keeps looking past radius, up to maxradius, to find nearest 1 BLOCK.
What EJScreen does in that case is report NA, right? So,
does EJAM really need to report stats on residents presumed to be within radius,
if no block centroid is within radius?
Best estimate might be to report indicators from nearest block centroid which is
probably almost always the one your site is sitting inside of,
but ideally would adjust total count to be a fraction of blockwt based on
what is area of circular buffer as fraction of area of block it is apparently inside of.
Setting this to TRUE can produce unexpected results, which will not match EJScreen numbers.

Note that if creating a proximity score, by contrast, you instead want to find nearest 1 SITE if none within radius of this BLOCK.

\item[\code{report\_progress\_every\_n}] Reports progress to console after every n points,
mostly for testing, but a progress bar feature might be useful unless this is super fast.

\item[\code{quiet}] Optional. set to TRUE to avoid message about using getblock\_diagnostics(),
which is relevant only if a user saved the output of this function.

\item[\code{quadtree}] (a pointer to the large quadtree object)
created using indexblocks() which uses the SearchTree package.
Takes about 2-5 seconds to create this each time it is needed.
It can be automatically created when the package is attached via the .onAttach() function
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
For each point, it uses the specified search radius and finds the distance to
every block within the circle defined by the radius.
Each block is defined by its Census-provided internal point, by latitude and longitude.

Results are the sites2blocks table that would be used by doaggregate(),
with distance in miles as one output column of data.table.
Adjusts distance to avg resident in block when it is very small relative to block size,
the same way EJScreen adjusts distances in creating proximity scores.

Each point can be the location of a regulated facility or other type of site, and
the blocks are a high-resolution source of information about where
residents live.

Finding which blocks have their internal points in a circle provides
a way to quickly estimate what fraction of a block group is
inside the circular buffer more accurately and more quickly than
areal apportionment of block groups would provide.
\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{ejamit()}{ejamit}} \code{\LinkA{getblocksnearby()}{getblocksnearby}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
  # indexblocks() # if localtree not available yet, quadtree = localtree
  x = getblocksnearby(testpoints_1000, radius = 3)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getblocksnearbyviaQuadTree2}{getblocksnearbyviaQuadTree2 - Find nearby blocks using Quad Tree data structure for speed, NO PARALLEL PROCESSING - DRAFT / WORK IN PROGRESS}{getblocksnearbyviaQuadTree2}
%
\begin{Description}\relax
Given a set of points and a specified radius in miles,
this function quickly finds all the US Census blocks near each point.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getblocksnearbyviaQuadTree2(
  sitepoints,
  radius = 3,
  maxradius = 31.07,
  avoidorphans = FALSE,
  report_progress_every_n = 500,
  quiet = FALSE,
  quadtree
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{sitepoints}] data.table with columns siteid, lat, lon giving point locations of sites or facilities around which are circular buffers

\item[\code{radius}] in miles, defining circular buffer around a site point

\item[\code{maxradius}] miles distance (max distance to check if not even 1 block point is within radius)

\item[\code{avoidorphans}] logical If TRUE, then where not even 1 BLOCK internal point is within radius of a SITE,
it keeps looking past radius, up to maxradius, to find nearest 1 BLOCK.
What EJScreen does in that case is report NA, right? So,
does EJAM really need to report stats on residents presumed to be within radius,
if no block centroid is within radius?
Best estimate might be to report indicators from nearest block centroid which is
probably almost always the one your site is sitting inside of,
but ideally would adjust total count to be a fraction of blockwt based on
what is area of circular buffer as fraction of area of block it is apparently inside of.
Setting this to TRUE can produce unexpected results, which will not match EJScreen numbers.

Note that if creating a proximity score, by contrast, you instead want to find nearest 1 SITE if none within radius of this BLOCK.

\item[\code{report\_progress\_every\_n}] Reports progress to console after every n points,
mostly for testing, but a progress bar feature might be useful unless this is super fast.

\item[\code{quiet}] Optional. set to TRUE to avoid message about using getblock\_diagnostics(),
which is relevant only if a user saved the output of this function.

\item[\code{quadtree}] (a pointer to the large quadtree object)
created using indexblocks() which uses the SearchTree package.
Takes about 2-5 seconds to create this each time it is needed.
It can be automatically created when the package is attached via the .onAttach() function
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This should be almost identical to getblocksnearbyviaQuadTree(), but it uses f2, a copy of sitepoints, and more importantly pulls some code out of the for loop and uses a vectorized approach.
For each point, it uses the specified search radius and finds the distance to
every block within the circle defined by the radius.
Each block is defined by its Census-provided internal point, by latitude and longitude.

Results are the sites2blocks table that would be used by doaggregate(),
with distance in miles as one output column of data.table.
Adjusts distance to avg resident in block when it is very small relative to block size,
the same way EJScreen adjusts distances in creating proximity scores.

Each point can be the location of a regulated facility or other type of site, and
the blocks are a high-resolution source of information about where
residents live.

Finding which blocks have their internal points in a circle provides
a way to quickly estimate what fraction of a block group is
inside the circular buffer more accurately and more quickly than
areal apportionment of block groups would provide.
\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{ejamit()}{ejamit}} \code{\LinkA{getblocksnearby()}{getblocksnearby}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
  # indexblocks() # if localtree not available yet, quadtree = localtree
  x = getblocksnearby2(testpoints_1000, radius = 3)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getblocksnearbyviaQuadTree3}{getblocksnearbyviaQuadTree3 - Find nearby blocks using Quad Tree data structure for speed, NO PARALLEL PROCESSING DRAFT / WAS WORK IN PROGRESS}{getblocksnearbyviaQuadTree3}
%
\begin{Description}\relax
Given a set of points and a specified radius (in miles),
this function quickly finds all the US Census blocks near each point.
For each point, it uses the specified search radius and finds the distance to
every block within the circle defined by the radius.
Each block is defined by its Census-provided internal point, by latitude and longitude.

Each point can be the location of a regulated facility or other type of site, and
the blocks are a high-resolution source of information about where
residents live.

Finding which blocks have their internal points in a circle provides
a way to quickly estimate what fraction of a block group is
inside the circular buffer more accurately and more quickly than
areal apportionment of block groups would provide.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getblocksnearbyviaQuadTree3(
  sitepoints,
  radius = 3,
  maxradius = 31.07,
  avoidorphans = TRUE,
  report_progress_every_n = 500,
  quadtree
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{sitepoints}] data.table with columns siteid, lat, lon giving point locations of sites or facilities around which are circular buffers

\item[\code{radius}] in miles, defining circular buffer around site point

\item[\code{maxradius}] miles distance (max distance to check if not even 1 block point is within radius)

\item[\code{avoidorphans}] logical Whether to avoid case where no block points are within radius,
so if TRUE, it keeps looking past radius to find nearest one within maxradius.

\item[\code{report\_progress\_every\_n}] Reports progress to console after every n points,
mostly for testing, but a progress bar feature might be useful unless this is super fast.

\item[\code{quadtree}] (a pointer to the large quadtree object)
created from the SearchTree package example:
SearchTrees::createTree( quaddata, treeType = "quad", dataType = "point")
Takes about 2-5 seconds to create this each time it is needed.
It is automatically created when the package is attached via the .onAttach() function
\end{ldescription}
\end{Arguments}
%
\begin{SeeAlso}\relax
\code{\LinkA{ejamit()}{ejamit}} \code{\LinkA{getblocksnearby()}{getblocksnearby}} \code{\LinkA{getblocksnearbyviaQuadTree()}{getblocksnearbyviaQuadTree}} \code{\LinkA{getblocksnearbyviaQuadTree\_Clustered()}{getblocksnearbyviaQuadTree.Rul.Clustered}} \code{\LinkA{getblocksnearbyviaQuadTree2()}{getblocksnearbyviaQuadTree2}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{getblocksnearbyviaQuadTree\_Clustered}{getblocksnearbyviaQuadTree\_Clustered - find nearby blocks using Quad Tree data structure for speed, CLUSTERED FOR PARALLEL PROCESSING}{getblocksnearbyviaQuadTree.Rul.Clustered}
%
\begin{Description}\relax
Uses packages parallel and snow. \LinkA{parallel::makePSOCKcluster}{parallel::makePSOCKcluster} is an enhanced version of \LinkA{snow::makeSOCKcluster}{snow::makeSOCKcluster} in package snow.
It runs Rscript on the specified host(s) to set up a worker process which listens on a socket for expressions to evaluate, and returns the results (as serialized objects).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getblocksnearbyviaQuadTree_Clustered(
  sitepoints,
  radius,
  maxradius,
  avoidorphans,
  CountCPU = 1,
  quadtree
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{sitepoints}] data.table with columns LAT, LONG

\item[\code{radius}] in miles

\item[\code{maxradius}] miles distance

\item[\code{avoidorphans}] logical

\item[\code{CountCPU}] for parallel processing via makeCluster() and \code{\LinkA{doSNOW::registerDoSNOW()}{doSNOW::registerDoSNOW()}}

\item[\code{quadtree}] index of all US blocks like localtree
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
For all examples, see \code{\LinkA{getblocksnearbyviaQuadTree()}{getblocksnearbyviaQuadTree}}

Uses indexgridsize and quaddata  variables that come from global environment (but should pass to this function rather than assume in global env?)
\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{getblocksnearby()}{getblocksnearby}} \code{\LinkA{getblocksnearbyviaQuadTree()}{getblocksnearbyviaQuadTree}} \code{\LinkA{getblocksnearbyviaQuadTree\_Clustered()}{getblocksnearbyviaQuadTree.Rul.Clustered}} \code{\LinkA{getblocksnearbyviaQuadTree2()}{getblocksnearbyviaQuadTree2}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{getblocksnearby\_from\_fips}{getblocksnearby\_from\_fips Actually finds all blocks within each of the FIPS codes provided}{getblocksnearby.Rul.from.Rul.fips}
%
\begin{Description}\relax
getblocksnearby\_from\_fips
Actually finds all blocks within each of the FIPS codes provided
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getblocksnearby_from_fips(fips, inshiny = FALSE, need_blockwt = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{fips}] vector of FIPS codes identifying blockgroups, tracts, counties, or states.
This is useful if -- instead of gettings stats on and comparing circular buffers or polygons --
one will be getting stats on one or more tracts,
or analyzing and comparing blockgroups in a county,
or comparing whole counties to each other, within a State.

\item[\code{inshiny}] used by shiny app server code to handle errors via validate() instead of stop()

\item[\code{need\_blockwt}] set to FALSE to speed it up if you do not need blockwt
\end{ldescription}
\end{Arguments}
%
\begin{Value}
same as for \LinkA{getblocksnearby}{getblocksnearby} but one row per FIPS, and the distance column is irrelevant
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{fips\_bg\_from\_anyfips()}{fips.Rul.bg.Rul.from.Rul.anyfips}} \code{\LinkA{fips\_lead\_zero()}{fips.Rul.lead.Rul.zero}} \code{\LinkA{getblocksnearby\_from\_fips()}{getblocksnearby.Rul.from.Rul.fips}} \code{\LinkA{fips\_from\_table()}{fips.Rul.from.Rul.table}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
  x <- getblocksnearby_from_fips(fips_counties_from_state_abbrev("DE"))
  counties_ej <- doaggregate(x)
 # mapfast(counties_ej$results_bysite)
  y =  ejamit(fips=fips_counties_from_statename("Delaware"))
  
  # x=getblocksnearby_from_fips("482011000011") # one blockgroup only
  # y=doaggregate(x)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getblocks\_diagnostics}{getblocks\_diagnostics - Lots of stats about \# of blocks, \# of sites, etc.}{getblocks.Rul.diagnostics}
%
\begin{Description}\relax
getblocks\_diagnostics - Lots of stats about \# of blocks, \# of sites, etc.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getblocks_diagnostics(x, detailed = FALSE, see_plot = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] The output of \code{\LinkA{getblocksnearby()}{getblocksnearby}} like testoutput\_getblocksnearby\_10pts\_1miles

\item[\code{detailed}] if TRUE, also shows in console a long table of frequencies via \code{\LinkA{getblocks\_summarize\_blocks\_per\_site()}{getblocks.Rul.summarize.Rul.blocks.Rul.per.Rul.site}}

\item[\code{see\_plot}] set TRUE to draw for each site a boxplot of distances of nearby blocks
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list of stats
\end{Value}
%
\begin{SeeAlso}\relax
This relies on  \code{\LinkA{getblocks\_summarize\_blocks\_per\_site()}{getblocks.Rul.summarize.Rul.blocks.Rul.per.Rul.site}} and \code{\LinkA{getblocks\_summarize\_sites\_per\_block()}{getblocks.Rul.summarize.Rul.sites.Rul.per.Rul.block}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
 getblocks_diagnostics(testoutput_getblocksnearby_10pts_1miles)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{getblocks\_summarize\_blocks\_per\_site}{getblocks\_summarize\_blocks\_per\_site - how many blocks are near the sites (pop density affects accuracy)}{getblocks.Rul.summarize.Rul.blocks.Rul.per.Rul.site}
%
\begin{Description}\relax
Number of blocks near avg site, how many sites have only 1 or fewer than 30 blocks nearby, etc.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getblocks_summarize_blocks_per_site(x, varname = "siteid")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] The output of getblocksnearby()

\item[\code{varname}] colname of variable in data.table x that is the one to summarize by
\end{ldescription}
\end{Arguments}
%
\begin{Value}
invisibly, a list of stats
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{getblocks\_diagnostics()}{getblocks.Rul.diagnostics}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{getblocks\_summarize\_sites\_per\_block}{getblocks\_summarize\_sites\_per\_block - how many sites are near the blocks (site density near residents)}{getblocks.Rul.summarize.Rul.sites.Rul.per.Rul.block}
%
\begin{Description}\relax
getblocks\_summarize\_sites\_per\_block - how many sites are near the blocks (site density near residents)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getblocks_summarize_sites_per_block(x, varname = "blockid")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] The output of \code{\LinkA{getblocksnearby()}{getblocksnearby}} like testoutput\_getblocksnearby\_10pts\_1miles

\item[\code{varname}] colname of variable in data.table x that is the one to summarize by
\end{ldescription}
\end{Arguments}
%
\begin{Value}
invisibly, a list of stats
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{getblocks\_diagnostics()}{getblocks.Rul.diagnostics}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{get\_blockpoints\_in\_shape}{get\_blockpoints\_in\_shape - find blocks that are in a polygon, using internal point of block - WORK IN PROGRESS ****}{get.Rul.blockpoints.Rul.in.Rul.shape}
\aliasA{shapefile2blockpoints}{get\_blockpoints\_in\_shape}{shapefile2blockpoints}
%
\begin{Description}\relax
This is like getblocksnearby() but for a polygonal buffer area instead of
a circular buffer.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
get_blockpoints_in_shape(
  polys,
  addedbuffermiles = 0,
  blocksnearby = NULL,
  dissolved = FALSE,
  safety_margin_ratio = 1.1,
  crs = 4269
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{polys}] Spatial data as from sf::st\_as\_sf(), with a column called siteid, like
points as from \code{\LinkA{shapefile\_from\_sitepoints()}{shapefile.Rul.from.Rul.sitepoints}},
or a table of points with lat,lon columns that will first be converted here using that function,
or polygons

\item[\code{addedbuffermiles}] width of optional buffering to add to the points (or edges), in miles

\item[\code{blocksnearby}] optional table of blocks with blockid,siteid (from which lat,lon can be looked up in blockpoints dt)

\item[\code{dissolved}] If TRUE, use sf::st\_union(polys) to find unique blocks inside any one or more of polys

\item[\code{safety\_margin\_ratio}] multiplied by addedbuffermiles, how far to search for
blocks nearby using getblocksnearby(), before using those found to do the intersection via sf::

\item[\code{crs}] used in st\_as\_sf() and st\_transform() and shape\_buffered\_from\_shapefile\_points(), crs = 4269 or Geodetic CRS NAD83
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This uses getblocksnearby() to get a very fast rough/good estimate of
which US block points are nearby (with a safety margin - see param below),
before then using sf:: to carefully identify which of those candidate blocks are actually
inside each polygon (e.g., circle) according to sf:: methods.

For circular buffers, just using getblocksnearby() should work and not need this function.

For noncircular polygons, buffered or not, this function will provide a way to very quickly
filter down to which of the millions of US blocks should be examined by the sf:: join / intersect,
since otherwise it takes forever for sf:: to check all US blocks.
\end{Details}
%
\begin{Value}
Block points table for those blocks whose internal point is inside the buffer
which is just a circular buffer of specified radius if polys are just points.
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{get\_blockpoints\_in\_shape()}{get.Rul.blockpoints.Rul.in.Rul.shape}} \code{\LinkA{shapefile\_from\_sitepoints()}{shapefile.Rul.from.Rul.sitepoints}} \code{\LinkA{shape\_buffered\_from\_shapefile\_points()}{shape.Rul.buffered.Rul.from.Rul.shapefile.Rul.points}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
 
  # y <- get_blockpoints_in_shape()
  
  # x = shapefile_from_sitepoints(testpoints_n(2))
  # y = get_blockpoints_in_shape(x, 1)  # very very slow
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{high\_pctiles\_tied\_with\_min}{high\_pctiles\_tied\_with\_min (DATA) internal data used to handle cases where multiple places are tied for the lowest indicator score}{high.Rul.pctiles.Rul.tied.Rul.with.Rul.min}
%
\begin{Description}\relax
high\_pctiles\_tied\_with\_min (DATA) internal data used to handle cases where multiple places are tied for the lowest indicator score
\end{Description}
\inputencoding{utf8}
\HeaderA{indexblocks}{indexblocks Create localtree (a quadtree index of all US block centroids) in global environment}{indexblocks}
%
\begin{Description}\relax
indexblocks
Create localtree (a quadtree index of all US block centroids) in global environment
\end{Description}
%
\begin{Usage}
\begin{verbatim}
indexblocks()
\end{verbatim}
\end{Usage}
%
\begin{Details}\relax
Note this is duplicated code in .onAttach() and also in global.R

.onAttach() can be edited to create this when the package loads,
but then it takes time each time a developer rebuilds/installs the package or others that load EJAM.

It also has to happen in global.R if it has not already.
\end{Details}
%
\begin{Value}
Returns TRUE when done. Side effect is it creates the index in memory.
\end{Value}
\inputencoding{utf8}
\HeaderA{input\_names\_listing}{input\_names\_listing Utility checking values of input\$ that appear in this code See appsilon pkg shiny.info now}{input.Rul.names.Rul.listing}
%
\begin{Description}\relax
input\_names\_listing
Utility checking values of input\$ that appear in this code
See appsilon pkg shiny.info now
\end{Description}
%
\begin{Usage}
\begin{verbatim}
input_names_listing(file = "./R/app_server.R")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{file}] path to source file to search in
\end{ldescription}
\end{Arguments}
%
\begin{Value}
character vector of ids of inputs like x,y,z if it found input\$x input\$y input\$z
\end{Value}
\inputencoding{utf8}
\HeaderA{islandareas}{islandareas (DATA) table, bounds info on lat lon of US Island Areas}{islandareas}
%
\begin{Description}\relax
data.frame of info on approximate lat lon bounding boxes around
American Samoa, Guam, the
Commonwealth of the Northern Mariana Islands (Northern Mariana Islands),
and the United States Virgin Islands.

See also \LinkA{stateinfo}{stateinfo} and []

See \url{http://www.census.gov/geo/reference/gtc/gtc_island.html}

See datacreate\_islandareas.R or data-raw/islandareas.xlsx

Note the US minor outlying islands are not in that list and are widely dispersed.
They include Midway Islands, etc.
\end{Description}
\inputencoding{utf8}
\HeaderA{latlon\_as.numeric}{latlon\_as.numeric - Strip non-numeric characters from a vector}{latlon.Rul.as.numeric}
%
\begin{Description}\relax
Remove all characters other than minus signs, decimal points, and numeric digits
\end{Description}
%
\begin{Usage}
\begin{verbatim}
latlon_as.numeric(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] vector of something that is supposed to be numbers like latitude or longitude
and may be a character vector because there were some other characters like tab or space or percent sign or dollar sign
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Useful if latitude or longitude vector has spaces, tabs, etc.
CAUTION - Assumes stripping those out and making it numeric will fix whatever problem there was
and end result is a valid set of numbers. Inf etc. are turned into NA values.
Empty zero length string is turned into NA without warning. NA is left as NA.
If anything other than empty or NA could not be interpreted as a number, it
returns NA for those and offers a warning.
\end{Details}
%
\begin{Value}
numeric vector same length as x
\end{Value}
%
\begin{SeeAlso}\relax
latlon\_df\_clean() latlon\_infer() latlon\_is.valid() latlon\_as.numeric()
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
  
  latlon_as.numeric(c("-97.179167000000007", " -94.0533", "-95.152083000000005"))
  latlon_as.numeric(-3:3)
  latlon_as.numeric(c(1:3, NA))
  latlon_as.numeric(c(1, 'asdf'))
  latlon_as.numeric(c(1, ''))
  latlon_as.numeric(c(1, '', NA))
  latlon_as.numeric(c('aword', '$b'))
  latlon_as.numeric(c('-10.5%', '<5', '$100'))
  latlon_as.numeric(c(Inf, 1))
  
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{latlon\_df\_clean}{latlon\_df\_clean - Find and clean up latitude and longitude columns in a data.frame}{latlon.Rul.df.Rul.clean}
%
\begin{Description}\relax
Utility to identify lat and lon columns, renaming and cleaning them up.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
latlon_df_clean(df)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] data.frame With columns lat and lon or names that can be interpreted as such
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Tries to figure out which columns seem to have lat lon values, renames those in the data.frame.
Cleans up lat and lon values (removes extra characters, makes numeric)
\end{Details}
%
\begin{Value}
Returns the same data.frame but with relevant colnames changed to lat and lon,
and invalid lat or lon values cleaned up if possible or else replaced with NA
\end{Value}
%
\begin{SeeAlso}\relax
Used by \code{\LinkA{latlon\_from\_anything()}{latlon.Rul.from.Rul.anything}}. Uses \code{\LinkA{latlon\_infer()}{latlon.Rul.infer}} \code{\LinkA{latlon\_is.valid()}{latlon.Rul.is.valid}} \code{\LinkA{latlon\_as.numeric()}{latlon.Rul.as.numeric}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
#  x <- latlon_df_clean(x)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{latlon\_from\_anything}{latlon\_from\_anything - Flexibly get lat/lon from file, data.frame, data.table, or lat/lon vectors}{latlon.Rul.from.Rul.anything}
\aliasA{latlon\_any\_format}{latlon\_from\_anything}{latlon.Rul.any.Rul.format}
\aliasA{lonlat\_any\_format}{latlon\_from\_anything}{lonlat.Rul.any.Rul.format}
%
\begin{Description}\relax
Try to figure out if user provided latitude / longitude as vectors, data.frame, file, or interactively pick file.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
latlon_from_anything(x, y)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] If missing and interactive mode in RStudio, prompts user for file. Otherwise,
this can be a filename (csv or xlsx, with path), or data.frame/ data.table/ matrix,
or vector of longitudes (in which case y must be the latitudes).
Note that even though it is called latlon\_etc the
lon is x and comes before the lat among parameters x,y (unlike in most other functions here using lat,lon)
File or data.frame/data.table/matrix must have columns called lat and lon, or names that can
be inferred to be that by latlon\_infer()

\item[\code{y}] If x is a vector of longitudes, y must be the latitudes. Ignored otherwise.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This function

relies on

read\_csv\_or\_xl()  and

\code{\LinkA{latlon\_df\_clean()}{latlon.Rul.df.Rul.clean}} which in turn uses \code{\LinkA{latlon\_infer()}{latlon.Rul.infer}} \code{\LinkA{latlon\_as.numeric()}{latlon.Rul.as.numeric}} \code{\LinkA{latlon\_is.valid()}{latlon.Rul.is.valid}}

read\_and\_clean\_points() from EJAMejscreenapi

would be the most general / flexible broadest way to get points, but is still work in progress

is similar to what is done by latlon\_from\_anything()

except it also uses these functions:

\code{\LinkA{latlon\_from\_siteid()}{latlon.Rul.from.Rul.siteid}}

\code{\LinkA{latlon\_from\_programid()}{latlon.Rul.from.Rul.programid}}   but not  \_from\_naics() ?
\end{Details}
%
\begin{Value}
A data.frame that has at least columns lon and lat (and others if they were in x)
\end{Value}
%
\begin{SeeAlso}\relax
read\_csv\_or\_xl() latlon\_df\_clean()
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
 
 if (interactive()) {
 pts <- latlon_from_anything()
 }
 latlon_from_anything(testpoints_100[1:6,] )
 latlon_from_anything(testpoints_100[1:6, c('lat','lon')] )
 latlon_from_anything(x=testpoints_100$lon[1:6], y=testpoints_100$lat[1:6] )
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{latlon\_from\_mactsubpart}{latlon\_from\_mactsubpart Get point locations for US EPA-regulated facilities that have sources subject to Maximum Achievable Control Technology (MACT) standards under the Clean Air Act.}{latlon.Rul.from.Rul.mactsubpart}
%
\begin{Description}\relax
latlon\_from\_mactsubpart
Get point locations for US EPA-regulated facilities that have
sources subject to Maximum Achievable Control Technology (MACT) standards
under the Clean Air Act.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
latlon_from_mactsubpart(subpart, include_if_no_latlon = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{subpart}] vector of one or more strings indicating the
Subpart of CFR Title 40 Part 63 that covers the source category
of interest, such as "FFFF" - see for example,
\url{https://www.ecfr.gov/current/title-40/part-63/subpart-FFFF}

\item[\code{include\_if\_no\_latlon}] logical - many in the database lack lat lon values but have a MACT code
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
See \url{https://www.epa.gov/stationary-sources-air-pollution/national-emission-standards-hazardous-air-pollutants-neshap-8}
\end{Details}
%
\begin{Value}
a table of lat, lon, subpart, etc. for US EPA FRS sites with that MACT code
\end{Value}
\inputencoding{utf8}
\HeaderA{latlon\_from\_naics}{latlon\_from\_naics - Find EPA-regulated facilities in FRS by NAICS code (industrial category) Get lat lon, Registry ID, given NAICS industry code(s) Find all EPA Facility Registry Service (FRS) sites with this exact NAICS code (not subcategories)}{latlon.Rul.from.Rul.naics}
%
\begin{Description}\relax
latlon\_from\_naics - Find EPA-regulated facilities in FRS by NAICS code (industrial category)
Get lat lon, Registry ID, given NAICS industry code(s)
Find all EPA Facility Registry Service (FRS) sites with this exact NAICS code (not subcategories)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
latlon_from_naics(naics, id_only = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{naics}] a vector of naics codes, or
a data.table with column named code, as with output of \code{\LinkA{naics\_from\_any()}{naics.Rul.from.Rul.any}}
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
NOTE: many FRS sites lack NAICS code!

Also, this function does not find the sites
identified by FRS data as being in a child NAICS (subcategory of your exact query)!

Relies on  frs\_by\_naics (a data.table)

See info about NAICS industry codes at \url{https://www.naics.com/search}
\end{Details}
%
\begin{Value}
A data.table (not just data.frame) with columns called
lat, lon, REGISTRY\_ID, NAICS (but see the id\_only parameter)
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
  siteid_from_naics(321114)
  latlon_from_naics(321114)
  latlon_from_naics(EJAM::naics_from_any("cheese")[,code] )
  head(latlon_from_naics(c(3366, 33661, 336611), id_only=TRUE))
  # mapfast(frs_from_naics(336611)) # simple map
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{latlon\_from\_program}{latlon\_from\_program - Get lat lon, Registry ID, and NAICS, for given FRS Program System CATEGORY Find all FRS sites in a program like RCRAINFO, TRIS, or others}{latlon.Rul.from.Rul.program}
%
\begin{Description}\relax
latlon\_from\_program - Get lat lon, Registry ID, and NAICS, for given FRS Program System CATEGORY
Find all FRS sites in a program like RCRAINFO, TRIS, or others
\end{Description}
%
\begin{Usage}
\begin{verbatim}
latlon_from_program(query)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{program}] like "RMP", "RCRAINFO", "TRIS", "RMP", or others.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
For info on FRS program codes in general, see \url{https://www.epa.gov/frs/frs-program-crosswalks}

Also see information at \url{https://echo.epa.gov/tools/data-downloads/frs-download-summary}
about the file FRS\_PROGRAM\_LINKS.csv

For info on program codes ECHO uses, see \url{https://echo.epa.gov/resources/echo-data/about-the-data}

including \url{https://www.epa.gov/frs/frs-environmental-interest-types}

For a list of program acronyms, \url{https://www.epa.gov/frs/frs-rest-services\#appendixa}

The acronym is the abbreviated name that represents the name of an
information management system for an environmental program.
The Federal ones with at least 100k facilities each are

RCRAINFO (over 500k sites), NPDES, ICIS, AIR, FIS, EIS, and AIRS/AFS.
\end{Details}
%
\begin{Value}
data.table with lat  lon  REGISTRY\_ID  program -- but not pgm\_sys\_id
since there could be duplicates where same REGISTRY\_ID has 2 different pgm\_sys\_id values
in the same program, so results were sometimes longer than if using \code{\LinkA{frs\_from\_program()}{frs.Rul.from.Rul.program}}
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
 x = latlon_from_program("CAMDBS")
 EJAMejscreenapi::mapfast(x)
 program <- c("EIS", "UST")
 x = latlon_from_program(program)
 # to get the facility name as well:
 x = frs[grepl("RCRAINFO", PGM_SYS_ACRNMS), ] # fast
 ## x = latlon_from_siteid(latlon_from_program(program)[,REGISTRY_ID])  # slower!
 EJAMejscreenapi::mapfast(x[sample(1:nrow(x), 1000), ])

## End(Not run)
 
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{latlon\_from\_programid}{latlon\_from\_programid - Get lat lon, Registry ID, and NAICS, for given FRS Program System ID}{latlon.Rul.from.Rul.programid}
%
\begin{Description}\relax
latlon\_from\_programid - Get lat lon, Registry ID, and NAICS, for given FRS Program System ID
\end{Description}
%
\begin{Usage}
\begin{verbatim}
latlon_from_programid(programid)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{programid}] like "XJW000012435"
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The ID is the identification number, such as the permit number,
assigned by an information management system that represents a
facility site, waste site, operable unit, or other feature tracked by that
Environmental Information System.

Also note the FRS API:
\url{https://www.epa.gov/frs/facility-registry-service-frs-api}
\url{https://www.epa.gov/frs/frs-rest-services}
\end{Details}
%
\begin{Value}
data.table with lat  lon  REGISTRY\_ID  program   pgm\_sys\_id
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
 latlon_from_programid(c("XJW000012435", "00768SRTRSROAD1"))
 pids <- c("7-0540-00003", "354362", "1513529", "485659", "LAG750956", 
   "CAC002995519", "3601252181", "3601439158")
 latlon_from_siteid(latlon_from_programid(pids)[,REGISTRY_ID])
 latlon_from_programid(c("XJW000012435", "00768SRTRSROAD1", "asdfsdf"))[,.(lat,lon)]
 
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{latlon\_from\_regid}{latlon\_from\_siteid - Get lat lon (and NAICS) via Facility Registry ID}{latlon.Rul.from.Rul.regid}
%
\begin{Description}\relax
latlon\_from\_siteid - Get lat lon (and NAICS) via Facility Registry ID
\end{Description}
%
\begin{Usage}
\begin{verbatim}
latlon_from_regid(siteid)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{siteid}] Facility Registry Service ID like 110010052520
\end{ldescription}
\end{Arguments}
%
\begin{Value}
data.table with columns
lat,lon,REGISTRY\_ID,PRIMARY\_NAME,NAICS,PGM\_SYS\_ACRNMS
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
 latlon_from_siteid(110070874073)
x = latlon_from_siteid(
    c(110071293460, 110070874073, 110070538057, 110044340807,
       110030509215, 110019033810, 110056111559, 110056982323)
        )
EJAMejscreenapi::mapfast(x)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{latlon\_from\_sic}{latlon\_from\_sic - Find EPA-regulated facilities in FRS by SIC code (industrial category)}{latlon.Rul.from.Rul.sic}
%
\begin{Description}\relax
Get lat lon, Registry ID, given SIC industry code(s)
Find all EPA Facility Registry Service (FRS) sites with this exact SIC code (not subcategories)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
latlon_from_sic(sic, id_only = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{sic}] a vector of SIC codes, or
a data.table with column named code, as with output of \code{\LinkA{sic\_from\_any()}{sic.Rul.from.Rul.any}}
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
NOTE: many FRS sites lack SIC code!

Also, this function does not find the sites
identified by FRS data as being in a child SIC (subcategory of your exact query)!

Relies on  frs\_by\_sic (a data.table)

See info about SIC industry codes at \url{https://www.naics.com/search}
\end{Details}
%
\begin{Value}
A data.table (not just data.frame) with columns called
lat, lon, REGISTRY\_ID, SIC (but see the id\_only parameter)
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
  siteid_from_sic('7300')
  latlon_from_sic('7300')
  latlon_from_sic(sic_from_any("cheese")[,code] )
  head(latlon_from_sic(c('6150', '6300', '5995'), id_only=TRUE))
  # mapfast(frs_from_sic('6150')) # simple map
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{latlon\_from\_siteid}{latlon\_from\_siteid - Get lat lon (and NAICS) via Facility Registry ID}{latlon.Rul.from.Rul.siteid}
%
\begin{Description}\relax
latlon\_from\_siteid - Get lat lon (and NAICS) via Facility Registry ID
\end{Description}
%
\begin{Usage}
\begin{verbatim}
latlon_from_siteid(siteid)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{siteid}] Facility Registry Service ID like 110010052520
\end{ldescription}
\end{Arguments}
%
\begin{Value}
data.table with columns
lat,lon,REGISTRY\_ID,PRIMARY\_NAME,NAICS,PGM\_SYS\_ACRNMS
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
 latlon_from_siteid(110070874073)
x = latlon_from_siteid(
    c(110071293460, 110070874073, 110070538057, 110044340807,
       110030509215, 110019033810, 110056111559, 110056982323)
        )
EJAMejscreenapi::mapfast(x)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{latlon\_infer}{latlon\_infer - guess which columns have lat and lon based on aliases like latitude, FacLat, etc.}{latlon.Rul.infer}
%
\begin{Description}\relax
latlon\_infer - guess which columns have lat and lon based on aliases like latitude, FacLat, etc.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
latlon_infer(mycolnames)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mycolnames}] e.g., colnames(x) where x is a data.frame from read.csv
\end{ldescription}
\end{Arguments}
%
\begin{Value}
returns all of mycolnames except replacing the best candidates with lat and lon
\end{Value}
%
\begin{SeeAlso}\relax
latlon\_df\_clean() latlon\_infer() latlon\_is.valid() latlon\_as.numeric()
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
  latlon_infer(c('trilat', 'belong', 'belong')) # warns if no alias found, 
    #  but doesnt warn of dupes in other terms, just preferred term.
  latlon_infer(c('a', 'LONG', 'Longitude', 'lat')) # only the best alias is converted/used
  latlon_infer(c('a', 'LONGITUDE', 'Long', 'Lat')) # only the best alias is converted/used
  latlon_infer(c('a', 'longing', 'Lat', 'lat', 'LAT')) # case variants of preferred are 
      # left alone only if lowercase one is found
  latlon_infer(c('LONG', 'long', 'lat')) # case variants of a single alias are 
      # converted to preferred word (if pref not found), creating dupes!  warn!
  latlon_infer(c('LONG', 'LONG')) # dupes of an alias are renamed and still are dupes! warn!
  latlon_infer(c('lat', 'lat', 'Lon')) # dupes left as dupes but warn!
  
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{latlon\_is.available}{latlon\_is.available check if not NA using !is.na()}{latlon.Rul.is.available}
%
\begin{Description}\relax
latlon\_is.available
check if not NA using !is.na()
\end{Description}
%
\begin{Usage}
\begin{verbatim}
latlon_is.available(lat, lon)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{lat}] vector of latitudes

\item[\code{lon}] vector of longitudes
\end{ldescription}
\end{Arguments}
%
\begin{Value}
logical vector, one element per lat lon pair (location)
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{latlon\_is.usa()}{latlon.Rul.is.usa}} \code{\LinkA{latlon\_is.islandareas()}{latlon.Rul.is.islandareas}} \code{\LinkA{latlon\_is.available()}{latlon.Rul.is.available}} \code{\LinkA{latlon\_is.possible()}{latlon.Rul.is.possible}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{latlon\_is.islandareas}{latlon\_is.islandareas Check lat lon coordinates to see if each is approx. in general area of US Island Areas Guam, USVI, Amer Samoa or N Marianas See \LinkA{islandareas}{islandareas}}{latlon.Rul.is.islandareas}
%
\begin{Description}\relax
latlon\_is.islandareas
Check lat lon coordinates to see if each is approx. in general area of US Island Areas Guam, USVI, Amer Samoa or N Marianas
See \LinkA{islandareas}{islandareas}
\end{Description}
%
\begin{Usage}
\begin{verbatim}
latlon_is.islandareas(lat, lon)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{lat}] vector of latitudes

\item[\code{lon}] vector of longitudes
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector of TRUE / FALSE values indicating a given lat lon pair
is approximately in one of the rough bounding boxes that includes the 4 Island Areas.
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{latlon\_is.usa()}{latlon.Rul.is.usa}} \code{\LinkA{latlon\_is.islandareas()}{latlon.Rul.is.islandareas}} \code{\LinkA{latlon\_is.available()}{latlon.Rul.is.available}} \code{\LinkA{latlon\_is.possible()}{latlon.Rul.is.possible}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# this would require the testpoints_1000 data from the EJAM package:
  isles <- which(latlon_is.islandareas(lat = testpoints_1000$lat, lon = testpoints_1000$lon))
  mapfast(testpoints_1000[isles, ]) # c(213,785) 
  which(!(latlon_is.usa(lat = testpoints_1000$lat, lon = testpoints_1000$lon)))

## End(Not run)
  
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{latlon\_is.possible}{latlon\_is.possible check if between -180 and +180}{latlon.Rul.is.possible}
%
\begin{Description}\relax
latlon\_is.possible
check if between -180 and +180
\end{Description}
%
\begin{Usage}
\begin{verbatim}
latlon_is.possible(lat, lon)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{lat}] vector of latitudes

\item[\code{lon}] vector of longitudes
\end{ldescription}
\end{Arguments}
%
\begin{Value}
logical vector, one element per lat lon pair (location)
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{latlon\_is.usa()}{latlon.Rul.is.usa}} \code{\LinkA{latlon\_is.islandareas()}{latlon.Rul.is.islandareas}} \code{\LinkA{latlon\_is.available()}{latlon.Rul.is.available}} \code{\LinkA{latlon\_is.possible()}{latlon.Rul.is.possible}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{latlon\_is.usa}{latlon\_is.usa Check lat lon coordinates to see if each is approx. in general area of USA excluding Island Areas}{latlon.Rul.is.usa}
%
\begin{Description}\relax
latlon\_is.usa
Check lat lon coordinates to see if each is approx. in general area of USA excluding Island Areas
\end{Description}
%
\begin{Usage}
\begin{verbatim}
latlon_is.usa(lat, lon)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{lat}] vector of latitudes

\item[\code{lon}] vector of longitudes
\end{ldescription}
\end{Arguments}
%
\begin{Value}
logical vector, one element per lat lon pair (location)
Indicates the point is approximately in one of the
rough bounding boxes that includes the USA without
the Island Areas Guam, American Samoa, USVI, N Marianas Islands.
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{latlon\_is.usa()}{latlon.Rul.is.usa}} \code{\LinkA{latlon\_is.islandareas()}{latlon.Rul.is.islandareas}} \code{\LinkA{latlon\_is.available()}{latlon.Rul.is.available}} \code{\LinkA{latlon\_is.possible()}{latlon.Rul.is.possible}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{latlon\_is.valid}{latlon\_is.valid - Validate latitudes and longitudes}{latlon.Rul.is.valid}
%
\begin{Description}\relax
Check each latitude and longitude value to see if they are valid.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
latlon_is.valid(lat, lon, quiet = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{lat}] vector of latitudes

\item[\code{lon}] vector of longitudes

\item[\code{quiet}] optional logical, if TRUE, show list of bad values in console
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
NA or outside expected numeric ranges

(based on approx ranges of lat lon seen among block internal points dataset)

But note Guam, American Samoa, Northern Mariana Islands, and U.S. Virgin Islands are outside these ranges!
EJScreen 2.2 does not provide demographic data in those locations anyway, but can map sites there.

lat must be between 17.5 and 71.5, and

lon must be ( between -180 and -64) OR (between 172 and 180)
\end{Details}
%
\begin{Value}
logical vector, one element per lat lon pair (location)
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{latlon\_is.usa()}{latlon.Rul.is.usa}} \code{\LinkA{latlon\_is.islandareas()}{latlon.Rul.is.islandareas}} \code{\LinkA{latlon\_is.available()}{latlon.Rul.is.available}} \code{\LinkA{latlon\_is.possible()}{latlon.Rul.is.possible}}
\code{\LinkA{latlon\_df\_clean()}{latlon.Rul.df.Rul.clean}} \code{\LinkA{latlon\_infer()}{latlon.Rul.infer}} \code{\LinkA{latlon\_is.valid()}{latlon.Rul.is.valid}} \code{\LinkA{latlon\_as.numeric()}{latlon.Rul.as.numeric}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
 ## Not run: 
 # this would only work using the EJAM package datasets frs and blockpoints:
   if (!exists("frs")) dataload_from_pins("frs")
 table(latlon_is.valid(lat =  frs$lat, lon =  frs$lon))
 # blockpoints may need to be downloaded using dataload_from_aws()
 table(latlon_is.valid(lat =  blockpoints$lat, lon =  blockpoints$lon))
  
## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{latlon\_join\_on\_blockid}{latlon\_join\_on\_blockid - get lat,lon of each block internal point via blockid get expanded version of sites2blocks data.table, with new lat,lon columns}{latlon.Rul.join.Rul.on.Rul.blockid}
%
\begin{Description}\relax
latlon\_join\_on\_blockid - get lat,lon of each block internal point via blockid
get expanded version of sites2blocks data.table, with new lat,lon columns
\end{Description}
%
\begin{Usage}
\begin{verbatim}
latlon_join_on_blockid(s2b)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{s2b}] like \LinkA{testoutput\_getblocksnearby\_10pts\_1miles}{testoutput.Rul.getblocksnearby.Rul.10pts.Rul.1miles}, output of \code{\LinkA{getblocksnearby()}{getblocksnearby}}
\end{ldescription}
\end{Arguments}
%
\begin{Value}
returns the input data.table but with lat,lon columns added as block coordinates
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
 s2b = copy(testoutput_getblocksnearby_10pts_1miles)
 latlon_join_on_blockid(s2b) # done by trilaterate also
 
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{lat\_alias}{lat\_alias, lon\_alias (DATA) Synonyms for lat and lon}{lat.Rul.alias}
\aliasA{lon\_alias}{lat\_alias}{lon.Rul.alias}
%
\begin{Description}\relax
lists of synonyms for "latitude" and "longitude" used when guessing which column is what in user-provided tables of coordinates
\end{Description}
\inputencoding{utf8}
\HeaderA{linesofcode2}{linesofcode2 - UTILITY - count lines of source code per .R file (not per function) - NOT TESTED}{linesofcode2}
%
\begin{Description}\relax
linesofcode2 - UTILITY - count lines of source code per .R file (not per function) - NOT TESTED
\end{Description}
%
\begin{Usage}
\begin{verbatim}
linesofcode2(
  folder = getwd(),
  packages,
  recursive = TRUE,
  sums = FALSE,
  rfolderonly = FALSE,
  cropfilename = 40,
  croppath = 20,
  showrows = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{folder}] path to folder with .R files

\item[\code{packages}] optional vector of names of packages of source code

\item[\code{recursive}] logical, look in subfolders

\item[\code{sums}] logical, if TRUE, returns sums info, otherwise just prints that to console and returns more info

\item[\code{rfolderonly}] logical

\item[\code{cropfilename}] number of character to truncate filename to for display in console

\item[\code{croppath}] limit path for display

\item[\code{showrows}] optional
\end{ldescription}
\end{Arguments}
%
\begin{Value}
data.frame of info about files
\end{Value}
\inputencoding{utf8}
\HeaderA{lookup\_pctile}{lookup\_pctile - Find approx percentiles in lookup table that is in memory}{lookup.Rul.pctile}
%
\begin{Description}\relax
lookup\_pctile - Find approx percentiles in lookup table that is in memory
\end{Description}
%
\begin{Usage}
\begin{verbatim}
lookup_pctile(
  myvector,
  varname.in.lookup.table,
  lookup = usastats,
  zone = "USA"
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{myvector}] Numeric vector, required. Values to look for in the lookup table.

\item[\code{varname.in.lookup.table}] Character element, required.
Name of column in lookup table to look in
to find interval where a given element of myvector values is.

*** If vector is provided, then must be same length as myvector,

but only 1 value for zone can be provided.

\item[\code{lookup}] Either lookup must be provided, not quoted,
or a lookup table called \LinkA{usastats}{usastats} must already be in memory. This is the lookup table
data.frame with a PCTILE column, REGION column, and column whose name is the value of varname.in.lookup.table
To use state lookups set lookup=statestats

\item[\code{zone}] Character element (or vector as long as myvector), optional.
If specified, must appear in a column called REGION within the lookup table,
or NA returned for each item looked up and warning given.
For example, it could be "NY" for New York State, "USA" for national percentiles.
\end{ldescription}
\end{Arguments}
%
\begin{SeeAlso}\relax
Identical to \code{\LinkA{pctile\_from\_raw\_lookup()}{pctile.Rul.from.Rul.raw.Rul.lookup}} \LinkA{usastats}{usastats} \LinkA{statestats}{statestats}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{mact\_table}{mact\_table (DATA) MACT NESHAP subparts (the code and the description)}{mact.Rul.table}
%
\begin{Description}\relax
This is a data.table with one row per MACT subpart such as BBBBBB or ZZZZZZ
and the title of each category. From the ECHO download of ICIS Air
@seealso \LinkA{frs\_by\_mact}{frs.Rul.by.Rul.mact}
\end{Description}
\inputencoding{utf8}
\HeaderA{mapfastej\_counties}{mapfastej\_counties - Static or HTML/leaflet map of counties}{mapfastej.Rul.counties}
%
\begin{Description}\relax
mapfastej\_counties - Static or HTML/leaflet map of counties
\end{Description}
%
\begin{Usage}
\begin{verbatim}
mapfastej_counties(
  mydf,
  colorvarname = "pctile.Demog.Index.Supp",
  static_not_leaflet = FALSE,
  main = "Selected Counties",
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mydf}] something like  ejamit(fips = fips\_counties\_from\_statename("Kentucky"), radius = 0)\$results\_bysite

\item[\code{colorvarname}] colname of indicator in mydf that drives color-coding

\item[\code{static\_not\_leaflet}] set TRUE to use \code{\LinkA{map\_shapes\_plot()}{map.Rul.shapes.Rul.plot}} instead of \code{\LinkA{map\_shapes\_leaflet()}{map.Rul.shapes.Rul.leaflet}}

\item[\code{main}] title for map

\item[\code{...}] passed to map\_shapes\_plot() if relevant
\end{ldescription}
\end{Arguments}
%
\begin{Value}
leaflet html widget (but if static\_not\_leaflet=T,
returns just shapes\_counties\_from\_countyfips(mydf\$siteid))
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
 fips_ky <- fips_counties_from_statename("Kentucky")
 x <- ejamit(fips = fips_ky, radius = 0)
 mapfastej_counties(x$results_bysite)
 
## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{mapfast\_gg}{mapfast\_gg - A very simple ggplot2 map of points in the USA}{mapfast.Rul.gg}
%
\begin{Description}\relax
mapfast\_gg - A very simple ggplot2 map of points in the USA
\end{Description}
%
\begin{Usage}
\begin{verbatim}
mapfast_gg(
  mydf = data.frame(lat = 40, lon = -100)[0, ],
  dotsize = 1,
  ptcolor = "black",
  xlab = "Longitude",
  ylab = "Latitude",
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mydf}] data.frame with columns named lat and lon

\item[\code{dotsize}] optional, size of dot representing a point

\item[\code{ptcolor}] optional, color of dot

\item[\code{xlab}] optional, text for x label

\item[\code{ylab}] optional, text for y label

\item[\code{...}] optional, passed to \code{\LinkA{ggplot2::labs()}{ggplot2::labs()}}
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a ggplot() object
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
  mapfast_gg(EJAM::testpoints_10)
  
  pts <- read.table(textConnection(
  "lat lon 
  39.5624775 -119.7410994 
  42.38748056 -94.61803333"
  ),
  header = TRUE, 
  as.is = TRUE
  )
  mapfast_gg(pts)
  # str(pts) # lon, not long
  
## End(Not run)
  
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{map\_blockgroups\_over\_blocks}{map\_blockgroups\_over\_blocks - Overlay blockgroups near 1 site, after plotblocksnearby() Overlay blockgroups near 1 site, after plotblocksnearby()}{map.Rul.blockgroups.Rul.over.Rul.blocks}
%
\begin{Description}\relax
map\_blockgroups\_over\_blocks - Overlay blockgroups near 1 site, after plotblocksnearby()
Overlay blockgroups near 1 site, after plotblocksnearby()
\end{Description}
%
\begin{Usage}
\begin{verbatim}
map_blockgroups_over_blocks(y)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{y}] output of \code{\LinkA{plotblocksnearby()}{plotblocksnearby}}
\end{ldescription}
\end{Arguments}
%
\begin{Value}
leaflet map widget
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{map\_blockgroups()}{map.Rul.blockgroups}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
dontrun{
 y <- plotblocksnearby(testpoints_10[5,], 
        radius = 3,
        returnmap = TRUE)
 map_blockgroups_over_blocks(y)
  }
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{map\_facilities}{map\_facilities}{map.Rul.facilities}
%
\begin{Description}\relax
make a leaflet map of uploaded points
\end{Description}
%
\begin{Usage}
\begin{verbatim}
map_facilities(mypoints, rad = 3, highlight = FALSE, clustered)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mypoints, }] data frame of uploaded points

\item[\code{rad, }] a size for drawing each circle (buffer search radius)

\item[\code{highlight, }] a logicial for whether to highlight overlapping points (defaults to FALSE)

\item[\code{clustered, }] a vector of T/F values for each point, indicating if they overlap with another
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a leaflet map with circles, circleMarkers, and basic popup
\end{Value}
\inputencoding{utf8}
\HeaderA{map\_facilities\_proxy}{map\_facilities\_proxy}{map.Rul.facilities.Rul.proxy}
%
\begin{Description}\relax
update a leaflet map within the EJAM shiny app with uploaded points.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
map_facilities_proxy(
  mymap,
  rad = 3,
  highlight = FALSE,
  clustered = FALSE,
  popup_vec = NULL,
  use_marker_clusters = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mymap, }] leafletProxy map object to be added to

\item[\code{rad, }] a size for drawing each circle (buffer search radius)

\item[\code{highlight, }] a logicial for whether to highlight overlapping points (defaults to FALSE)

\item[\code{clustered, }] a vector of T/F values for each point, indicating if they overlap with another

\item[\code{popup\_vec, }] a vector of popup values to display when points are clicked. Length should match number of rows in the dataset.

\item[\code{use\_marker\_clusters, }] boolean for whether to group points into markerClusters. Uses logic from shiny app to only implement when n > 1000.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a leaflet map with circles, circleMarkers, and basic popup
\end{Value}
\inputencoding{utf8}
\HeaderA{map\_shapes\_leaflet}{map\_shapes\_leaflet}{map.Rul.shapes.Rul.leaflet}
%
\begin{Description}\relax
map\_shapes\_leaflet
\end{Description}
%
\begin{Usage}
\begin{verbatim}
map_shapes_leaflet(shapes, color = "green", popup = shapes$NAME)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{shapes}] like from shapes\_counties\_from\_countyfips()

\item[\code{color}] passed to leaflet::addPolygons()

\item[\code{popup}] passed to leaflet::addPolygons()
\end{ldescription}
\end{Arguments}
%
\begin{Value}
html widget from leaflet::leaflet()
\end{Value}
\inputencoding{utf8}
\HeaderA{map\_shapes\_mapview}{map\_shapes\_mapview}{map.Rul.shapes.Rul.mapview}
%
\begin{Description}\relax
map\_shapes\_mapview
\end{Description}
%
\begin{Usage}
\begin{verbatim}
map_shapes_mapview(shapes, col.regions = "green", map.types = "OpenStreetMap")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{shapes}] like from shapes\_counties\_from\_countyfips()

\item[\code{col.regions}] passed to mapview() from mapview package

\item[\code{map.types}] passed to mapview() from mapview package
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{map\_shapes\_plot}{map\_shapes\_plot}{map.Rul.shapes.Rul.plot}
%
\begin{Description}\relax
map\_shapes\_plot
\end{Description}
%
\begin{Usage}
\begin{verbatim}
map_shapes_plot(shapes, main = "Selected Census Units", ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{shapes}] like from shapes\_counties\_from\_countyfips()

\item[\code{main}] title for map

\item[\code{...}] passed to plot()
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Just draws map using plot()
\end{Value}
\inputencoding{utf8}
\HeaderA{metadata\_add}{helper function for package to set attributes of a dataset}{metadata.Rul.add}
%
\begin{Description}\relax
This can be used annually to update some datasets in a package.
It just makes it easier to set a few metadata attributes similarly
for a number of data elements, for example,
to add new or update existing attributes.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
metadata_add(x, metadata)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] dataset (or any object) whose metadata you want to update or create

\item[\code{metadata}] must be a named list, so that the function can do this for each i:
\code{attr(x, which=names(metadata)[i]) <- metadata[[i]]}
\end{ldescription}
\end{Arguments}
%
\begin{Value}
returns x but with new or altered attributes
\end{Value}
%
\begin{SeeAlso}\relax
metadata\_check()
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
  x <- data.frame(a=1:10,b=1001:1010)
  metadata <- list(
  ejscreen_version =  '2.2',
  acs_version =          '2017-2021',
  census_version = 2020,
  ejscreen_releasedate = '2023-06-23',
  acs_releasedate =      '2022-12-08',
  ejscreen_pkg_data = NA
  )
  x <- metadata_add(x, metadata)
  attributes(x)
  x <- metadata_add(x, list(status='final'))
  attr(x,'status')
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{metadata\_check}{helper function in updating the package metadata}{metadata.Rul.check}
%
\begin{Description}\relax
Quick and dirty helper during development, to check all the
attributes of all the data files in relevant packages.
It loads unloaded packages as needed, which you might not want it to do,
but it is not coded to be able to check attributes without doing that.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
metadata_check(
  packages = EJAM::ejampackages,
  which = c("census_version", "acs_version", "acs_releasedate", "ACS",
    "ejscreen_version", "ejscreen_releasedate", "ejscreen_pkg_data", "year", "released"),
  loadifnotloaded = TRUE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{packages}] Optional. e.g. 'EJAMejscreendata', or can be a vector of character strings,
and if not specified, default is to report on all packages with EJ as part of their name,
like EJAMejscreenapi

\item[\code{which}] Optional vector (not list) of strings, the attributes.
Default is some typical ones used in EJAM-related packages currently.

\item[\code{loadifnotloaded}] Optional to control if func should temporarily attach packages not already loaded.
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{NAICS}{NAICS (DATA) named list of all NAICS code numbers and industry name for each}{NAICS}
%
\begin{Description}\relax
NAICS (DATA) named list of all NAICS code numbers and industry name for each
\end{Description}
%
\begin{Details}\relax
see \url{https://naics.com}
\end{Details}
%
\begin{SeeAlso}\relax
\LinkA{naicstable}{naicstable} \code{\LinkA{naics\_from\_any()}{naics.Rul.from.Rul.any}} \code{\LinkA{naics\_categories()}{naics.Rul.categories}} \LinkA{NAICS}{NAICS}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{naics2children}{naics2children - See NAICS codes queried plus all children of any of those Used by naics\_find()}{naics2children}
%
\begin{Description}\relax
naics2children - See NAICS codes queried plus all children of any of those
Used by naics\_find()
\end{Description}
%
\begin{Usage}
\begin{verbatim}
naics2children(codes, allcodes = EJAM::NAICS)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{codes}] vector of numerical or character

\item[\code{allcodes}] Optional (already loaded with package) - dataset with all the codes
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
start with shortest (highest level) codes. since tied for nchar, these branches have zero overlap, so do each.
for each of those, get its children = all rows where parentcode == substr(allcodes, 1, nchar(parentcode))
put together list of all codes we want to include so far.
now for the next longest set of codes in original list of codes,
do same thing.
etc. until did it for 5 digit ones to get 6digit children.
take the unique(allthat)
table(nchar(as.character(NAICS)))
2    3    4    5    6
17   99  311  709 1057
\end{Details}
%
\begin{Value}
vector of codes and their names
\end{Value}
%
\begin{SeeAlso}\relax
naics\_find() NAICS
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
  naics2children(211)
  naics_find(211, exactnumber=TRUE)
  naics_find(211, exactnumber=TRUE, add_children = TRUE)
  NAICS[211][1:3] # wrong
  NAICS[NAICS == 211]
  NAICS["211 - Oil and Gas Extraction"]
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{naicstable}{naicstable (DATA) data.table of NAICS code(s) and industry names for each EPA-regulated site in Facility Registry Service Also has the 2,3,4,5,and 6-digit NAICS that this code falls under, where relevant for given length}{naicstable}
%
\begin{Description}\relax
This is similar to the data file EJAM::NAICS but in a more useful format and newer functions work with it.
\end{Description}
%
\begin{Details}\relax
see \url{https://naics.com}
\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{naics\_from\_any()}{naics.Rul.from.Rul.any}} \LinkA{NAICS}{NAICS}  \code{\LinkA{naics\_categories()}{naics.Rul.categories}}  \code{\LinkA{naics\_findwebscrape()}{naics.Rul.findwebscrape}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{naics\_categories}{naics\_categories - See the names of industrial categories and their NAICS code Easy way to list the 2-digit NAICS (17 categories), or other level}{naics.Rul.categories}
%
\begin{Description}\relax
naics\_categories - See the names of industrial categories and their NAICS code
Easy way to list the 2-digit NAICS (17 categories), or other level
\end{Description}
%
\begin{Usage}
\begin{verbatim}
naics_categories(digits = 2, dataset = EJAM::NAICS)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{digits}] default is 2, for 2-digits NAICS, the top level, but could be up to 6.

\item[\code{dataset}] Should default to the dataset called NAICS, installed with this package.
see \LinkA{NAICS}{NAICS}  Check attr(NAICS, 'year')
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Also see \url{https://www.naics.com/search/}

There are this many NAICS codes roughly by number of digits in the code:

table(nchar(NAICS))

2    3    4    5    6

17   99  311  709 1057

See \url{https://www.census.gov/naics/}
\end{Details}
%
\begin{SeeAlso}\relax
\LinkA{naics\_from\_any}{naics.Rul.from.Rul.any}  \LinkA{NAICS}{NAICS}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
 naics_categories()
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{naics\_download}{naics\_download - script to download NAICS file with code and name of sector}{naics.Rul.download}
%
\begin{Description}\relax
See source code. Mostly just a short script to get the 2017 or 2022 codes and names.
See <'https://www.census.gov/naics/?48967'>
\end{Description}
%
\begin{Usage}
\begin{verbatim}
naics_download(
  year = 2017,
  urlpattern = "https://www.census.gov/naics/YYYYNAICS/2-6%20digit_YYYY_Codes.xlsx",
  destfile = paste0("~/Downloads/", year, "NAICS.xlsx")
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{year}] which vintage of NAICS codes to use, 2012, 2017, or 2022

\item[\code{urlpattern}] full url of xlsx file to use, but with YYYY instead of year

\item[\code{destfile}] full path and name of file to save as locally
\end{ldescription}
\end{Arguments}
%
\begin{Value}
names list with year as an attribute
\end{Value}
\inputencoding{utf8}
\HeaderA{naics\_findwebscrape}{naics\_findwebscrape - for query term, show list of roughly matching NAICS, scraped from web This finds more than just \code{\LinkA{naics\_from\_any()}{naics.Rul.from.Rul.any}} does, since that needs an exact match but this looks at naics.com website which lists various aliases for a sector.}{naics.Rul.findwebscrape}
%
\begin{Description}\relax
naics\_findwebscrape - for query term, show list of roughly matching NAICS, scraped from web
This finds more than just \code{\LinkA{naics\_from\_any()}{naics.Rul.from.Rul.any}} does, since that needs an exact match
but this looks at naics.com website which lists various aliases for a sector.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
naics_findwebscrape(query)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{query}] text like "gasoline" or "copper smelting"
\end{ldescription}
\end{Arguments}
%
\begin{Value}
data.frame of info on what was found, naics and title
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{naics\_from\_any()}{naics.Rul.from.Rul.any}}  \code{\LinkA{url\_naics.com()}{url.Rul.naics.com}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
 # naics_from_any("copper smelting")
 # naics_from_any("copper smelting", website_scrape=TRUE)
 # browseURL(naics_from_any("copper smelting", website_url=TRUE) )
 
  url_naics.com("copper smelting")
  ## Not run: 
  naics_findwebscrape("copper smelting")
  browseURL(url_naics.com("copper smelting"))
  browseURL(naics_url_of_code(326))
  
## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{naics\_from\_any}{naics\_from\_any - General way to search for industry names and NAICS codes Find industry names and codes by searching for queried code(s) or text}{naics.Rul.from.Rul.any}
%
\begin{Description}\relax
naics\_from\_any - General way to search for industry names and NAICS codes
Find industry names and codes by searching for queried code(s) or text
\end{Description}
%
\begin{Usage}
\begin{verbatim}
naics_from_any(
  query,
  children = FALSE,
  ignore.case = TRUE,
  fixed = FALSE,
  website_scrape = FALSE,
  website_url = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{query}] query string(s) and/or number(s), vector of NAICS codes or industry names or any regular expression or partial words

\item[\code{children}] logical, if TRUE, also return all the subcategories - where NAICS starts with the same digits

\item[\code{ignore.case}] see \code{\LinkA{grepl()}{grepl}}

\item[\code{fixed}] should it be an exact match? see \code{\LinkA{grepl()}{grepl}}

\item[\code{website\_scrape}] whether to scrape info from the NAICS website to return a table of codes and names that match (web query uses synonyms so gets more hits)

\item[\code{website\_url}] whether to return the URL of the webpage with info on the NAICS (web query uses synonyms so gets more hits)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a subset of the \LinkA{naicstable}{naicstable} data.table (not just the codes column)
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{naics\_subcodes\_from\_code()}{naics.Rul.subcodes.Rul.from.Rul.code}} \code{\LinkA{naics\_from\_code()}{naics.Rul.from.Rul.code}}  \code{\LinkA{naics\_from\_name()}{naics.Rul.from.Rul.name}}  \code{\LinkA{naics\_from\_any()}{naics.Rul.from.Rul.any}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
# Also see vignette for examples
  naics_categories()
  naics_from_any(naics_categories(3))[order(name),.(name,code)][1:10,] 
  naics_from_any(naics_categories(3))[order(code),.(code,name)][1:10,] 
  naics_from_code(211)
  naicstable[code==211,]
  naics_subcodes_from_code(211)
  naics_from_code(211,  children = TRUE)
  naicstable[n3==211,]
  NAICS[211][1:3] # wrong
  NAICS[NAICS == 211]
  NAICS["211 - Oil and Gas Extraction"]
  
 naics_from_any("plastics and rubber")[,.(name,code)]
 naics_from_any(326)
 naics_from_any(326, children = T)[,.(code,name)]
 naics_from_any("plastics", children=T)[,unique(n3)] 
 naics_from_any("pig")
 naics_from_any("pig ") # space after g
 
 # naics_from_any("copper smelting")
 # naics_from_any("copper smelting", website_scrape=TRUE)
 # browseURL(naics_from_any("copper smelting", website_url=TRUE) )
 
 a = naics_from_any("plastics")
 b = naics_from_any("rubber") 
 fintersect(a,b)[,.(name,code)] #  a AND b
 funion(a,b)[,.(name,code)]     #  a OR  b
 naics_subcodes_from_code(funion(a,b)[,code])[,.(name,code)]   #  plus children
 naics_from_any(funion(a,b)[,code], children=T)[,.(name,code)] #  same
 
 NROW(naics_from_any(325))
#[1] 1
 NROW(naics_from_any(325, children = T))
#[1] 54
 NROW(naics_from_any("chem"))
#[1] 20
 NROW(naics_from_any("chem", children = T))
[1] 104


\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{naics\_from\_code}{naics\_from\_code - search for industry names by NAICS code(s), 2-6 digits long each See \code{\LinkA{naics\_from\_any()}{naics.Rul.from.Rul.any}} which uses this}{naics.Rul.from.Rul.code}
%
\begin{Description}\relax
naics\_from\_code - search for industry names by NAICS code(s), 2-6 digits long each
See \code{\LinkA{naics\_from\_any()}{naics.Rul.from.Rul.any}} which uses this
\end{Description}
%
\begin{Usage}
\begin{verbatim}
naics_from_code(mycodes, children = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mycodes}] vector of numeric NAICS codes. see \url{https://naics.com}

\item[\code{children}] logical, if TRUE, also return all the subcategories - where NAICS starts with the same digits
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a subset of the \LinkA{naicstable}{naicstable} data.table (not just the codes column)
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{naics\_subcodes\_from\_code()}{naics.Rul.subcodes.Rul.from.Rul.code}} \code{\LinkA{naics\_from\_code()}{naics.Rul.from.Rul.code}}  \code{\LinkA{naics\_from\_name()}{naics.Rul.from.Rul.name}}  \code{\LinkA{naics\_from\_any()}{naics.Rul.from.Rul.any}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{naics\_from\_federalregister}{naics\_from\_federalregister - DRAFT WORK IN PROGRESS}{naics.Rul.from.Rul.federalregister}
%
\begin{Description}\relax
naics\_from\_federalregister - DRAFT WORK IN PROGRESS
\end{Description}
%
\begin{Usage}
\begin{verbatim}
naics_from_federalregister(naics_text_copy_from_fr)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{naics\_text\_copy\_from\_fr}] 
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{naics\_from\_name}{naics\_from\_name - search for industry names and NAICS codes by query string query by parts of words, etc. in the industry name. See \code{\LinkA{naics\_from\_any()}{naics.Rul.from.Rul.any}} which uses this}{naics.Rul.from.Rul.name}
%
\begin{Description}\relax
naics\_from\_name - search for industry names and NAICS codes by query string
query by parts of words, etc. in the industry name.
See \code{\LinkA{naics\_from\_any()}{naics.Rul.from.Rul.any}} which uses this
\end{Description}
%
\begin{Usage}
\begin{verbatim}
naics_from_name(mynames, children = FALSE, ignore.case = TRUE, fixed = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mynames}] query string, vector of NAICS industry names or any regular expression or partial words. See \url{https://naics.com}

\item[\code{children}] logical, if TRUE, also return all the subcategories - where NAICS starts with the same digits

\item[\code{ignore.case}] see \code{\LinkA{grepl()}{grepl}}

\item[\code{fixed}] should it be an exact match? see \code{\LinkA{grepl()}{grepl}}

\item[\code{search\_on\_naics\_website}] whether to query on naics website for more hits than just search for text in industry title
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a subset of the \LinkA{naicstable}{naicstable} data.table (not just the codes column)
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{naics\_subcodes\_from\_code()}{naics.Rul.subcodes.Rul.from.Rul.code}} \code{\LinkA{naics\_from\_code()}{naics.Rul.from.Rul.code}}  \code{\LinkA{naics\_from\_name()}{naics.Rul.from.Rul.name}}  \code{\LinkA{naics\_from\_any()}{naics.Rul.from.Rul.any}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
 data.table::fintersect(naics_from_any( "manufac"), naics_from_any("chem"))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{naics\_subcodes\_from\_code}{naics\_subcodes\_from\_code - find subcategories of the given overall NAICS industry code(s) Given 3-digit NAICS code, for example, get all NAICS that start with those digits.}{naics.Rul.subcodes.Rul.from.Rul.code}
%
\begin{Description}\relax
naics\_subcodes\_from\_code - find subcategories of the given overall NAICS industry code(s)
Given 3-digit NAICS code, for example, get all NAICS that start with those digits.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
naics_subcodes_from_code(mycodes)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mycodes}] NAICS codes vector, of 2 to 6 digits each. See \url{https://naics.com}
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
similar idea was naics2children() but this is more robust
See \code{\LinkA{naics\_from\_any()}{naics.Rul.from.Rul.any}} which uses this
\end{Details}
%
\begin{Value}
a subset of the \LinkA{naicstable}{naicstable} data.table (not just the codes column)
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{naics\_subcodes\_from\_code()}{naics.Rul.subcodes.Rul.from.Rul.code}} \code{\LinkA{naics\_from\_code()}{naics.Rul.from.Rul.code}}  \code{\LinkA{naics\_from\_name()}{naics.Rul.from.Rul.name}}  \code{\LinkA{naics\_from\_any()}{naics.Rul.from.Rul.any}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
  naics_categories()
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{naics\_url\_of\_code}{naics\_url\_of\_code - Get URL for page with info about industry sector(s) by NAICS See (https://naics.com) for more information on NAICS codes}{naics.Rul.url.Rul.of.Rul.code}
%
\begin{Description}\relax
naics\_url\_of\_code - Get URL for page with info about industry sector(s) by NAICS
See (https://naics.com) for more information on NAICS codes
\end{Description}
%
\begin{Usage}
\begin{verbatim}
naics_url_of_code(naics)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{naics}] vector of one or more NAICS codes, like 11,"31-33",325
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector of URLs as strings like https://www.naics.com/six-digit-naics/?v=2017\&code=22
\end{Value}
\inputencoding{utf8}
\HeaderA{naics\_validation}{naics\_validation - Validate NAICS uploads}{naics.Rul.validation}
%
\begin{Description}\relax
Validates and prepares echo uploads
\end{Description}
%
\begin{Usage}
\begin{verbatim}
naics_validation(naics_enter, naics_select)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{naics\_enter}] vector of naics

\item[\code{naics\_select}] 
\end{ldescription}
\end{Arguments}
%
\begin{Value}
boolean value (valid or not valid) - TRUE if
length of at least one of the two input vectors is > 0
\end{Value}
\inputencoding{utf8}
\HeaderA{names\_d}{names\_d (DATA) list of demographic indicator names}{names.Rul.d}
%
\begin{Description}\relax
names\_d (DATA) list of demographic indicator names
\end{Description}
%
\begin{SeeAlso}\relax
map\_headernames (in EJAMejscreenapi package) \LinkA{names\_d}{names.Rul.d} \LinkA{names\_e}{names.Rul.e} \LinkA{namez}{namez}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{names\_e}{names\_e (DATA) list of environmental indicator names}{names.Rul.e}
%
\begin{Description}\relax
names\_e (DATA) list of environmental indicator names
\end{Description}
%
\begin{SeeAlso}\relax
EJAMejscreenapi dataset called map\_headernames \LinkA{names\_d}{names.Rul.d} \LinkA{names\_e}{names.Rul.e} \LinkA{namez}{namez}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{names\_whichlist}{names\_whichlist See which of the lists of names a single term appears in}{names.Rul.whichlist}
%
\begin{Description}\relax
names\_whichlist
See which of the lists of names a single term appears in
\end{Description}
%
\begin{Usage}
\begin{verbatim}
names_whichlist(
  x,
  exact = T,
  grepmatching = T,
  ignore.case.exact = FALSE,
  ignore.case.grep = FALSE,
  keylists = F,
  exactonly = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] term, like part or all of a variable name, such as state.avg

\item[\code{exact}] whether to look for exact matches

\item[\code{grepmatching}] whether to look for matches via grep (partial match)

\item[\code{ignore.case.exact}] whether to ignore capitalization in exact matches

\item[\code{ignore.case.grep}] passed to grep as ignore.case param

\item[\code{keylists}] if true, only report for the key lists not friendly, all, these, need types.

\item[\code{exactonly}] to limit output to rows with exact matches
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
EJAM::namez has a list of lists of names used for indicators or variables, such as
namez\$d\_friendly which is a vector of terms like
"Demog.Ind.", "Suppl Demog Index",  "\% Low-inc.", etc.
\end{Details}
%
\begin{Value}
a data.frame of whichlist, exactmatch, grepmatch, and grephits (examples)
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
 
   x <- names_whichlist("rsei", ignore.case.exact = T, ignore.case.grep = T)
   subset(x, !grepl("friendly", x$whichlist))
   
   subset(x,  grepl("friendly", x$whichlist))
   subset(namez, names(namez) != "all_r" & names(namez) %in%
      subset(x, x$grepmatch == "yes" & !grepl("friendly", x$whichlist))$whichlist  )
   grep("\\.eo$", namez$ej, value = T)
   
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{names\_whichlist\_multi}{names\_whichlist\_multi See which lists of names the given indicator names are in}{names.Rul.whichlist.Rul.multi}
%
\begin{Description}\relax
names\_whichlist\_multi
See which lists of names the given indicator names are in
\end{Description}
%
\begin{Usage}
\begin{verbatim}
names_whichlist_multi(x, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] vector of names (query terms)

\item[\code{...}] passed to names\_whichlist()
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a list of sets of names
\end{Value}
\inputencoding{utf8}
\HeaderA{names\_whichlist\_multi\_key}{names\_whichlist\_multi\_key See which key lists of names the given indicator names are in}{names.Rul.whichlist.Rul.multi.Rul.key}
%
\begin{Description}\relax
names\_whichlist\_multi\_key
See which key lists of names the given indicator names are in
\end{Description}
%
\begin{Usage}
\begin{verbatim}
names_whichlist_multi_key(x, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] vector of names

\item[\code{...}] passed to names\_whichlist\_multi()
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector maybe
\end{Value}
\inputencoding{utf8}
\HeaderA{namez}{namez (DATA) list of lists of indicator names (complete list in 1 object)}{namez}
%
\begin{Description}\relax
namez (DATA) list of lists of indicator names (complete list in 1 object)
\end{Description}
%
\begin{SeeAlso}\relax
EJAMejscreenapi dataset called map\_headernames \LinkA{names\_d}{names.Rul.d} \LinkA{names\_e}{names.Rul.e}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{pctiles\_lookup\_create}{pctiles\_lookup\_create - create lookup table of percentiles 0 to 100 and mean for each indicator by State or USA total}{pctiles.Rul.lookup.Rul.create}
%
\begin{Description}\relax
pctiles\_lookup\_create - create lookup table of percentiles 0 to 100 and mean for each indicator by State or USA total
\end{Description}
%
\begin{Usage}
\begin{verbatim}
pctiles_lookup_create(
  x,
  zone.vector = NULL,
  zoneOverallName = "USA",
  wts = NULL,
  usecollapse = TRUE,
  type = 7
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] data.frame with numeric data. Each column will be examined to calculate
mean,   and percentiles, for each zone

\item[\code{zone.vector}] optional names of states or regions, for example. same length as wts, or rows in mydf

\item[\code{zoneOverallName}] optional. Default is USA.

\item[\code{wts}] leave as default since weighted percentiles of blockgroups are not used for EJScreen percentiles anymore

\item[\code{usecollapse}] logical, whether to use collapse::fquantile()
instead of Hmisc package wtd.quantile and stats pkg quantile,
to test before fully removing dependency on Hmisc and also speed it up.

\item[\code{type}] DO NOT CHANGE - moot for EJScreen/EJAM - SEE SOURCE CODE - Hmisc pkg wtd.quantile type "1/n" was used here in the past and possibly by EJScreen
(EJScreen no longer uses weighted percentiles so this is moot for the weighted case)
but collapse pkg fquantile is now used here to avoid Hmisc dependency
and fquantile type 4 seems to be the same as Hmisc type "1/n" but that has not been confirmed,
and this function by default uses fquantile type 1, the inverse of the ECDF however,
which seems simpler than using type 4 which does linear interpolation between points of the ECDF!
***  NEED TO CONFIRM IF THAT CREATES A TABLE DIFFERENT THAN WHAT EJSCREEN WOULD CREATE
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
EJScreen assigns each indicator in each block group a percentile value via python script, using
\url{https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.percentileofscore.html}

The way the python function is used as of 2023 is that percentileofscore is 80\% if

80\% of all indicator values (statewide or nationwide, depending on the type being calculated)

are less than (NOT equal to) the indicator value

in the specified block group (since kind="strict").

The percentile recorded in the EJScreen dataset is the floor of that,

meaning if the 81.9\% of values are less than x, the percentile is reported as 81.

The EJScreen python script used to create percentile lookup tables is in a file

called cal\_statepctile\_0222.py and the key lines of code and functions it uses are

pctile = math.floor(stats.percentileofscore(barray, indicatorscore, kind="strict"))

binvalue = getBinvalue(pctile)

and

def getBinvalue(pct):

if pct is None:
return 0
else:
if pct >= 95:
return 11
elif pct >= 90 and pct < 95:
return 10
elif pct >= 80 and pct < 90:
return 9
elif pct >= 70 and pct < 80:
return 8
elif pct >= 60 and pct < 70:
return 7
elif pct >= 50 and pct < 60:
return 6
elif pct >= 40 and pct < 50:
return 5
elif pct >= 30 and pct < 40:
return 4
elif pct >= 20 and pct < 30:
return 3
elif pct >= 10 and pct < 20:
return 2
else:
return 1
\end{Details}
\inputencoding{utf8}
\HeaderA{pctile\_from\_raw\_lookup}{pctile\_from\_raw\_lookup - Find approx percentiles in lookup table that is in memory}{pctile.Rul.from.Rul.raw.Rul.lookup}
\aliasA{lookup\_pctile}{pctile\_from\_raw\_lookup}{lookup.Rul.pctile}
%
\begin{Description}\relax
This is used with a lookup table to
convert a raw indicator vector to percentiles in US or States.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
pctile_from_raw_lookup(
  myvector,
  varname.in.lookup.table,
  lookup = usastats,
  zone = "USA"
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{myvector}] Numeric vector, required. Values to look for in the lookup table.

\item[\code{varname.in.lookup.table}] Character element, required.
Name of column in lookup table to look in
to find interval where a given element of myvector values is.

*** If vector is provided, then must be same length as myvector,

but only 1 value for zone can be provided.

\item[\code{lookup}] Either lookup must be provided, not quoted,
or a lookup table called \LinkA{usastats}{usastats} must already be in memory. This is the lookup table
data.frame with a PCTILE column, REGION column, and column whose name is the value of varname.in.lookup.table
To use state lookups set lookup=statestats

\item[\code{zone}] Character element (or vector as long as myvector), optional.
If specified, must appear in a column called REGION within the lookup table,
or NA returned for each item looked up and warning given.
For example, it could be "NY" for New York State, "USA" for national percentiles.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This could be recoded to be more efficient - could use data.table.

The data.frame lookup table must have a field called "PCTILE" that has quantiles/percentiles
and other column(s) with values that fall at those percentiles.
\LinkA{usastats}{usastats} and \LinkA{statestats}{statestats} are such lookup tables.
This function accepts lookup table (or uses one called us if that is in memory), and
finds the number in the PCTILE column that corresponds to where a specified value
(in myvector) appears in the column called varname.in.lookup.table.
The function just looks for where the specified value fits between values in the lookup table
and returns the approximate percentile as found in the PCTILE column.
If the value is between the cutpoints listed as
percentiles 89 and 90, it returns 89, for example.
If the value is exactly equal to the cutpoint listed as percentile 90,
it returns percentile 90.
If the value is exactly the same as the minimum in the lookup table and multiple percentiles
in that lookup are listed as tied for having the same threshold value defining the percentile
(i.e., a large percent of places have the same score and it is the minimum score),
then the percentile gets reported as 0,
not the percent of places tied for that minimum score. Note this is true whether they are
tied at a value of 0 or are tied at some other minimum value than 0.
If the value is less than the cutpoint listed as percentile 0,
which should be the minimum value in the dataset,
it still returns 0 as the percentile, but with a warning that
the value checked was less than the minimum in the dataset.

It also handles other odd cases, like where a large percent of all raw scores are tied at
the minimum value, in which case it reports 0 as percentile, not that large percent.
\end{Details}
%
\begin{Value}
By default, returns numeric vector length of myvector.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 

eg <- dput(round(as.vector(unlist(testoutput_ejamit_10pts_1miles$results_overall[ , ..names_d] )),3))

data.frame(value = eg, pctile = t(testoutput_ejamit_10pts_1miles$results_overall[ , ..names_d_pctile]))

data.frame(value = eg, pctile = lookup_pctile(eg, names_d))


  # compare ejscreen API output percentiles to those from this function:
  for (vname in c(names_d[c(1,3:6,8:10)] )) {
     print(pctile_from_raw_lookup(testoutput_ejscreenapi_plus_100[,vname] / 100, vname, 
       lookup = usastats) 
       - testoutput_ejscreenapi_plus_100[,paste0("pctile.",vname)] )
  }
  for (vname in c(names_e )) {
     print(pctile_from_raw_lookup(testoutput_ejscreenapi_plus_100[,vname], vname, 
       lookup = usastats)
         - testoutput_ejscreenapi_plus_100[,paste0("pctile.",vname)] )
  }

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plotblocksnearby}{plotblocksnearby - Map view of Census blocks (their centroids) near one or more sites Utility to quickly view one or more facility points on map with the blocks found nearby}{plotblocksnearby}
%
\begin{Description}\relax
plotblocksnearby - Map view of Census blocks (their centroids) near one or more sites
Utility to quickly view one or more facility points on map with the blocks found nearby
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plotblocksnearby(
  sitepoints,
  radius = 3,
  sites2blocks,
  usemapfast = TRUE,
  returnmap = FALSE,
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{sitepoints}] table of points with lat, lon in decimal degrees (data.frame or data.table),
but also could just be the output of getblocksnearby() if that has already been done.

\item[\code{radius}] in miles (Max allowed is 32 miles, or just over 50 kilometers since 31.06856 miles is 50 * 1000 / meters\_per\_mile).

\item[\code{sites2blocks}] If provided, used as sites2blocks like \LinkA{testoutput\_getblocksnearby\_10pts\_1miles}{testoutput.Rul.getblocksnearby.Rul.10pts.Rul.1miles}
If neither sites2blocks nor sitepoints is provided it cannot plot and returns error.
If sites2blocks and sitepoints are both provided, it uses them both to plot blocks and sites (centers of circles).
If sites2blocks not provided, but sitepoints alone is provided, checks if sitepoints is actually sites2blocks, and uses as such.
If sites2blocks not provided, but sitepoints alone is provided, and sitepoints is really sitepoints, it runs getblocksnearby() to create sites2blocks.
If sites2blocks is provided, but sitepoints is not, it could only do a bad approximation of sitepoints so it will not draw the circle or site at center of the circle.

\item[\code{usemapfast}] optional. simpler plot if FALSE

\item[\code{returnmap}] optional. if set TRUE, returns the leaflet map object instead of tabular info.

\item[\code{...}] passed to mapfast() or plot() depending on usemapfast
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Uses \code{\LinkA{getblocksnearby()}{getblocksnearby}} if lat,lon points provided as sitepoints,
but skips it if looks like user passed output of getblocksnearby(),
and then displays a map of those blocks near the specified point.
\end{Details}
%
\begin{Value}
invisibly returns sites2blocks like getblocksnearby() does
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
  #  see all Census Blocks within 1 mile of 1 site, if already had run getblocksnearby()
   z =  plotblocksnearby(sitepoints = testpoints_10, 
   sites2blocks = testoutput_getblocksnearby_10pts_1miles[siteid == 1,], radius = 1  )
   # see two sites if already had run getblocksnearby()
   z =  plotblocksnearby(sitepoints = testpoints_10[c(4,10),], 
   sites2blocks = testoutput_getblocksnearby_10pts_1miles[siteid %in% c(4,10),], radius = 1  )
  ## Not run: 
  # See one randomly selected regulated facility from FRS and all Census Blocks within 2 miles:
    plotblocksnearby(testpoints_n(1), 2) 
  # See two sites and all Census Blocks within 5 kilometers
    plotblocksnearby(testpoints_2, radius = convert_units(5, from = "km", towhat = "miles"))
  # See 100 sites and all blocks within 1 mile of each - 
  # Note you have to specify radius here or it uses default that may not match intent 
  # - and this is a bit slow
  plotblocksnearby(testdata_ejamit_output_100pts_1miles$results_bysite[,.(siteid, lat,lon)], radius = 1) 
  
## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plot\_barplot\_ratios}{plot\_barplot\_ratios Make barplot of ratios of demographic score to its average}{plot.Rul.barplot.Rul.ratios}
%
\begin{Description}\relax
plot\_barplot\_ratios
Make barplot of ratios of demographic score to its average
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plot_barplot_ratios(
  ratio.to.us.d.overall,
  names2plot_friendly = NULL,
  mycolorsavailable = c("gray", "yellow", "orange", "red")
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{ratio.to.us.d.overall}] named list of a few ratios to plot

\item[\code{names2plot\_friendly}] names to use for plot - should be same length as named list ratio.to.us.d.overall

\item[\code{mycolorsavailable}] leave as default
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
For plots in general, see:
\begin{itemize}

\item{} \url{https://echarts4r.john-coene.com/articles/themes.html}
\item{} \url{https://exts.ggplot2.tidyverse.org/gallery}

\end{itemize}


For BARPLOTS, see/ merge/consolidate:
\begin{itemize}

\item{} output\$view1\_summary\_plot <- renderPlot(v1\_summary\_plot()) and v1\_summary\_plot <- reactive( )
in EJAM server for Short Report if  bar type
\item{} output\$summ\_display\_bar <- renderPlot(  ) contains its own plot code not a reactive
in EJAM server for tab showing barplots in Detailed Results
\item{} plot\_barplot\_ratios() drafted function in EJAM

\end{itemize}


For BOXPLOTS, see:
\begin{itemize}

\item{} v1\_summary\_plot <- reactive( )     and output\$view1\_summary\_plot <- renderPlot(v1\_summary\_plot())

in EJAM server for SHORT report if box type, and

in EJAM server for LONG report passed as a parameter
\item{} boxplots\_ratios()   in EJAMejscreenapi

(NOT in EJAM server for Detailed Results interactive views)
\item{} ejscreenapi\_script() code also relevant? in EJAMejscreenapi
\item{} box/scatter examples in ggplot, \url{https://r-graph-gallery.com/89-box-and-scatter-plot-with-ggplot2.html}
\item{} boxplots in base R, \url{https://www.r-bloggers.com/2023/09/how-to-reorder-boxplots-in-r-a-comprehensive-guide}

\end{itemize}


For HISTOGRAMS, see:
\begin{itemize}

\item{} output\$summ\_display\_hist <- renderPlot   in EJAM server for interactive views
\item{} the histograms code and discussion in EJAMbatch.summarizer package

\end{itemize}

\end{Details}
%
\begin{Value}
ggplot should be returned
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{table\_xls\_format()}{table.Rul.xls.Rul.format}} \LinkA{plot\_barplot\_ratios}{plot.Rul.barplot.Rul.ratios}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
 
  plot_barplot_ratios(unlist(testoutput_ejamit_1000pts_1miles$results_overall[ , c(..names_d_ratio_to_avg , ..names_d_subgroups_ratio_to_avg) ]))
  
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plot\_demogshare\_by\_distance}{plot\_demogshare\_by\_distance - work in progress}{plot.Rul.demogshare.Rul.by.Rul.distance}
%
\begin{Description}\relax
plot\_demogshare\_by\_distance - work in progress
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plot_demogshare_by_distance(
  results_bybg_people,
  demogvarname = names_d[1],
  siteids = unique(results_bybg_people$siteid),
  show.lowess = F,
  show.lm = TRUE,
  show.line = TRUE,
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{results\_bybg\_people}] 

\item[\code{demogvarname}] 

\item[\code{siteids}] 

\item[\code{show.lowess}] F

\item[\code{show.lm}] linefit

\item[\code{show.line}] linefit

\item[\code{...}] passed to plot
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Could also consider plotting something like boxplot(demogvar \textasciitilde{} round(distance, 1))

See notes on plots at \code{\LinkA{plot\_barplot\_ratios()}{plot.Rul.barplot.Rul.ratios}}
\end{Details}
\inputencoding{utf8}
\HeaderA{plot\_distance\_by\_pctd}{plot\_distance\_by\_pctd  -  Plot percent demographics within X miles of a site}{plot.Rul.distance.Rul.by.Rul.pctd}
%
\begin{Description}\relax
plot\_distance\_by\_pctd  -  Plot percent demographics within X miles of a site
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plot_distance_by_pctd(
  s2b = NULL,
  mysiteid = NULL,
  myvars = c(names_d_count, names_d_subgroups_count)[1],
  dpctvar = paste0("pct", myvars)
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{s2b}] output of \code{\LinkA{getblocksnearby()}{getblocksnearby}}

\item[\code{mysiteid}] one number that is the siteid to look at in s2b

\item[\code{myvars}] a colname of a population count variable in blockgroupstats indicating which to plot, like "hisp" or "lowinc"
and only works for one indicator at a time so far.

\item[\code{dpctvar}] a colname of usastats and statestats that is the percentage version of myvars, like "pcthisp" or "pctlowinc"
\end{ldescription}
\end{Arguments}
%
\begin{Value}
returns s2b but with more columns in it, like cumpop, cumdpop, pctdwithin
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
  plot_distance_by_pctd()
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plot\_distance\_cdf\_by\_group}{plot\_distance\_cdf\_by\_group  - SLOW - needs to be optimized CDF Line Plots of cumulative share of each demographic group, within each distance Each groups distribution of distances}{plot.Rul.distance.Rul.cdf.Rul.by.Rul.group}
%
\begin{Description}\relax
plot\_distance\_cdf\_by\_group  - SLOW - needs to be optimized
CDF Line Plots of cumulative share of each demographic group, within each distance
Each groups distribution of distances
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plot_distance_cdf_by_group(
  results_bybg_people = NULL,
  radius_miles =
    round(max(results_bybg_people$distance_min_avgperson[!is.infinite(results_bybg_people$distance_min_avgperson)],
    na.rm = T), 1),
  subgroups_type = NULL,
  demogvarname = NULL,
  demoglabel = NULL,
  colorlist = colorspace::diverging_hcl(length(demogvarname)),
  coloroverall = "black",
  returnwhat = "table",
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{results\_bybg\_people}] data.table from doaggregate()\$results\_bybg\_people

\item[\code{radius\_miles}] miles radius that was max distance analyzed

\item[\code{subgroups\_type}] optional, can be set to "nh" or "alone".
Specifies types of race ethnicity subgroups to use for demogvarname
but only if demogvarname is not specified as a parameter.
If neither is specified it tries to use default\_subgroups\_type
if that is a variable set by global.R, since it cannot check the reactive variable input\$subgroups\_type
outside the context of the web app.

\item[\code{demogvarname}] optional way to specify names of columns to use from results\_bybg\_people,
e.g., c("pctlowinc", "pctmin"), or  namez\$d, or
could be a vector of subgroups such as namez\$d\_subgroups\_nh that includes "pctnhba" etc.
or namez\$d\_subgroups\_alone that includes "pctba" etc.,
but if demogvarname is not specified here as a parameter,
this info could also be specified by the subgroups\_type parameter here.
If neither is specified, the function will try to use a default
(which may not reflect any changes being made during development of EJAM if default\_subgroups\_type is in flux)

\item[\code{demoglabel}] friendly text names for labelling graphic, like "Low income residents"

\item[\code{colorlist}] colors like "red" etc. for the demographic groups of interest

\item[\code{coloroverall}] color like "gray" for everyone as a whole

\item[\code{returnwhat}] If returnwhat is "table", invisibly returns a
full table of sorted distances of blockgroups,
cumulative count of demog groups at that block group's distance.
If returnwhat is "plotfilename" then it returns the full path including filename of a .png in a tempdir
If returnwhat is "plot" then it returns the plot object as needed for table\_xls\_format()
\end{ldescription}
\end{Arguments}
%
\begin{Value}
see returnwhat parameter
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{distance\_by\_group()}{distance.Rul.by.Rul.group}} \code{\LinkA{ejamit()}{ejamit}} for examples
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
 y <- ejamit(testpoints_100, radius = 3)
 plot_distance_mean_by_group(y$results_bybg_people) # or distance_mean_by_group() synonym
 print(distance_by_group(y$results_bybg_people, 
   demogvarname = 'pctlowinc', demoglabel = 'Low Income'))
 distance_by_group_plot(y$results_bybg_people, 
   demogvarname = 'pctlowinc', demoglabel = 'Low Income')
 xyz = plot_distance_cdf_by_group(y$results_bybg_people) #  
 tail(round(xyz,3))
 tail(xyz[xyz$pctwa <= 0.501, ]) #  Median distance to nearest site here 
   for White Alone is 2.15 miles, but >60% of Black Alone have a site that close.
 tail(xyz[xyz$pctba <= 0.501, ]) #  Median distance to nearest site here 
   for Black Alone is 1.85 miles
 round(tail(xyz[xyz$dist <=1, ]), 3) #  11% of White have a site within 1 mile, 
   compared to 18.7% of Asian who do.
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{plot\_distance\_mean\_by\_group}{plot\_distance\_mean\_by\_group - Barplot Avg. proximity, by group Shows proximity to sites, for each demographic group (relative to everyone else)}{plot.Rul.distance.Rul.mean.Rul.by.Rul.group}
%
\begin{Description}\relax
plot\_distance\_mean\_by\_group - Barplot Avg. proximity, by group
Shows proximity to sites, for each demographic group (relative to everyone else)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plot_distance_mean_by_group(
  results_bybg_people,
  demogvarname = NULL,
  demoglabel = NULL,
  graph = TRUE,
  returnwhat = "table"
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{results\_bybg\_people}] data.table from doaggregate()\$results\_bybg\_people

\item[\code{demogvarname}] vector of column names like "pctlowinc" etc.

\item[\code{demoglabel}] vector of labels like "Low Income Residents" etc.

\item[\code{returnwhat}] If returnwhat is "table", invisibly returns a
data.frame with group, ratio, avg\_distance\_for\_group, avg\_distance\_for\_nongroup.
If returnwhat is "plotfilename" then it returns the full path including filename of a .png in a tempdir
If returnwhat is "plot" then it returns the plot object as needed for table\_xls\_format() ?
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Note that the ratio shown is a ratio of distance among others to distance of a given group,
so values below 1 mean the given demographic group lives closer to facilities.
A value of 0.85 would mean the group is only 85\% as far from a site as everyone else.

Note it is in miles assuming input was in miles, and the distance for each resident is
actually the average distance of all residents within their Census block (not block group),
and when a site is very close to the block internal point (like a centroid)
relative to the size of the block, the distance to the average resident in the block is
estimated as 90 percent of the effective radius, which is what the radius of the block
would be if it were the same area in square meters or miles but circular in shape.
This is the approach used in EJScreen to estimate average proximity of a block resident in
cases where the block is extremely close to the site or the site may actually be inside the block,
or exactly on top of the internal point of the block, in which case zero would not be an
appropriate estimate of the distance, hence this adjustment is made in EJAM getblocksnearby()
\end{Details}
%
\begin{Value}
see parameter returnwhat
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{distance\_by\_group()}{distance.Rul.by.Rul.group}}

\code{\LinkA{distance\_by\_group\_plot()}{distance.Rul.by.Rul.group.Rul.plot}}  \code{\LinkA{plot\_distance\_cdf\_by\_group()}{plot.Rul.distance.Rul.cdf.Rul.by.Rul.group}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
 y <- ejamit(testpoints_100, radius = 3)
 plot_distance_mean_by_group(y$results_bybg_people) # or distance_mean_by_group() synonym
 print(distance_by_group(y$results_bybg_people, 
   demogvarname = 'pctlowinc', demoglabel = 'Low Income'))
 distance_by_group_plot(y$results_bybg_people, 
   demogvarname = 'pctlowinc', demoglabel = 'Low Income')
 xyz = plot_distance_cdf_by_group(y$results_bybg_people) #  
 tail(round(xyz,3))
 tail(xyz[xyz$pctwa <= 0.501, ]) #  Median distance to nearest site here 
   for White Alone is 2.15 miles, but >60% of Black Alone have a site that close.
 tail(xyz[xyz$pctba <= 0.501, ]) #  Median distance to nearest site here 
   for Black Alone is 1.85 miles
 round(tail(xyz[xyz$dist <=1, ]), 3) #  11% of White have a site within 1 mile, 
   compared to 18.7% of Asian who do.
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{popshare\_at\_top\_n}{popshare\_at\_top\_n  - top N sites account for what percent of residents? What fraction of total population is accounted for by the top N places?}{popshare.Rul.at.Rul.top.Rul.n}
%
\begin{Description}\relax
popshare\_at\_top\_n  - top N sites account for what percent of residents?
What fraction of total population is accounted for by the top N places?
\end{Description}
%
\begin{Usage}
\begin{verbatim}
popshare_at_top_n(pop, n = 10, astext = FALSE, dig = 0)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{pop}] vector of population totals across places,
like out\$results\_bysite\$pop where out is the output of ejamit()

\item[\code{n}] the number of places to consider

\item[\code{astext}] if TRUE, return text of description of results

\item[\code{dig}] rounding digits for text output
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A fraction of 1
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
 x <- testdata_ejamit_output_100pts_1miles$results_bysite
 popshare_p_lives_at_what_pct(x$pop, p = 0.50, astext=TRUE)
 popshare_p_lives_at_what_n(  x$pop, p = c(0.50, 0.67, 0.80, 0.95))
 popshare_at_top_x_pct(       x$pop, x = c(0.25, 0.50, .90))
 popshare_at_top_n(           x$pop, n = c(1, 5, 10))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{popshare\_at\_top\_x\_pct}{popshare\_at\_top\_x\_pct  - top X percent of sites account for what percent of residents? What fraction of total population is accounted for by the top X percent of places?}{popshare.Rul.at.Rul.top.Rul.x.Rul.pct}
%
\begin{Description}\relax
popshare\_at\_top\_x\_pct  - top X percent of sites account for what percent of residents?
What fraction of total population is accounted for by the top X percent of places?
\end{Description}
%
\begin{Usage}
\begin{verbatim}
popshare_at_top_x_pct(pop, x = 0.2, astext = FALSE, dig = 0)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{pop}] vector of population totals across places,
like out\$results\_bysite\$pop where out is the output of ejamit()

\item[\code{x}] a fraction of 1, the share of all places (or a vector of values)

\item[\code{astext}] if TRUE, return text of description of results

\item[\code{dig}] rounding digits for text output
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A fraction of 1 (or a vector of results) or text
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
 x <- testdata_ejamit_output_100pts_1miles$results_bysite
 popshare_p_lives_at_what_pct(x$pop, p = 0.50, astext=TRUE)
 popshare_p_lives_at_what_n(  x$pop, p = c(0.50, 0.67, 0.80, 0.95))
 popshare_at_top_x_pct(       x$pop, x = c(0.25, 0.50, .90))
 popshare_at_top_n(           x$pop, n = c(1, 5, 10))
 
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{popshare\_p\_lives\_at\_what\_n}{popshare\_p\_lives\_at\_what\_n  - how many sites account for P percent of residents?}{popshare.Rul.p.Rul.lives.Rul.at.Rul.what.Rul.n}
%
\begin{Description}\relax
popshare\_p\_lives\_at\_what\_n  - how many sites account for P percent of residents?
\end{Description}
%
\begin{Usage}
\begin{verbatim}
popshare_p_lives_at_what_n(pop, p, astext = FALSE, dig = 0)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{pop}] vector of population totals across places,
like out\$results\_bysite\$pop where out is the output of ejamit()

\item[\code{p}] share of population (0-1, fraction), vector of one or more

\item[\code{astext}] if TRUE, return text of description of results

\item[\code{dig}] rounding digits for text output
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector of numbers of sites, or text about that
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
 x <- testdata_ejamit_output_100pts_1miles$results_bysite
 popshare_p_lives_at_what_pct(x$pop, p = 0.50, astext=TRUE)
 popshare_p_lives_at_what_n(  x$pop, p = c(0.50, 0.67, 0.80, 0.95))
 popshare_at_top_x_pct(       x$pop, x = c(0.25, 0.50, .90))
 popshare_at_top_n(           x$pop, n = c(1, 5, 10))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{popshare\_p\_lives\_at\_what\_pct}{popshare\_p\_lives\_at\_what\_pct  - what percent of sites account for P percent of residents?}{popshare.Rul.p.Rul.lives.Rul.at.Rul.what.Rul.pct}
%
\begin{Description}\relax
popshare\_p\_lives\_at\_what\_pct  - what percent of sites account for P percent of residents?
\end{Description}
%
\begin{Usage}
\begin{verbatim}
popshare_p_lives_at_what_pct(pop, p, astext = FALSE, dig = 0)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{pop}] vector of population totals across places,
like out\$results\_bysite\$pop where out is the output of ejamit()

\item[\code{p}] share of population (0-1, fraction), vector of one or more

\item[\code{astext}] if TRUE, return text of description of results

\item[\code{dig}] rounding digits for text output
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector of fractions 0-1 of all sites, or text about that
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
 x <- testdata_ejamit_output_100pts_1miles$results_bysite
 popshare_p_lives_at_what_pct(x$pop, p = 0.50, astext=TRUE)
 popshare_p_lives_at_what_n(  x$pop, p = c(0.50, 0.67, 0.80, 0.95))
 popshare_at_top_x_pct(       x$pop, x = c(0.25, 0.50, .90))
 popshare_at_top_n(           x$pop, n = c(1, 5, 10))
 
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{popup\_from\_any}{popup\_from\_any - Simple map popup from a data.table or data.frame, one point per row Creates popup vector that leaflet::addCircles or leaflet::addPopups can use. Works similarly to EJAMejscreenapi::popup\_from\_df, but now extends to data.table}{popup.Rul.from.Rul.any}
%
\begin{Description}\relax
popup\_from\_any - Simple map popup from a data.table or data.frame, one point per row
Creates popup vector that leaflet::addCircles or leaflet::addPopups can use.
Works similarly to EJAMejscreenapi::popup\_from\_df, but now extends to data.table
\end{Description}
%
\begin{Usage}
\begin{verbatim}
popup_from_any(
  x,
  column_names = names(x),
  labels = column_names,
  n = "all",
  testing = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x, }] a data table or data frame

\item[\code{column\_names}] default is all, or a vector of column names from x to use.
If some of column\_names requested are not found in names(x),
a warning is given and NA values returned for those names not in x.
If some of names(x) not requested by column\_names, they are left out.

\item[\code{labels}] default is column\_names - vector used to label
the elements in the popup. Must be same length as column\_names

\item[\code{n}] Show the first n columns of mypoints, in popup. "all" means all of them.

\item[\code{testing}] can set to TRUE while testing function
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Each popup is made from one row of the data.frame.
Each popup has one row of text per column of the data.frame
\end{Details}
%
\begin{Value}
A vector of strings, one per row or map point,
with a line break separating column elements
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
 
 dat <- data.table(
   RegistryId = c("110071102551", "110015787683"),
   FacilityName = c("USDOI FWS AK MARITIME NWR etc", "ADAK POWER PLANT"),
   LocationAddress = c("65 MI W. OF ADAK NAVAL FACILITY", "100 HILLSIDE BLVD"),
   CityName = c("ADAK", "ADAK"),
   CountyName = c("ALEUTIAN ISLANDS", "ALEUTIANS WEST"),
   StateAbbr = c("AK", "AK"),
   ZipCode = c("99546", "99546"),
   FIPSCode = c("02010", "02016"),
   lat = c(51.671389,51.8703), lon = c(-178.051111, -176.659),
   SupplementalLocation = c(NA_character_,NA_character_))
 
 ## add popups only
 leaflet::leaflet(dat) |> leaflet::addTiles() |> leaflet::addPopups(popup = popup_from_any(dat))
 
 ## add circles with clickable popups
 leaflet::leaflet(dat) |> leaflet::addTiles() |> leaflet::addCircles(popup = popup_from_any(dat))
 
 ## convert to data frame, works the same way 
 dat_df <- as.data.frame(dat_df)
 leaflet::leaflet(dat) |> leaflet::addTiles() |> leaflet::addCircles(popup = popup_from_any(dat))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{proximity.score.in.miles}{proximity.score.in.miles - convert EJScreen proximity scores to miles per site instead of sites per kilometer Shows US percentiles if no arguments used}{proximity.score.in.miles}
%
\begin{Description}\relax
proximity.score.in.miles - convert EJScreen proximity scores to miles per site instead of sites per kilometer
Shows US percentiles if no arguments used
\end{Description}
%
\begin{Usage}
\begin{verbatim}
proximity.score.in.miles(scoresdf = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{scoresdf}] data.frame of simple proximity scores like for tsdf, rmp, npl
but not traffic.score or npdes one since those are weighted and not just count per km
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{proxistat2}{proxistat2 - Calculate a proximity score for every blockgroup - WORK IN PROGRESS Indicator of proximity of each blockgroups to some set of facilities or sites.}{proxistat2}
%
\begin{Description}\relax
proxistat2 - Calculate a proximity score for every blockgroup - WORK IN PROGRESS
Indicator of proximity of each blockgroups to some set of facilities or sites.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
proxistat2(pts, radius = 8.04672, quadtree)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{pts}] data.table of lat lon

\item[\code{radius}] distance max, in miles, default is 5km (8.04672 miles)
which is the EJScreen max search range for proximity scores

\item[\code{quadtree}] must be called localtree, an index of block locations,
built during use of EJAM package. see \LinkA{quaddata}{quaddata}
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Proximity score is sum of (1/d) where each d is distance of a given site in km,
summed over all sites within 5km, as in EJScreen.

doaggregate() has a bit of code in it to do this same thing that this function does.

*** Still need area of each block to fix this function -
the block area should get put into one of these:
\LinkA{blockpoints}{blockpoints} or \LinkA{blockwts}{blockwts}
\end{Details}
%
\begin{Value}
data.table with proximityscore, bgfips, lat, lon, etc.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
 # pts <- testpoints_100
 # x <- proxistat2(pts = pts[1:1000,], quadtree = localtree) 
 #
 # summary(x$proximityscore)
 # # analyze.stuff   pctiles(x$proximityscore)
 # plot(x = x$lon, y = x$lat)
 # tops = x$proximityscore > 500 & !is.infinite(x$proximityscore) & !is.na(x$proximityscore)
 # points(x = x$lon[tops], y = x$lat[tops], col="red")
 
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{quaddata}{quaddata (DATA) data.table used to create index of all US block point locations}{quaddata}
%
\begin{Description}\relax
quaddata (DATA) data.table used to create index of all US block point locations
\end{Description}
%
\begin{Details}\relax
8,174,955 rows when non-populated blocks are kept.
5,806,512 rows have Census 2020 population (and blockwt) > 0.
This is the largest file used by the package, and is 168 MB as a file, for 2020 Census.
- blockid
- BLOCK\_X, BLOCK\_Y, BLOCK\_Z  (not lat, lon)

\begin{alltt}localtree is the index made from quaddata  
(QuadTree class, via SearchTrees pkg), not a data.table
\end{alltt}

\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{indexblocks()}{indexblocks}} \LinkA{EJAM}{EJAM}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{radius\_inferred}{radius\_inferred - utility to estimate original radius requested in getblocksnearby() if we only have the outputs of getblocksnearby()}{radius.Rul.inferred}
%
\begin{Description}\relax
radius\_inferred - utility to estimate original radius requested in getblocksnearby()
if we only have the outputs of getblocksnearby()
\end{Description}
%
\begin{Usage}
\begin{verbatim}
radius_inferred(
  s2b = NULL,
  decimalsreported = 2,
  decimalsforinferring = 3,
  pctile_of_sites = 0.9,
  nth_furthest_block = 2
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{s2b}] data.table of siteid, distance, etc. that is the output of getblocksnearby()

\item[\code{decimalsreported}] parameter to fine tune estimates - generally should not be changed

\item[\code{decimalsforinferring}] parameter to fine tune estimates - generally should not be changed

\item[\code{pctile\_of\_sites}] parameter to fine tune estimates - generally should not be changed

\item[\code{nth\_furthest\_block}] parameter to fine tune estimates - generally should not be changed
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
There are some cases where someone using EJAM functions like getblocksnearby()
might in a later separate step use the results of getblocksnearby() to summarize
indicator values using a function like doaggregate(), and the actual radius originally
requested is not known.

This function tries to approximate what radius must have been requested for analysis,
looking at the sites2blocks information about distances to all nearby blocks
near each of the analyzed sites. It is not as simple as using the max distance over all sites,
because at some sites getblocksnearby() reports one or two distances larger than
radius requested, even if avoidorphans is FALSE. That must be because the
reported distance is adjusted when it is small relative to the whole block, to
better estimate distance to average resident in the block rather than reporting
distance to the point that is the block internal point (centroid essentially).
As documented in the EJScreen information about creating proximity scores,
a facility exactly on top of the block internal point has distance zero to the point but
that is not the actual distance to the average resident in the block, hence the adjustment.
Some blocks in low density areas are huge so a relatively small circular buffer (small radius)
will require adjustments more often. If the block is 3 miles in radius but someone wants a
radius of 1 mile in getblocksnearby() or ejamit() analysis overall, a site inside the block
might be reported as having a distance of 2.7 miles because the average resident in the block
is estimated to be 2.7 miles away from any site in the block. Almost 2\% of US blocks are
affected by this issue for a selected radius of 1 mile, but only 1 in 1,000 are for a radius of 3 miles.

This function is based largely on a practical algorithm that is accurate to within 0.01 miles
the vast majority of the time for a radius of 1 to 3 miles.
\end{Details}
%
\begin{Value}
a single number such as 1.5 or 3 that is the estimate of the miles distance that was
originally requested in getblocksnearby()
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
 radius_inferred()
  # radius_inferred(getblocksnearby(testpoints_n(100), radius = 3.25))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{regionstats}{regionstats (DATA) (obsolete) data.table of 100 percentiles and means for each EPA Region.}{regionstats}
%
\begin{Description}\relax
data.table of 100 percentiles and means for each EPA Region (> 1,000 rows)
for all the block groups in that zone (e.g., block groups in \LinkA{blockgroupstats}{blockgroupstats})
for a set of indicators such as percent low income.
Each column is one indicator (or specifies the percentile).

This should be similar to the lookup tables in the gdb on the FTP site of EJScreen.
\end{Description}
\inputencoding{utf8}
\HeaderA{rmost}{rmost - utility to rm(list=ls()) but not remove key datasets EJAM uses}{rmost}
%
\begin{Description}\relax
rmost - utility to rm(list=ls()) but not remove key datasets EJAM uses
\end{Description}
%
\begin{Usage}
\begin{verbatim}
rmost(
  notremove = c("rmost", "localtree", "blockgroupstats", "usastats", "statestats",
    "bgid2fips", "blockid2fips", "blockpoints", "blockwts", "quaddata", "bgej")
)
\end{verbatim}
\end{Usage}
\inputencoding{utf8}
\HeaderA{run\_app}{run\_app - Launch the Shiny Application in RStudio}{run.Rul.app}
%
\begin{Description}\relax
launch Shiny web app from RStudio
\end{Description}
%
\begin{Usage}
\begin{verbatim}
run_app(
  onStart = NULL,
  options = list(),
  enableBookmarking = "server",
  uiPattern = "/",
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{onStart}] A function that will be called before the app is actually run.
This is only needed for \code{shinyAppObj}, since in the \code{shinyAppDir}
case, a \code{global.R} file can be used for this purpose.

\item[\code{options}] Named options that should be passed to the \code{runApp} call
(these can be any of the following: "port", "launch.browser", "host", "quiet",
"display.mode" and "test.mode"). You can also specify \code{width} and
\code{height} parameters which provide a hint to the embedding environment
about the ideal height/width for the app.

\item[\code{enableBookmarking}] Can be one of \code{"url"}, \code{"server"}, or
\code{"disable"}. The default value, \code{NULL}, will respect the setting from
any previous calls to  \code{\LinkA{enableBookmarking()}{enableBookmarking()}}. See \code{\LinkA{enableBookmarking()}{enableBookmarking()}}
for more information on bookmarking your app.

\item[\code{uiPattern}] A regular expression that will be applied to each \code{GET}
request to determine whether the \code{ui} should be used to handle the
request. Note that the entire request path must match the regular
expression in order for the match to be considered successful.

\item[\code{...}] arguments to pass to golem\_opts. Maybe could be something like sitepoints="latlondata.xlsx" or sitepoints=\LinkA{testpoints\_100}{testpoints.Rul.100}
See \code{?golem::get\_golem\_options} for more details.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
app\_run\_EJAM()                 is like \code{\LinkA{run\_app()}{run.Rul.app}} from the EJAM package
\end{Details}
\inputencoding{utf8}
\HeaderA{setdiff2}{setdiff2 aka unshared - UTILITY - see what is only in x or y but not both utility just like setdiff except for y,x and also x,y Just shows which elements are in one and only one of the sets x and y}{setdiff2}
%
\begin{Description}\relax
setdiff2 aka unshared - UTILITY - see what is only in x or y but not both
utility just like setdiff except for y,x and also x,y
Just shows which elements are in one and only one of the sets x and y
\end{Description}
%
\begin{Usage}
\begin{verbatim}
setdiff2(x, y)
\end{verbatim}
\end{Usage}
\inputencoding{utf8}
\HeaderA{setdiff\_yx}{setdiff\_yx - UTILITY - see what is in y not x utility just like setdiff except for y,x instead of x,y}{setdiff.Rul.yx}
%
\begin{Description}\relax
setdiff\_yx - UTILITY - see what is in y not x
utility just like setdiff except for y,x instead of x,y
\end{Description}
%
\begin{Usage}
\begin{verbatim}
setdiff_yx(x, y)
\end{verbatim}
\end{Usage}
\inputencoding{utf8}
\HeaderA{shapefile\_clean}{shapefile\_clean  -  drop invalid rows and warn if all invalid}{shapefile.Rul.clean}
%
\begin{Description}\relax
shapefile\_clean  -  drop invalid rows and warn if all invalid
\end{Description}
%
\begin{Usage}
\begin{verbatim}
shapefile_clean(shp, crs = 4269)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{shp}] a shapefile object using sf::read\_sf()

\item[\code{crs}] used in shp <- sf::st\_transform(shp, crs = crs), default is crs = 4269 or Geodetic CRS NAD83
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a shapefile object using sf::read\_sf()
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{shapefile\_from\_folder()}{shapefile.Rul.from.Rul.folder}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{shapefile\_filepaths\_from\_folder}{shapefile\_filepaths\_from\_folder  -  get list of valid filenames comprising shapefile including paths}{shapefile.Rul.filepaths.Rul.from.Rul.folder}
%
\begin{Description}\relax
shapefile\_filepaths\_from\_folder  -  get list of valid filenames comprising shapefile including paths
\end{Description}
%
\begin{Usage}
\begin{verbatim}
shapefile_filepaths_from_folder(folder = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{folder}] path of folder that contains the files (.shp, .shx, .dbf, and .prj)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
string vector of filenames including full paths
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{shapefile\_from\_folder()}{shapefile.Rul.from.Rul.folder}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{shapefile\_filepaths\_valid}{shapefile\_filepaths\_valid  -  confirm files have all the extensions .shp, .shx, .dbf, and .prj}{shapefile.Rul.filepaths.Rul.valid}
%
\begin{Description}\relax
shapefile\_filepaths\_valid  -  confirm files have all the extensions .shp, .shx, .dbf, and .prj
\end{Description}
%
\begin{Usage}
\begin{verbatim}
shapefile_filepaths_valid(filepaths)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{filepaths}] vector of full paths with filenames (types .shp, .shx, .dbf, and .prj) as strings
\end{ldescription}
\end{Arguments}
%
\begin{Value}
logical, indicating if all 4 extensions are found among the filepaths
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{shapefile\_from\_folder()}{shapefile.Rul.from.Rul.folder}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{shapefile\_from\_filepaths}{shapefile\_from\_filepaths  -  Read shapefile from disk based on the filenames given}{shapefile.Rul.from.Rul.filepaths}
%
\begin{Description}\relax
shapefile\_from\_filepaths  -  Read shapefile from disk based on the filenames given
\end{Description}
%
\begin{Usage}
\begin{verbatim}
shapefile_from_filepaths(filepaths = NULL, cleanit = TRUE, crs = 4269)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{filepaths}] vector of full paths with filenames (types .shp, .shx, .dbf, and .prj) as strings

\item[\code{cleanit}] set to FALSE if you want to skip validation and dropping invalid rows

\item[\code{crs}] if cleanit = TRUE, crs is passed to shapefile\_clean()
default is crs = 4269 or Geodetic CRS NAD83
Also can check this via x <- sf::st\_crs(sf::read\_sf()); x\$input
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a shapefile object using sf::read\_sf()
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{shapefile\_from\_folder()}{shapefile.Rul.from.Rul.folder}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{shapefile\_from\_folder}{shapefile\_from\_folder  -  read shapefile from a folder}{shapefile.Rul.from.Rul.folder}
%
\begin{Description}\relax
shapefile\_from\_folder  -  read shapefile from a folder
\end{Description}
%
\begin{Usage}
\begin{verbatim}
shapefile_from_folder(folder = NULL, cleanit = TRUE, crs = 4269)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{folder}] path of folder that contains the files (.shp, .shx, .dbf, and .prj)

\item[\code{cleanit}] set to FALSE if you want to skip validation and dropping invalid rows

\item[\code{crs}] passed to shapefile\_from\_filepaths() default is crs = 4269 or Geodetic CRS NAD83
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a shapefile object using sf::read\_sf()
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
  testfolder <- system.file("testdata/shapes/Portland_neighborhoods", package = "EJAM")
  testshape <- shapefile_from_folder(testfolder)
  
  testpaths <- shapefile_filepaths_from_folder(testfolder)
  testshape <- shapefile_from_filepaths(testpaths)
  
  ## if interactive(), R user can point to right folder or select the right set of files:
  # testshape <- shapefile_from_filepaths()
  # testshape <- shapefile_from_folder()
  
  x <- get_blockpoints_in_shape(testshape)
  leaflet(x$polys) %>% addTiles() %>% addPolygons(color = "blue")
  DT::datatable(out$results_bysite)
  
  
## End(Not run)
  
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{shapefile\_from\_sitepoints}{shapefile\_from\_sitepoints - convert table of lat,lon points/sites into sf:: shapefile Creates a simple feature (sf) dataframe from points}{shapefile.Rul.from.Rul.sitepoints}
%
\begin{Description}\relax
shapefile\_from\_sitepoints - convert table of lat,lon points/sites into sf:: shapefile
Creates a simple feature (sf) dataframe from points
\end{Description}
%
\begin{Usage}
\begin{verbatim}
shapefile_from_sitepoints(sitepoints, crs = 4269)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{sitepoints}] a data.table or data.frame with columns called lat,lon

\item[\code{crs}] used in st\_as\_sf() default is crs = 4269 or Geodetic CRS NAD83
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A shapefile via \code{\LinkA{sf::st\_as\_sf()}{sf::st.Rul.as.Rul.sf()}}
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{get\_blockpoints\_in\_shape()}{get.Rul.blockpoints.Rul.in.Rul.shape}} \code{\LinkA{shapefile\_from\_sitepoints()}{shapefile.Rul.from.Rul.sitepoints}} \code{\LinkA{shape\_buffered\_from\_shapefile\_points()}{shape.Rul.buffered.Rul.from.Rul.shapefile.Rul.points}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{shapes\_blockgroups\_from\_bgfips}{use API to get boundaries of blockgroups}{shapes.Rul.blockgroups.Rul.from.Rul.bgfips}
%
\begin{Description}\relax
use API to get boundaries of blockgroups
\end{Description}
%
\begin{Usage}
\begin{verbatim}
shapes_blockgroups_from_bgfips(
  bgfips = "010890029222",
  outFields = "",
  myservice =
    c("https://services.arcgis.com/P3ePLMYs2RVChkJx/ArcGIS/rest/services/USA_Boundaries_2022/FeatureServer/5/query",
    "https://services.arcgis.com/P3ePLMYs2RVChkJx/ArcGIS/rest/services/USA_Block_Groups/FeatureServer/0/query",
    "https://services.arcgis.com/cJ9YHowT8TU7DUyn/ArcGIS/rest/services/EJScreen_2_21_US_Percentiles_Block_Groups/FeatureServer/0/query")[1]
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{bgfips}] one or more block group FIPS codes as 12-character strings in a vector

\item[\code{outFields}] can be "*" for all, or can be
just some variables like SQMI, POPULATION\_2020, etc., or none

\item[\code{myservice}] URL of feature service to get shapes from.

"https://services.arcgis.com/cJ9YHowT8TU7DUyn/ArcGIS/rest/services/
EJScreen\_2\_21\_US\_Percentiles\_Block\_Groups/FeatureServer/0/query"

for example provides EJScreen indicator values, NPL\_CNT, TSDF\_CNT, EXCEED\_COUNT\_90, etc.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This is useful mostly for small numbers of blockgroups.
The EJScreen map services provide other ways to map blockgroups and see EJScreen data.
\end{Details}
%
\begin{Value}
spatial object via sf::read\_sf()
\end{Value}
\inputencoding{utf8}
\HeaderA{shapes\_counties\_from\_countyfips}{use API to get boundaries of US Counties to map them}{shapes.Rul.counties.Rul.from.Rul.countyfips}
%
\begin{Description}\relax
use API to get boundaries of US Counties to map them
\end{Description}
%
\begin{Usage}
\begin{verbatim}
shapes_counties_from_countyfips(
  countyfips = "10001",
  outFields = "",
  myservice =
    c("https://services.arcgis.com/P3ePLMYs2RVChkJx/ArcGIS/rest/services/USA_Boundaries_2022/FeatureServer/2/query",
    "https://services.arcgis.com/P3ePLMYs2RVChkJx/ArcGIS/rest/services/USA_Counties_and_States_with_PR/FeatureServer/0/query",
    "https://services.arcgis.com/cJ9YHowT8TU7DUyn/ArcGIS/rest/services/EJScreen_2_22_US_Percentiles_Tracts/FeatureServer/query")[1]
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{countyfips}] FIPS codes as 5-character strings (or numbers) in a vector

\item[\code{outFields}] can be "*" for all, or can be
just some variables like SQMI, POPULATION\_2020, etc., or none

\item[\code{myservice}] URL of feature service to get shapes from.
Only default was tested
\end{ldescription}
\end{Arguments}
%
\begin{Value}
spatial object via sf::read\_sf()
\end{Value}
\inputencoding{utf8}
\HeaderA{shape\_buffered\_from\_shapefile}{shape\_buffered\_from\_shapefile - add buffer around shape}{shape.Rul.buffered.Rul.from.Rul.shapefile}
%
\begin{Description}\relax
shape\_buffered\_from\_shapefile - add buffer around shape
\end{Description}
%
\begin{Usage}
\begin{verbatim}
shape_buffered_from_shapefile(shapefile, radius.miles, crs = 4269, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{shapefile}] spatial object like areas at high risk or areas with facilities to be analyzed

\item[\code{radius.miles}] width of buffer to add to shapefile
(in case dist is a units object, it should be
convertible to arc\_degree if x has geographic coordinates,
and to st\_crs(x)\$units otherwise)

\item[\code{crs}] used in st\_transform()  default is crs = 4269 or Geodetic CRS NAD83

\item[\code{...}] passed to st\_buffer()
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Just a wrapper for \code{\LinkA{sf::st\_buffer()}{sf::st.Rul.buffer()}}
\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{get\_blockpoints\_in\_shape()}{get.Rul.blockpoints.Rul.in.Rul.shape}} \code{\LinkA{shapefile\_from\_sitepoints()}{shapefile.Rul.from.Rul.sitepoints}} \LinkA{shape\_buffered\_from\_shapefile\_points}{shape.Rul.buffered.Rul.from.Rul.shapefile.Rul.points}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{shape\_buffered\_from\_shapefile\_points}{shape\_buffered\_from\_shapefile\_points - add buffer around shape (points, here)}{shape.Rul.buffered.Rul.from.Rul.shapefile.Rul.points}
%
\begin{Description}\relax
shape\_buffered\_from\_shapefile\_points - add buffer around shape (points, here)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
shape_buffered_from_shapefile_points(
  shapefile_points,
  radius.miles,
  crs = 4269,
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{shapefile\_points}] spatial object like areas at high risk or areas with facilities to be analyzed

\item[\code{radius.miles}] width of buffer to add to shapefile\_points
(in case dist is a units object, it should be
convertible to arc\_degree if x has geographic coordinates,
and to st\_crs(x)\$units otherwise)

\item[\code{crs}] used in st\_transform()  default is crs = 4269 or Geodetic CRS NAD83

\item[\code{...}] passed to st\_buffer()
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Just a wrapper for \code{\LinkA{sf::st\_buffer()}{sf::st.Rul.buffer()}}
\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{get\_blockpoints\_in\_shape()}{get.Rul.blockpoints.Rul.in.Rul.shape}} \code{\LinkA{shapefile\_from\_sitepoints()}{shapefile.Rul.from.Rul.sitepoints}} \LinkA{shape\_buffered\_from\_shapefile\_points}{shape.Rul.buffered.Rul.from.Rul.shapefile.Rul.points}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{SIC}{SIC (DATA) named list of all SIC code numbers and category name for each}{SIC}
%
\begin{Description}\relax
SIC (DATA) named list of all SIC code numbers and category name for each
\end{Description}
%
\begin{Details}\relax
see \url{https://siccode.com}
\end{Details}
%
\begin{SeeAlso}\relax
\LinkA{SIC}{SIC} \LinkA{sictable}{sictable} \code{\LinkA{sic\_categories()}{sic.Rul.categories}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{sictable}{sictable (DATA) data.table of SIC code(s) and industry names for each EPA-regulated site in Facility Registry Service Also has the 2,3, and 4-digit SIC that this code falls under, where relevant for given length}{sictable}
%
\begin{Description}\relax
This is similar to the data file EJAM::SIC but in a more useful format and newer functions work with it.
\end{Description}
%
\begin{Details}\relax
see \url{https://siccode.com}
\end{Details}
%
\begin{SeeAlso}\relax
\LinkA{SIC}{SIC} \LinkA{sictable}{sictable} \code{\LinkA{sic\_categories()}{sic.Rul.categories}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{sic\_categories}{sic\_categories - See the names of SIC industrial categories and their codes Easy way to view, in RStudio console, the SIC categories. SIC all are 4-digit codes, like 7218 - Industrial launderers}{sic.Rul.categories}
%
\begin{Description}\relax
sic\_categories - See the names of SIC industrial categories and their codes
Easy way to view, in RStudio console, the SIC categories.
SIC all are 4-digit codes, like 7218 - Industrial launderers
\end{Description}
%
\begin{Usage}
\begin{verbatim}
sic_categories()
\end{verbatim}
\end{Usage}
%
\begin{SeeAlso}\relax
\LinkA{SIC}{SIC} \LinkA{naics\_categories}{naics.Rul.categories}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{sic\_from\_any}{sic\_from\_any - General way to search for industry names and NAICS codes Find industry names and codes by searching for queried code(s) or text}{sic.Rul.from.Rul.any}
%
\begin{Description}\relax
sic\_from\_any - General way to search for industry names and NAICS codes
Find industry names and codes by searching for queried code(s) or text
\end{Description}
%
\begin{Usage}
\begin{verbatim}
sic_from_any(
  query,
  children = FALSE,
  ignore.case = TRUE,
  fixed = FALSE,
  website_scrape = FALSE,
  website_url = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{query}] query string(s) and/or number(s), vector of NAICS codes or industry names or any regular expression or partial words

\item[\code{children}] logical, if TRUE, also return all the subcategories - where NAICS starts with the same digits

\item[\code{ignore.case}] see \code{\LinkA{grepl()}{grepl}}

\item[\code{fixed}] should it be an exact match? see \code{\LinkA{grepl()}{grepl}}

\item[\code{website\_scrape}] whether to scrape info from the NAICS website to return a table of codes and names that match (web query uses synonyms so gets more hits)

\item[\code{website\_url}] whether to return the URL of the webpage with info on the NAICS (web query uses synonyms so gets more hits)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a subset of the \LinkA{sictable}{sictable} data.table (not just the codes column)
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{sic\_subcodes\_from\_code()}{sic.Rul.subcodes.Rul.from.Rul.code}} \code{\LinkA{sic\_from\_code()}{sic.Rul.from.Rul.code}}  \code{\LinkA{sic\_from\_name()}{sic.Rul.from.Rul.name}}  \code{\LinkA{sic\_from\_any()}{sic.Rul.from.Rul.any}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{sic\_from\_code}{sic\_from\_code - search for industry names by SIC code(s), 4 digits each}{sic.Rul.from.Rul.code}
%
\begin{Description}\relax
sic\_from\_code - search for industry names by SIC code(s), 4 digits each
\end{Description}
%
\begin{Usage}
\begin{verbatim}
sic_from_code(mycodes, children = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mycodes}] vector of character SIC codes. see \url{https://siccode.com}

\item[\code{children}] logical, if TRUE, also return all the subcategories - where SIC starts with the same digits
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a subset of the \LinkA{sictable}{sictable} data.table (not just the codes column)
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{sic\_subcodes\_from\_code()}{sic.Rul.subcodes.Rul.from.Rul.code}} \code{\LinkA{sic\_from\_code()}{sic.Rul.from.Rul.code}}  \code{\LinkA{sic\_from\_name()}{sic.Rul.from.Rul.name}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{sic\_from\_name}{sic\_from\_name - search for industry names and SIC codes by query string query by parts of words, etc. in the industry name.}{sic.Rul.from.Rul.name}
%
\begin{Description}\relax
sic\_from\_name - search for industry names and SIC codes by query string
query by parts of words, etc. in the industry name.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
sic_from_name(mynames, children = FALSE, ignore.case = TRUE, fixed = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mynames}] query string, vector of SIC industry names or any regular expression or partial words. See \url{https://siccode.com}

\item[\code{children}] logical, if TRUE, also return all the subcategories - where SIC starts with the same digits

\item[\code{ignore.case}] see \code{\LinkA{grepl()}{grepl}}

\item[\code{fixed}] should it be an exact match? see \code{\LinkA{grepl()}{grepl}}
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a subset of the \LinkA{sictable}{sictable} data.table (not just the codes column)
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{sic\_subcodes\_from\_code()}{sic.Rul.subcodes.Rul.from.Rul.code}} \code{\LinkA{sic\_from\_code()}{sic.Rul.from.Rul.code}}  \code{\LinkA{sic\_from\_name()}{sic.Rul.from.Rul.name}}  \code{\LinkA{sic\_from\_any()}{sic.Rul.from.Rul.any}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
 data.table::fintersect(sic_from_any( "glass"), sic_from_any("paint"))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{sic\_subcodes\_from\_code}{sic\_subcodes\_from\_code - find subcategories of the given overall SIC industry code(s) Given 3-digit SIC code, for example, get all SIC that start with those digits.}{sic.Rul.subcodes.Rul.from.Rul.code}
%
\begin{Description}\relax
sic\_subcodes\_from\_code - find subcategories of the given overall SIC industry code(s)
Given 3-digit SIC code, for example, get all SIC that start with those digits.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
sic_subcodes_from_code(mycodes)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mycodes}] SIC codes vector, of 2 to 4 digits each. See \url{https://siccode.com}
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
similar idea was naics2children() but this is more robust
See \code{\LinkA{sic\_from\_any()}{sic.Rul.from.Rul.any}} which uses this
\end{Details}
%
\begin{Value}
a subset of the \LinkA{sictable}{sictable} data.table (not just the codes column)
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{sic\_subcodes\_from\_code()}{sic.Rul.subcodes.Rul.from.Rul.code}} \code{\LinkA{sic\_from\_code()}{sic.Rul.from.Rul.code}}  \code{\LinkA{sic\_from\_name()}{sic.Rul.from.Rul.name}}  \code{\LinkA{sic\_from\_any()}{sic.Rul.from.Rul.any}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
  # codes starting with '07'
  sic_subcodes_from_code('07')
  # codes starting with '078'
  sic_subcodes_from_code('078')
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{siteid\_from\_naics}{latlon\_from\_naics - Find EPA-regulated facilities in FRS by NAICS code (industrial category) Get lat lon, Registry ID, given NAICS industry code(s) Find all EPA Facility Registry Service (FRS) sites with this exact NAICS code (not subcategories)}{siteid.Rul.from.Rul.naics}
%
\begin{Description}\relax
latlon\_from\_naics - Find EPA-regulated facilities in FRS by NAICS code (industrial category)
Get lat lon, Registry ID, given NAICS industry code(s)
Find all EPA Facility Registry Service (FRS) sites with this exact NAICS code (not subcategories)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
siteid_from_naics(naics, id_only = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{naics}] a vector of naics codes, or
a data.table with column named code, as with output of \code{\LinkA{naics\_from\_any()}{naics.Rul.from.Rul.any}}
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
NOTE: many FRS sites lack NAICS code!

Also, this function does not find the sites
identified by FRS data as being in a child NAICS (subcategory of your exact query)!

Relies on  frs\_by\_naics (a data.table)

See info about NAICS industry codes at \url{https://www.naics.com/search}
\end{Details}
%
\begin{Value}
A data.table (not just data.frame) with columns called
lat, lon, REGISTRY\_ID, NAICS (but see the id\_only parameter)
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
  siteid_from_naics(321114)
  latlon_from_naics(321114)
  latlon_from_naics(EJAM::naics_from_any("cheese")[,code] )
  head(latlon_from_naics(c(3366, 33661, 336611), id_only=TRUE))
  # mapfast(frs_from_naics(336611)) # simple map
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{siteid\_from\_sic}{latlon\_from\_sic - Find EPA-regulated facilities in FRS by SIC code (industrial category)}{siteid.Rul.from.Rul.sic}
%
\begin{Description}\relax
Get lat lon, Registry ID, given SIC industry code(s)
Find all EPA Facility Registry Service (FRS) sites with this exact SIC code (not subcategories)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
siteid_from_sic(sic, id_only = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{sic}] a vector of SIC codes, or
a data.table with column named code, as with output of \code{\LinkA{sic\_from\_any()}{sic.Rul.from.Rul.any}}
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
NOTE: many FRS sites lack SIC code!

Also, this function does not find the sites
identified by FRS data as being in a child SIC (subcategory of your exact query)!

Relies on  frs\_by\_sic (a data.table)

See info about SIC industry codes at \url{https://www.naics.com/search}
\end{Details}
%
\begin{Value}
A data.table (not just data.frame) with columns called
lat, lon, REGISTRY\_ID, SIC (but see the id\_only parameter)
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
  siteid_from_sic('7300')
  latlon_from_sic('7300')
  latlon_from_sic(sic_from_any("cheese")[,code] )
  head(latlon_from_sic(c('6150', '6300', '5995'), id_only=TRUE))
  # mapfast(frs_from_sic('6150')) # simple map
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{sites2blocks\_example1000pts\_1miles}{test output of getblocksnearby(), and is an input to doaggregate()}{sites2blocks.Rul.example1000pts.Rul.1miles}
%
\begin{Description}\relax
test output of getblocksnearby(), and is an input to doaggregate()
\end{Description}
%
\begin{Details}\relax
This is the output of getblocksnearby(testpoints\_1000, radius = 1)
This is the same as  \LinkA{testoutput\_getblocksnearby\_1000pts\_1miles}{testoutput.Rul.getblocksnearby.Rul.1000pts.Rul.1miles}
\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{getblocksnearby()}{getblocksnearby}}  \code{\LinkA{doaggregate()}{doaggregate}}  \LinkA{testpoints\_1000}{testpoints.Rul.1000}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{sites2blocks\_example100pts\_1miles}{test output of getblocksnearby(), and is an input to doaggregate()}{sites2blocks.Rul.example100pts.Rul.1miles}
%
\begin{Description}\relax
test output of getblocksnearby(), and is an input to doaggregate()
\end{Description}
%
\begin{Details}\relax
This is the output of getblocksnearby(testpoints\_100, radius = 1)
This is the same as  \LinkA{testoutput\_getblocksnearby\_100pts\_1miles}{testoutput.Rul.getblocksnearby.Rul.100pts.Rul.1miles}
\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{getblocksnearby()}{getblocksnearby}}  \code{\LinkA{doaggregate()}{doaggregate}}  \LinkA{testpoints\_100}{testpoints.Rul.100}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{sites2blocks\_example10pts\_1miles}{test output of getblocksnearby(), and is an input to doaggregate()}{sites2blocks.Rul.example10pts.Rul.1miles}
%
\begin{Description}\relax
test output of getblocksnearby(), and is an input to doaggregate()
\end{Description}
%
\begin{Details}\relax
This is the output of getblocksnearby(testpoints\_10, radius = 1)
This is the same as  \LinkA{testoutput\_getblocksnearby\_10pts\_1miles}{testoutput.Rul.getblocksnearby.Rul.10pts.Rul.1miles}
\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{getblocksnearby()}{getblocksnearby}}  \code{\LinkA{doaggregate()}{doaggregate}}  \LinkA{testpoints\_10}{testpoints.Rul.10}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{speedtable\_expand}{speedtable\_expand Utility used by speedtest() and speedtable\_summarize()}{speedtable.Rul.expand}
%
\begin{Description}\relax
speedtable\_expand
Utility used by speedtest() and speedtable\_summarize()
\end{Description}
%
\begin{Usage}
\begin{verbatim}
speedtable_expand(speedtable)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{speedtable}] must have columns called  points, miles, and perhr
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{speedtable\_summarize}{speedtable\_summarize utility used by speedtest()}{speedtable.Rul.summarize}
%
\begin{Description}\relax
speedtable\_summarize
utility used by speedtest()
\end{Description}
%
\begin{Usage}
\begin{verbatim}
speedtable_summarize(speedtable)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{speedtable}] from speedtest(), with columns named points and perhr
\end{ldescription}
\end{Arguments}
%
\begin{SeeAlso}\relax
\code{\LinkA{speedtest()}{speedtest}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{speedtest}{speedtest Run EJAM analysis for several radii and numbers of sitepoints, recording how long each step takes}{speedtest}
%
\begin{Description}\relax
speedtest
Run EJAM analysis for several radii and numbers of sitepoints,
recording how long each step takes
\end{Description}
%
\begin{Usage}
\begin{verbatim}
speedtest(
  n = 10,
  sitepoints = NULL,
  weighting = "frs",
  radii = c(1, 3.106856, 5, 10, 31.06856)[1:3],
  avoidorphans = FALSE,
  test_ejamit = FALSE,
  test_getblocksnearby = TRUE,
  test_doaggregate = TRUE,
  test_batch.summarize = FALSE,
  logging = FALSE,
  logfolder = getwd(),
  logfilename = "log_n_datetime.txt",
  honk_when_ready = TRUE,
  saveoutput = FALSE,
  plot = TRUE,
  getblocks_diagnostics_shown = FALSE,
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{n}] optional, vector of 1 or more counts of how many random points to test, or
set to 0 to interactively pick file of points in RStudio (n is ignored if sitepoints provided)

\item[\code{sitepoints}] optional,  (use if you do not want random points) data.frame of points or
path/file with points, where columns are lat and lon in decimal degrees

\item[\code{weighting}] optional, if using random points, how to weight them,
such as facilities, people, or blockgroups. see \code{\LinkA{testpoints\_n()}{testpoints.Rul.n}}

\item[\code{radii}] optional, one or more radius values in miles
to use in creating circular buffers when findings residents nearby each of sitepoints.
The default list includes one that is 5km (approx 3.1 miles)

\item[\code{avoidorphans}] see \code{\LinkA{getblocksnearby()}{getblocksnearby}} or \code{\LinkA{ejamit()}{ejamit}} regarding this param

\item[\code{test\_ejamit}] whether to test only ejamit()
instead of its subcomponents like getblocksnearby(), doaggregate(), etc

\item[\code{test\_getblocksnearby}] whether to include this function in timing - not used because always done

\item[\code{test\_doaggregate}] whether to include this function in timing

\item[\code{test\_batch.summarize}] whether to include this function in timing

\item[\code{logging}] logical optional, whether to save log file with timings of steps.
NOTE this slows it down though.

\item[\code{logfolder}] optional, name of folder for log file

\item[\code{logfilename}] optional, name of log file to go in folder

\item[\code{honk\_when\_ready}] optional, self-explanatory

\item[\code{saveoutput}] but this slows it down if set to TRUE to save each run as .rda file

\item[\code{plot}] whether to create plot of results

\item[\code{getblocks\_diagnostics\_shown}] set TRUE to see more details on block counts etc.

\item[\code{...}] passed to plotting function
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This is essentially a test script that times each step of EJAM for a large dataset
\begin{itemize}

\item{} pick a sample size (n) (or enter sitepoints, or set n=0 to interactively pick file of points in RStudio)
\item{} pick n random points
\item{} pick a few different radii for circular buffering
\item{} analyze indicators in circular buffers and overall (find blocks nearby and then calc indicators)
\item{} get stats that summarize those indicators
\item{} compare times between steps and radii and other approaches or tools

\end{itemize}

\end{Details}
%
\begin{Value}
EJAM results similar to as from the web app or \code{\LinkA{ejamit()}{ejamit}} and also creates a plot
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{speedtest\_plot()}{speedtest.Rul.plot}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run:  
  speedseen_few <- speedtest(c(50,500), radii=c(1, 3.106856), logging=FALSE, honk=FALSE)
  
  speedseen_nearer_to1k <- speedtest(n = c(1e2,1e3,1e4 ), radii=c(1, 3.106856,5 ),
    logging=TRUE, honk=FALSE)
  save( speedseen_nearer_to1k, file = "~/../Downloads/speedseen_nearer_to1k.rda")
  rstudioapi::savePlotAsImage(        "~/../Downloads/speedseen_nearer_to1k.png")
  
  speedseen_all <- speedtest(
    n = c(1e2,1e3,1e4), 
    radii=c(1, 3.106856, 5, 10, 31.06856), 
    logging=TRUE, honk=TRUE
  )
 
## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{speedtest\_plot}{speedtest\_plot utility to plot output of speedtest(), rate of points analyzed per hour}{speedtest.Rul.plot}
%
\begin{Description}\relax
speedtest\_plot
utility to plot output of speedtest(), rate of points analyzed per hour
\end{Description}
%
\begin{Usage}
\begin{verbatim}
speedtest_plot(x, ltype = "b", plotfile = NULL, secondsperthousand = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] table from speedtest()

\item[\code{ltype}] optional type of line for plot

\item[\code{plotfile}] optional path and filename of .png image file to save
\end{ldescription}
\end{Arguments}
%
\begin{Value}
side effect is a plot. returns x but with seconds column added to it
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{speedtest()}{speedtest}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{stateinfo}{stateinfo (DATA) data.frame of state abbreviations and state names (50+DC+PR; not AS, GU, MP, VI, UM)}{stateinfo}
%
\begin{Description}\relax
52 rows and a few variables: ST is the 2-letter abbreviation,
statename is the State name, etc.
\end{Description}
%
\begin{Details}\relax
Created for EJAM by datacreate\_stateinfo.R script

Also see \url{https://www.census.gov/programs-surveys/decennial-census/decade/2020/planning-management/release/2020-island-areas-data-products.html}

column names: "ST"  "statename"  "ftpname"   "FIPS.ST"   "REGION"

Some datasets lack PR. (72)

Many datasets lack these:  AS, GU, MP, VI (codes "60" "66" "69" "78")

Almost all datasets lack UM. (74)

\begin{alltt}    72 PR                 Puerto Rico
    
    66 GU                        Guam 
    
    69 MP    Northern Mariana Islands  
    
    78 VI         U.S. Virgin Islands 
    
    74 UM U.S. Minor Outlying Islands  
\end{alltt}

\end{Details}
%
\begin{SeeAlso}\relax
\LinkA{stateinfo2}{stateinfo2} for more columns
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{stateinfo2}{stateinfo2 (DATA) data.frame of state abbreviations and state names (50+DC+PR; not AS, GU, MP, VI, UM)}{stateinfo2}
%
\begin{Description}\relax
52 rows and several variables: ST is the 2-letter abbreviation,
statename is the State name, etc.
\end{Description}
%
\begin{Details}\relax
Created for EJAM by datacreate\_stateinfo2.R script

Also see \url{https://www.census.gov/programs-surveys/decennial-census/decade/2020/planning-management/release/2020-island-areas-data-products.html}

column names:

c("statename", "FIPS.ST", "ST", "ftpname", "REGION",

"is.usa.plus.pr", "is.usa", "is.state", "is.contiguous.us", "is.island.areas",

"area.sqmi", "area.sqkm",

"landarea.sqmi", "landarea.sqkm",

"waterarea.sqmi", "waterarea.sqkm",

"inland.sqmi", "inland.sqkm",

"coastal.sqmi", coastal.sqkm",

"greatlakes.sqmi", "greatlakes.sqkm",

"territorial.sqmi", "territorial.sqkm",

"lat", "lon")

Some datasets lack PR. (72)

Many datasets lack these:  AS, GU, MP, VI (codes "60" "66" "69" "78")

Almost all datasets lack UM. (74)

\begin{alltt}    72 PR                 Puerto Rico
    
    66 GU                        Guam 
    
    69 MP    Northern Mariana Islands  
    
    78 VI         U.S. Virgin Islands 
    
    74 UM U.S. Minor Outlying Islands  
\end{alltt}

\end{Details}
%
\begin{SeeAlso}\relax
\LinkA{stateinfo}{stateinfo}  for fewer columns
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{statestats}{statestats (DATA) data.frame of 100 percentiles and means for each US State and PR and DC.}{statestats}
%
\begin{Description}\relax
data.frame of 100 percentiles and means
for each US State and PR and DC (approx 5,300 rows)
for all the block groups in that zone (e.g., block groups in \LinkA{blockgroupstats}{blockgroupstats})
for a set of indicators such as percent low income.
Each column is one indicator (or specifies the percentile).

This should be similar to the lookup tables in the gdb on the FTP site of EJScreen,
except it also has data for the demographic race/ethnicity subgroups.
For details on how the table was made, see /EJAM/data-raw/usastats\_subgroups.R
\end{Description}
\inputencoding{utf8}
\HeaderA{statestats\_means}{statestats\_means - convenient way to see STATE MEANS of ENVIRONMENTAL and DEMOGRAPHIC indicators}{statestats.Rul.means}
%
\begin{Description}\relax
statestats\_means - convenient way to see STATE MEANS of ENVIRONMENTAL and DEMOGRAPHIC indicators
\end{Description}
%
\begin{Usage}
\begin{verbatim}
statestats_means(
  ST = unique(EJAM::statestats$REGION),
  varnames = c(EJAM::names_e, EJAM::names_d, EJAM::names_d_subgroups_nh),
  PCTILES = "mean",
  dig = 2
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{ST}] vector of state abbreviations, or USA

\item[\code{varnames}] names of columns in lookup table, like "proximity.rmp"

\item[\code{PCTILES}] vector of percentiles 0-100 and/or "mean"

\item[\code{dig}] digits to round to
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{statestats\_query}{statestats\_query - convenient way to see mean, pctiles of Env or Demog indicators from lookup table}{statestats.Rul.query}
%
\begin{Description}\relax
statestats\_query - convenient way to see mean, pctiles of Env or Demog indicators from lookup table
\end{Description}
%
\begin{Usage}
\begin{verbatim}
statestats_query(
  ST = sort(unique(EJAM::statestats$REGION)),
  varnames = c(EJAM::names_e, EJAM::names_d),
  PCTILES = NULL,
  dig = 2
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{ST}] vector of state abbreviations, or USA

\item[\code{varnames}] names of columns in lookup table, like "proximity.rmp"

\item[\code{PCTILES}] vector of percentiles 0-100 and/or "mean"

\item[\code{dig}] digits to round to
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 

usastats_querye() 
#  data.frame where names_e are the names(), 
#  means plus other percentiles, and there are other cols REGION PCTILE

avg.in.us                # This is a data.frame, 1 row, where colnames are indicators
avg.in.us[names_e]          # subset is a data.frame!
unlist(avg.in.us[names_e])  # to make it a vector

usastats_means()        # This is a matrix, with 1 col, and indicator names are rownames
usastats_means(names_e)     # subset is a matrix        and indicator names are rownames
usastats_means()[names_e, ] # subset is a named vector  and indicator names are  names

usastats_means()
statestats_query()

statestats_query()[,names_d]
statestats_query(varnames = names_d)

statestats_query()[,names_e]
statestats_query(varnames = names_e)

statestats_query(varnames = names_d_subgroups)
head(statestats_query(varnames = longlist))

## in USA overall, see mean and key percentiles for all demog and envt indicators
usastats_query() # or statestats_query('us') # can say us or US or USA or usa etc.
usastats_query(PCTILES = 'mean')
usastats_means() # same but nicer looking format in console
usastats_means(dig=4)

# long list of variables:
x = intersect(EJAM::names_all_r,  names(EJAM::usastats))
usastats_means(x)

usastats[!(usastats$PCTILE < 50), c("PCTILE", names_d)]
usastats[!(usastats$PCTILE < 50), c("PCTILE", names_e)]

## in 1 state, see mean and key percentiles for all demog and envt indicators
statestats_query('MD')

## in 1 state, see mean and key percentiles for just demog indicators
statestats_queryd('MD')

## 1 indicator in 1 state, see a few key percentiles and mean
statestats_query('MD','proximity.tsdf')

## mean of 1 indicator for each state
statestats_query(varnames = 'proximity.tsdf')

## using full blockgroup dataset, not lookup tables of percentiles, 
blockgroupstats[, lapply(.SD, function(x) mean(x, na.rm=T)),  .SDcols= c(names_d, names_e)]

##   see all total counts (not just US means), 
##   demographics including subgroups, 
##   but not environmental indicators.
t(round(ustotals2(bg = blockgroupstats),2)) #  ustotals2 is from EJAMbatch.summarizer package
t(blockgroupstats[, lapply(.SD, function(x) mean(x, na.rm=T)),
    .SDcols= c(names_e, names_d)])


## End(Not run)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{statestats\_queryd}{statestats\_queryd - convenient way to see mean, pctiles of DEMOG indicators from lookup table}{statestats.Rul.queryd}
%
\begin{Description}\relax
statestats\_queryd - convenient way to see mean, pctiles of DEMOG indicators from lookup table
\end{Description}
%
\begin{Usage}
\begin{verbatim}
statestats_queryd(
  ST = sort(unique(EJAM::statestats$REGION)),
  varnames = c(EJAM::names_d, EJAM::names_d_subgroups_nh),
  PCTILES = NULL,
  dig = 2
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{ST}] vector of state abbreviations, or USA

\item[\code{varnames}] names of columns in lookup table, like "proximity.rmp"

\item[\code{PCTILES}] vector of percentiles 0-100 and/or "mean"

\item[\code{dig}] digits to round to
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 

usastats_querye() 
#  data.frame where names_e are the names(), 
#  means plus other percentiles, and there are other cols REGION PCTILE

avg.in.us                # This is a data.frame, 1 row, where colnames are indicators
avg.in.us[names_e]          # subset is a data.frame!
unlist(avg.in.us[names_e])  # to make it a vector

usastats_means()        # This is a matrix, with 1 col, and indicator names are rownames
usastats_means(names_e)     # subset is a matrix        and indicator names are rownames
usastats_means()[names_e, ] # subset is a named vector  and indicator names are  names

usastats_means()
statestats_query()

statestats_query()[,names_d]
statestats_query(varnames = names_d)

statestats_query()[,names_e]
statestats_query(varnames = names_e)

statestats_query(varnames = names_d_subgroups)
head(statestats_query(varnames = longlist))

## in USA overall, see mean and key percentiles for all demog and envt indicators
usastats_query() # or statestats_query('us') # can say us or US or USA or usa etc.
usastats_query(PCTILES = 'mean')
usastats_means() # same but nicer looking format in console
usastats_means(dig=4)

# long list of variables:
x = intersect(EJAM::names_all_r,  names(EJAM::usastats))
usastats_means(x)

usastats[!(usastats$PCTILE < 50), c("PCTILE", names_d)]
usastats[!(usastats$PCTILE < 50), c("PCTILE", names_e)]

## in 1 state, see mean and key percentiles for all demog and envt indicators
statestats_query('MD')

## in 1 state, see mean and key percentiles for just demog indicators
statestats_queryd('MD')

## 1 indicator in 1 state, see a few key percentiles and mean
statestats_query('MD','proximity.tsdf')

## mean of 1 indicator for each state
statestats_query(varnames = 'proximity.tsdf')

## using full blockgroup dataset, not lookup tables of percentiles, 
blockgroupstats[, lapply(.SD, function(x) mean(x, na.rm=T)),  .SDcols= c(names_d, names_e)]

##   see all total counts (not just US means), 
##   demographics including subgroups, 
##   but not environmental indicators.
t(round(ustotals2(bg = blockgroupstats),2)) #  ustotals2 is from EJAMbatch.summarizer package
t(blockgroupstats[, lapply(.SD, function(x) mean(x, na.rm=T)),
    .SDcols= c(names_e, names_d)])


## End(Not run)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{statestats\_querye}{statestats\_querye - convenient way to see mean, pctiles of ENVIRONMENTAL indicators from lookup table}{statestats.Rul.querye}
%
\begin{Description}\relax
statestats\_querye - convenient way to see mean, pctiles of ENVIRONMENTAL indicators from lookup table
\end{Description}
%
\begin{Usage}
\begin{verbatim}
statestats_querye(
  ST = sort(unique(EJAM::statestats$REGION)),
  varnames = EJAM::names_e,
  PCTILES = NULL,
  dig = 2
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{dig}] how many digits to round to
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 

usastats_querye() 
#  data.frame where names_e are the names(), 
#  means plus other percentiles, and there are other cols REGION PCTILE

avg.in.us                # This is a data.frame, 1 row, where colnames are indicators
avg.in.us[names_e]          # subset is a data.frame!
unlist(avg.in.us[names_e])  # to make it a vector

usastats_means()        # This is a matrix, with 1 col, and indicator names are rownames
usastats_means(names_e)     # subset is a matrix        and indicator names are rownames
usastats_means()[names_e, ] # subset is a named vector  and indicator names are  names

usastats_means()
statestats_query()

statestats_query()[,names_d]
statestats_query(varnames = names_d)

statestats_query()[,names_e]
statestats_query(varnames = names_e)

statestats_query(varnames = names_d_subgroups)
head(statestats_query(varnames = longlist))

## in USA overall, see mean and key percentiles for all demog and envt indicators
usastats_query() # or statestats_query('us') # can say us or US or USA or usa etc.
usastats_query(PCTILES = 'mean')
usastats_means() # same but nicer looking format in console
usastats_means(dig=4)

# long list of variables:
x = intersect(EJAM::names_all_r,  names(EJAM::usastats))
usastats_means(x)

usastats[!(usastats$PCTILE < 50), c("PCTILE", names_d)]
usastats[!(usastats$PCTILE < 50), c("PCTILE", names_e)]

## in 1 state, see mean and key percentiles for all demog and envt indicators
statestats_query('MD')

## in 1 state, see mean and key percentiles for just demog indicators
statestats_queryd('MD')

## 1 indicator in 1 state, see a few key percentiles and mean
statestats_query('MD','proximity.tsdf')

## mean of 1 indicator for each state
statestats_query(varnames = 'proximity.tsdf')

## using full blockgroup dataset, not lookup tables of percentiles, 
blockgroupstats[, lapply(.SD, function(x) mean(x, na.rm=T)),  .SDcols= c(names_d, names_e)]

##   see all total counts (not just US means), 
##   demographics including subgroups, 
##   but not environmental indicators.
t(round(ustotals2(bg = blockgroupstats),2)) #  ustotals2 is from EJAMbatch.summarizer package
t(blockgroupstats[, lapply(.SD, function(x) mean(x, na.rm=T)),
    .SDcols= c(names_e, names_d)])


## End(Not run)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{states\_infer}{states\_infer - Get table of info on States (from latlon or FIPS) Get cleaned table of US State etc. by siteid, from lat/lon, or from FIPS}{states.Rul.infer}
%
\begin{Description}\relax
states\_infer - Get table of info on States (from latlon or FIPS)
Get cleaned table of US State etc. by siteid, from lat/lon, or from FIPS
\end{Description}
%
\begin{Usage}
\begin{verbatim}
states_infer(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] data.frame or data.table with either ST column or lat and lon columns, or FIPS,
and optionally a column with siteid or column called n
\end{ldescription}
\end{Arguments}
%
\begin{Value}
data.frame with unique siteid, ST, etc.
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{state\_from\_latlon()}{state.Rul.from.Rul.latlon}} \code{\LinkA{state\_from\_fips()}{state.Rul.from.Rul.fips}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{states\_shapefile}{states\_shapefile (DATA) US States boundaries 2020 shapefile from TIGER}{states.Rul.shapefile}
%
\begin{Description}\relax
This is used to figure out which state contains each point (facility/site).
\end{Description}
%
\begin{Details}\relax
This is used by \code{\LinkA{state\_from\_latlon()}{state.Rul.from.Rul.latlon}} to find which state is associated with each point
that the user wants to analyze. That is needed to report indicators in
the form of State-specific percentiles
(e.g., a score that is at the 80th percentile within Texas).
It is created by the package via a script at EJAM/data-raw/datacreate\_states\_shapefile.R
which downloads the data from Census Bureau.
\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{state\_from\_latlon()}{state.Rul.from.Rul.latlon}} \code{\LinkA{get\_blockpoints\_in\_shape()}{get.Rul.blockpoints.Rul.in.Rul.shape}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{state\_from\_blockid}{state\_from\_blockid given vector of blockids, get state abbreviation of each}{state.Rul.from.Rul.blockid}
%
\begin{Description}\relax
state\_from\_blockid
given vector of blockids, get state abbreviation of each
\end{Description}
%
\begin{Usage}
\begin{verbatim}
state_from_blockid(blockid)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{blockid}] vector of blockid values as from EJAM in a table called blockpoints
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector of ST info like AK, CA, DE, etc.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
state_from_blockid(c(8174952, blockpoints$blockid[5:6]))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{state\_from\_blocktable}{state\_from\_blocktable - was used only in some special cases of using testpoints\_n() given data.table with blockid column, get state abbreviation of each - not used?}{state.Rul.from.Rul.blocktable}
%
\begin{Description}\relax
state\_from\_blocktable - was used only in some special cases of using testpoints\_n()
given data.table with blockid column, get state abbreviation of each - not used?
\end{Description}
%
\begin{Usage}
\begin{verbatim}
state_from_blocktable(dt_with_blockid)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{dt\_with\_blockid}] 
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector of ST info like AK, CA, DE, etc.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
state_from_blocktable(blockpoints[45:49,])
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{state\_from\_fips}{state\_from\_fips - Get FIPS of ALL BLOCKGROUPS in the States or Counties Get the State abbreviations of ALL blockgroups within the input FIPS}{state.Rul.from.Rul.fips}
%
\begin{Description}\relax
state\_from\_fips - Get FIPS of ALL BLOCKGROUPS in the States or Counties
Get the State abbreviations of ALL blockgroups within the input FIPS
\end{Description}
%
\begin{Usage}
\begin{verbatim}
state_from_fips(fips, uniqueonly = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{fips}] Census FIPS codes vector, numeric or char, 2-digit, 5-digit, etc. OK

\item[\code{uniqueonly}] If set to TRUE, returns only unique results.
This parameter is here mostly to remind user that default is not uniques only.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Returns a vector of 2-letter State abbreviations that is
one per blockgroup that matches the input FIPS,
not necessarily a vector as long as the input vector of FIPS codes!,
and not just a short list of unique states!
\end{Details}
%
\begin{Value}
vector of 2-character state abbreviations like CA,CA,CA,MD,MD,TX
\end{Value}
\inputencoding{utf8}
\HeaderA{state\_from\_latlon}{state\_from\_latlon - find what state is where each point is located Takes 3 seconds to find state for 1k points, so a faster alternative would be useful}{state.Rul.from.Rul.latlon}
%
\begin{Description}\relax
state\_from\_latlon - find what state is where each point is located
Takes 3 seconds to find state for 1k points, so a faster alternative would be useful
\end{Description}
%
\begin{Usage}
\begin{verbatim}
state_from_latlon(lat, lon, states_shapefile = EJAM::states_shapefile)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{lat}] latitudes vector

\item[\code{lon}] longitudes vector

\item[\code{shapefile}] shapefile of US States, in package already
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Returns data.frame: ST, statename, FIPS.ST, REGION, n
as many rows as elements in lat or lon
\end{Value}
%
\begin{SeeAlso}\relax
\LinkA{states\_shapefile}{states.Rul.shapefile} \code{\LinkA{get\_blockpoints\_in\_shape()}{get.Rul.blockpoints.Rul.in.Rul.shape}} \code{\LinkA{states\_infer()}{states.Rul.infer}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
 myprogram <- "CAMDBS" # 739 sites
 pts <- frs_from_program(myprogram)[ , .(lat, lon, REGISTRY_ID,  PRIMARY_NAME)]
 # add a column with State abbreviation
 pts[, ST := state_from_latlon(lat=lat, lon = lon)$ST]
 #map these points
 mapfast(pts[ST == 'TX',], radius = 1) # 1 miles radius circles
 
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{structure.of.output.list}{structure.of.output.list - See info about list of results Utility to print summary info about the output of ejamit or doaggregate}{structure.of.output.list}
%
\begin{Description}\relax
structure.of.output.list - See info about list of results
Utility to print summary info about the output of ejamit or doaggregate
\end{Description}
%
\begin{Usage}
\begin{verbatim}
structure.of.output.list(x, maxshown = 10)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] the output of ejamit() or of doaggregate(),
a list of objects holding results of analysis

\item[\code{maxshown}] shows only first 10 elements of list by default
\end{ldescription}
\end{Arguments}
%
\begin{Value}
data.frame summarizing names of list, whether each element is a
data.table, data.frame, or vector, and rows/cols/length info
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
 
  structure.of.output.list(testpoints_10)
  structure.of.output.list(testoutput_getblocksnearby_10pts_1miles)
  structure.of.output.list(testoutput_doaggregate_10pts_1miles)
  structure.of.output.list(testoutput_ejamit_10pts_1miles)
  structure.of.output.list(testoutput_ejscreenapi_plus_5)
  structure.of.output.list(testoutput_ejscreenit_5)
  
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{ST\_by\_site\_from\_sites2blocks}{ST\_by\_site\_from\_sites2blocks - Get State that each site is in, from a table of siteid, blockid, distance}{ST.Rul.by.Rul.site.Rul.from.Rul.sites2blocks}
%
\begin{Description}\relax
Find the 2-character State abbreviation for each site. This is for when you need to know
the state each site is in, to be able to report state percentiles, but you do not have
the original list of siteid lat/lon or State info. This can infer the State
each site is located in, based on the state of the nearest block (and its parent blockgroup).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
ST_by_site_from_sites2blocks(sites2blocks)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{sites2blocks}] data.table or data.frame, like \LinkA{testoutput\_getblocksnearby\_10pts\_1miles}{testoutput.Rul.getblocksnearby.Rul.10pts.Rul.1miles},
from \code{\LinkA{getblocksnearby()}{getblocksnearby}} that has columns siteid and blockid and distance
\end{ldescription}
\end{Arguments}
%
\begin{Value}
data.table with columns  siteid, ST
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
  fname = './inst/testdata/testpoints_207_sites_with_signif_violations_NAICS_326_ECHO.csv'
  x = ST_by_site_from_sites2blocks(
    getblocksnearby( latlon_from_anything(fname), quadtree = localtree))
  y = read_csv_or_xl(fname)
  x$ST == y$FacState
  
## End(Not run)
  ST_by_site_from_sites2blocks(testoutput_getblocksnearby_10pts_1miles) 
  
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{table4gt\_from\_scorevectors}{table4gt\_from\_scorevectors - DRAFT EXPERIMENTAL - attempt to make table more flexible / any indicators Based on just indicator names and a value for each, it tries to fill in the rest of a summary table's data. and formats this as a data.frame ready for the next step}{table4gt.Rul.from.Rul.scorevectors}
%
\begin{Description}\relax
table4gt\_from\_scorevectors - DRAFT EXPERIMENTAL - attempt to make table more flexible / any indicators
Based on just indicator names and a value for each, it tries to fill in the rest of a summary table's data.
and formats this as a data.frame ready for the next step
\end{Description}
%
\begin{Usage}
\begin{verbatim}
table4gt_from_scorevectors(
  varnames_r = names_e,
  varnames_shown = fixcolnames(varnames_r, "r", "long"),
  value = as.vector(usastats_means(varnames_r)),
  state_avg = NULL,
  state_pctile = NULL,
  usa_avg = NULL,
  usa_pctile = NULL,
  state_ratio = NULL,
  usa_ratio = NULL,
  ST = "NY"
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{varnames\_r}] vector of variable names like names\_d

\item[\code{varnames\_shown}] vector like names\_d\_friendly

\item[\code{value}] indicator values for a place or overall

\item[\code{state\_avg}] indicator values average in State

\item[\code{state\_pctile}] indicator values as State percentiles

\item[\code{usa\_avg}] indicator values US average

\item[\code{usa\_pctile}] indicator values as US percentiles

\item[\code{state\_ratio}] indicator values as ratio to State average

\item[\code{usa\_ratio}] indicator values as ratio to US average
\end{ldescription}
\end{Arguments}
%
\begin{Value}
data.frame ready for table\_gt\_format\_step2 ???
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{table\_gt\_from\_ejamit()}{table.Rul.gt.Rul.from.Rul.ejamit}} \code{\LinkA{table\_gt\_from\_ejamit\_overall()}{table.Rul.gt.Rul.from.Rul.ejamit.Rul.overall}} \code{\LinkA{table\_gt\_from\_ejamit\_1site()}{table.Rul.gt.Rul.from.Rul.ejamit.Rul.1site}} \code{\LinkA{table\_validated\_ejamit\_row()}{table.Rul.validated.Rul.ejamit.Rul.row}} \code{\LinkA{table\_gt\_format\_step1()}{table.Rul.gt.Rul.format.Rul.step1}} \code{\LinkA{table\_gt\_format\_step2()}{table.Rul.gt.Rul.format.Rul.step2}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{tablefixed}{tablefixed - Table of counts of integer values zero through maxbin}{tablefixed}
%
\begin{Description}\relax
Like tabulate or table, sort of, but includes zero unlike tabulate,
and lets you ensure results include every integer 0 through maxbin,
so you can, for example, easily combine tables of counts where some
did not include all integers.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
tablefixed(x, maxbin = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] vector of integers, like counts, that can include 0

\item[\code{maxbin}] highest integer among x, or number of bins
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
There is likely a more efficient way to do this in some existing package,
but this is useful and fast enough.

When using a dataset like EJScreen with 13 indicators of interest,
and counting how many of the 13 are above various cutpoints,
there may be zero rows that have exactly 8 above some cutoff, for example.

This function makes it easier to combine those tables into a summary
where 0-13 are in each table while table() would only return integers
that came up in a given case (for one cutoff).
\end{Details}
%
\begin{Value}
summary table
\end{Value}
%
\begin{SeeAlso}\relax
colcounter\_summary()
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{table\_gt\_format\_step1}{table\_gt\_format\_step1 - validate and reshape 1 row of ejamit results to prep for formatting as gt table/report reshapes a few columns of a 1 row data.table into a tall multirow data.frame.}{table.Rul.gt.Rul.format.Rul.step1}
%
\begin{Description}\relax
table\_gt\_format\_step1 - validate and reshape 1 row of ejamit results to prep for formatting as gt table/report
reshapes a few columns of a 1 row data.table into a tall multirow data.frame.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
table_gt_format_step1(ejamit_results_1row = NULL, type = "demog")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{ejamit\_results\_1row}] data.table (or data.frame) like testoutput\_ejamit\_100pts\_1miles\$results\_overall
from something like ejamit(testpoints\_100, radius = 1)\$results\_overall

\item[\code{type}] demog or envt to specify which type of table
\end{ldescription}
\end{Arguments}
%
\begin{SeeAlso}\relax
\code{\LinkA{table\_gt\_from\_ejamit()}{table.Rul.gt.Rul.from.Rul.ejamit}} \code{\LinkA{table\_gt\_from\_ejamit\_overall()}{table.Rul.gt.Rul.from.Rul.ejamit.Rul.overall}} \code{\LinkA{table\_gt\_from\_ejamit\_1site()}{table.Rul.gt.Rul.from.Rul.ejamit.Rul.1site}} \code{\LinkA{table\_validated\_ejamit\_row()}{table.Rul.validated.Rul.ejamit.Rul.row}} \code{\LinkA{table\_gt\_format\_step1()}{table.Rul.gt.Rul.format.Rul.step1}} \code{\LinkA{table\_gt\_format\_step2()}{table.Rul.gt.Rul.format.Rul.step2}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{table\_gt\_format\_step2}{table\_gt\_format\_step2 - Format a table of demog or envt scores, percentiles, etc. to look similar to EJScreen report tables}{table.Rul.gt.Rul.format.Rul.step2}
%
\begin{Description}\relax
table\_gt\_format\_step2 - Format a table of demog or envt scores, percentiles, etc. to look similar to EJScreen report tables
\end{Description}
%
\begin{Usage}
\begin{verbatim}
table_gt_format_step2(
  df,
  type = c("demog", "envt")[1],
  my_cell_color = "#dce6f0",
  my_border_color = "#aaaaaa",
  digits_default = 2
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{df}] A data frame from table\_gt\_format\_step1

which is just a specific format of key EJAM results.

It has these columns (but it still works if the first two are omitted
and user-provided indicators are used - it just names them indicator 1, indicator 2, etc.):

varnames\_r, varnames\_shown, value, state\_avg, state\_pctile, usa\_avg, usa\_pctile

and one row per indicator, where varnames\_shown are longer indicator names for use in report.

The sort order in this df is ignored!  Instead, the variables are shown in the same order as
shown in EJScreen reports, as recorded in map\_headernames and checked here via varinfo(varnames\_r, "reportsort"), etc.

Uses gt R package for formatting.

\item[\code{type}] string - must be demog or envt

\item[\code{my\_cell\_color}] color for table cell fill backgrounds,  can be given as string ('blue') or hex code ('\#0070c0')

\item[\code{my\_border\_color}] color for table borders and boundaries, can be given as string ('blue') or hex code ('\#0070c0')

\item[\code{digits\_default}] number of digits to round to if not specified for a given indicator
(rounding info is drawn from map\_headernames\$decimals)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a gt-style table with formatting to closely match EJScreen standard report formatting
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{table\_gt\_from\_ejamit()}{table.Rul.gt.Rul.from.Rul.ejamit}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{table\_gt\_from\_ejamit}{table\_gt\_from\_ejamit - Create a gt-format table of results from EJAM Uses the list of results of ejamit()}{table.Rul.gt.Rul.from.Rul.ejamit}
%
\begin{Description}\relax
table\_gt\_from\_ejamit - Create a gt-format table of results from EJAM
Uses the list of results of ejamit()
\end{Description}
%
\begin{Usage}
\begin{verbatim}
table_gt_from_ejamit(ejamitoutput = NULL, type = c("demog", "envt")[1])
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{ejamitoutput}] list of EJAM results formatted as in testoutput\_ejamit\_100pts\_1miles,
as would be the output of ejamit()

\item[\code{type}] Must be "demog" or "envt" -- Creates one of these at a time
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
See the R package called gt. Also see code that creates html tables from html template
and code that creates formatted spreadsheets like \code{\LinkA{table\_xls\_format()}{table.Rul.xls.Rul.format}}
\end{Details}
%
\begin{Value}
Provides table in gt format from the R package called gt
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
 table_gt_from_ejamit(testoutput_ejamit_100pts_1miles)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{table\_gt\_from\_ejamit\_1site}{table\_gt\_from\_ejamit\_1site - Create a formatted table of results for 1 site from EJAM Uses 1 row from the results\_bysite part of ejamit() output}{table.Rul.gt.Rul.from.Rul.ejamit.Rul.1site}
%
\begin{Description}\relax
table\_gt\_from\_ejamit\_1site - Create a formatted table of results for 1 site from EJAM
Uses 1 row from the results\_bysite part of ejamit() output
\end{Description}
%
\begin{Usage}
\begin{verbatim}
table_gt_from_ejamit_1site(...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] passed to \code{\LinkA{table\_gt\_from\_ejamit\_overall()}{table.Rul.gt.Rul.from.Rul.ejamit.Rul.overall}}
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
 table_gt_from_ejamit_1site(testoutput_ejamit_100pts_1miles$results_bysite[ 1, ])
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{table\_gt\_from\_ejamit\_overall}{table\_gt\_from\_ejamit\_overall - Create a formatted table of results from EJAM overall summary stats Uses the results\_overall element of ejamit() output}{table.Rul.gt.Rul.from.Rul.ejamit.Rul.overall}
%
\begin{Description}\relax
table\_gt\_from\_ejamit\_overall - Create a formatted table of results from EJAM overall summary stats
Uses the results\_overall element of ejamit() output
\end{Description}
%
\begin{Usage}
\begin{verbatim}
table_gt_from_ejamit_overall(
  ejamit_results_1row = NULL,
  type = c("demog", "envt")[1]
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{ejamit\_results\_1row}] 1-row data.table like testoutput\_ejamit\_100pts\_1miles\$results\_overall,
as would come from ejamit(testpoints\_10)\$results\_overall

\item[\code{type}] Must be "demog" or "envt" -- Creates one of these at a time
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Provides table in gt format from the R package called gt
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
 x <- table_gt_from_ejamit_overall(testoutput_ejamit_100pts_1miles$results_overall)
 
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{table\_round}{table\_round - round numbers in a table, each column to appropriate number of decimal places}{table.Rul.round}
%
\begin{Description}\relax
table\_round - round numbers in a table, each column to appropriate number of decimal places
\end{Description}
%
\begin{Usage}
\begin{verbatim}
table_round(x, var = names(x), varnametype = "rname", ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] data.frame, data.table, or vector with at least some numerical columns, like the results
of ejamit()\$results\_bysite

\item[\code{var}] optional, but assumed to be names(x) by default, specifies colnames of table
or names of vector elements, within x

\item[\code{varnametype}] optional, name of column in map\_headernames that is looked in for var

\item[\code{...}] passed to \code{\LinkA{var\_is\_numeric\_ish()}{var.Rul.is.Rul.numeric.Rul.ish}}
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Returns the original x but with appropriate cells rounded off.
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{var\_is\_numeric\_ish()}{var.Rul.is.Rul.numeric.Rul.ish}} \code{\LinkA{table\_rounding\_info()}{table.Rul.rounding.Rul.info}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
 
  table_round(c(12.123456, 9, NA ), 'pm')

 x <- testoutput_ejamit_10pts_1miles$results_bysite[
   1:2, c('lat','lon', 'pop', names_these, names_ratio_to_avg_these, names_e_pctile), 
   with = FALSE
 ]

 table_rounding_info(names(x))

 table_round(x)
  
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{table\_rounding\_info}{table\_rounding\_info - how many decimal places to round to for given variable(s)}{table.Rul.rounding.Rul.info}
%
\begin{Description}\relax
table\_rounding\_info - how many decimal places to round to for given variable(s)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
table_rounding_info(var, varnametype = "rname")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{var}] vector of variable names such as c("pctlowinc", "cancer") or c(names\_d, names\_d\_subgroups)

\item[\code{varnametype}] which column of map\_headernames to use when looking for var, like "rname" or "api" or "long"
\end{ldescription}
\end{Arguments}
%
\begin{Value}
named vector same size as var, with var as names.
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{varinfo()}{varinfo}} \code{\LinkA{table\_round()}{table.Rul.round}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
  table_rounding_info("pm")
  table_round(8.252345, "pm")
  table_round(8, "pm")
  
  cbind(table_rounding_info(names_all_r), fixcolnames(names_all_r, "r", "long"))
 
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{table\_tall\_from\_overall}{table\_tall\_from\_overall Format the results\_overall part of the output of ejamit() or doaggregate()}{table.Rul.tall.Rul.from.Rul.overall}
%
\begin{Description}\relax
table\_tall\_from\_overall
Format the results\_overall part of the output of ejamit() or doaggregate()
\end{Description}
%
\begin{Usage}
\begin{verbatim}
table_tall_from_overall(results_overall, longnames)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{results\_overall}] data.table of 1 row, from output of ejamit() or doaggregate()

\item[\code{longnames}] vector of names of variables in results\_overall,
from output of ejamit() or doaggregate()
\end{ldescription}
\end{Arguments}
%
\begin{Value}
data.table that is one row per indicator
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
 table_tall_from_overall(testoutput_ejamit_10pts_1miles$results_overall)
 table_tall_from_overall(x$results_bysite[1, ])
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{table\_validated\_ejamit\_row}{table\_validated\_ejamit\_row - Cleans/validates EJAM results for 1 place or overall This is a first step in formatting results in nice tables}{table.Rul.validated.Rul.ejamit.Rul.row}
%
\begin{Description}\relax
table\_validated\_ejamit\_row - Cleans/validates EJAM results for 1 place or overall
This is a first step in formatting results in nice tables
\end{Description}
%
\begin{Usage}
\begin{verbatim}
table_validated_ejamit_row(ejamit_results_1row = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{ejamit\_results\_1row}] 1-row data.table like testoutput\_ejamit\_100pts\_1miles\$results\_overall,

as would come from ejamit(testpoints\_10)\$results\_overall

or a single row of testoutput\_ejamit\_100pts\_1miles\$results\_bysite
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Returns the input as a 1-row data.table, indicators etc. in the columns.
If not a 1 row table, or colnames are not what is expected, it returns correct structure filled with NA values.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
  x <- table_validated_ejamit_row(testoutput_ejamit_100pts_1miles$results_bysite[ 1, ])
  x <- table_validated_ejamit_row(testoutput_ejamit_100pts_1miles$results_overall)
  
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{table\_xls\_format}{table\_xls\_format - Format EJAM tabular outputs for saving as Excel spreadsheet Used by table\_xls\_from\_ejam()}{table.Rul.xls.Rul.format}
%
\begin{Description}\relax
table\_xls\_format - Format EJAM tabular outputs for saving as Excel spreadsheet
Used by table\_xls\_from\_ejam()
\end{Description}
%
\begin{Usage}
\begin{verbatim}
table_xls_format(
  overall,
  eachsite,
  longnames = NULL,
  formatted = NULL,
  bybg = NULL,
  plot_distance_by_group = FALSE,
  summary_plot = NULL,
  plotlatest = FALSE,
  plotfilename = NULL,
  mapadd = FALSE,
  ok2plot = TRUE,
  analysis_title = "EJAM analysis",
  buffer_desc = "Selected Locations",
  radius_or_buffer_in_miles = NULL,
  radius_or_buffer_description =
    "Miles radius of circular buffer (or distance used if buffering around polygons)",
  notes = NULL,
  heatmap_colnames = NULL,
  heatmap_cuts = c(80, 90, 95),
  heatmap_colors = c("yellow", "orange", "red"),
  heatmap2_colnames = NULL,
  heatmap2_cuts = c(1.009, 2, 3),
  heatmap2_colors = c("yellow", "orange", "red"),
  hyperlink_colnames = c("EJScreen Report", "EJScreen Map", "ECHO report"),
  graycolnames = NULL,
  narrowcolnames = NULL,
  graycolor = "gray",
  narrow6 = 6,
  testing = FALSE,
  launchexcel = FALSE,
  saveas = NULL,
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{overall}] table to save in one tab, from ejamit()\$overall, EJAM analysis of indicators overall (one row),
but if entire output of ejamit() is passed as if it were overall, function figures out eachsite, etc.

\item[\code{eachsite}] table to save in one tab, from ejamit()\$overall, EJAM analysis site by site (one row per site)

\item[\code{longnames}] vector of indicator names to display in Excel table

\item[\code{formatted}] optional table to save in one tab, from ejamit()\$overall, EJAM analysis overall in different format

\item[\code{bybg}] Optional large table of details of each block group that is only needed to analyze distances by group.

\item[\code{plot\_distance\_by\_group}] logical, whether to try to add a plot of mean distance by group.
This requires that bybg be provided as a parameter input to this function.

\item[\code{summary\_plot}] optional plot object passed from EJAM shiny app to save in 'Plot' sheet of Excel table

\item[\code{plotlatest}] optional logical. If TRUE, the most recently displayed plot (prior to this function being called) will be inserted into a tab called plot2

\item[\code{plotfilename}] the full path including name of .png file to insert

\item[\code{mapadd}] logical optional - try to include a map of the points

\item[\code{ok2plot}] can set to FALSE to prevent plots from being attempted, while debugging

\item[\code{analysis\_title}] optional title passed from Shiny app to 'Notes' sheet

\item[\code{buffer\_desc}] optional description of buffer used in analysis, passed to 'Notes' sheet

\item[\code{radius\_or\_buffer\_description}] optional text saying if distance is radius or polygon buffer, passed to 'Notes' sheet

\item[\code{notes}] Text of additional notes to put in the notes tab, optional vector of character elements pasted in as one line each.

\item[\code{heatmap\_colnames}] optional vector of colnames to apply heatmap colors

\item[\code{heatmap\_cuts}] vector of values to separate heatmap colors, between 0-100

\item[\code{heatmap\_colors}] vector of color names for heatmap bins, same length as
heatmap\_cuts, where first color is for those >= 1st cutpoint, but <2d,
second color is for those >=2d cutpoint but <3d, etc.

\item[\code{hyperlink\_colnames}] names of which to treat as URLs that should be hyperlinks

\item[\code{graycolnames}] which columns to deemphasize

\item[\code{narrowcolnames}] which column numbers to make narrow

\item[\code{graycolor}] color used to deemphasize some columns

\item[\code{narrow6}] how narrow

\item[\code{testing}] optional for testing only

\item[\code{launchexcel}] Set to TRUE to have this function launch Excel immediately, showing the final workbook created here.

\item[\code{saveas}] If not NULL, and a valid path with filename.xlsx is provided,
the workbook will be saved locally at that path and name. Warning: it will overwrite an existing file.

\item[\code{...}] other params passed along to \code{\LinkA{openxlsx::writeData()}{openxlsx::writeData()}}

\item[\code{radius\_miles}] If provided, miles buffer distance (from polygon or from point if circular buffers)
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Already took and put here most or all of code from table\_xls\_format() or table\_xls\_format\_api()
\end{Details}
%
\begin{Value}
a workbook, ready to be saved in spreadsheet format, with tabs like "Overall" and "Each Site"
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{table\_xls\_from\_ejam()}{table.Rul.xls.Rul.from.Rul.ejam}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
  table_xls_format(
    testoutput_ejamit_100pts_1miles$results_overall, 
    testoutput_ejamit_100pts_1miles$results_bysite,
    saveas =  "out1.xlsx")
 # can just pass the whole results of ejamit(), for convenience
 wb <- table_xls_format(testoutput_ejamit_100pts_1miles)
 openxlsx::saveWorkbook(wb, file = "out2.xlsx")

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{table\_xls\_from\_ejam}{table\_xls\_from\_ejam Format the results of ejamit() for excel and optionally save .xlsx file Uses table\_xls\_format()}{table.Rul.xls.Rul.from.Rul.ejam}
%
\begin{Description}\relax
table\_xls\_from\_ejam
Format the results of ejamit() for excel and optionally save .xlsx file
Uses table\_xls\_format()
\end{Description}
%
\begin{Usage}
\begin{verbatim}
table_xls_from_ejam(
  ejamitout,
  fname = NULL,
  save_now = TRUE,
  overwrite = TRUE,
  launchexcel = FALSE,
  interactive_console = TRUE,
  ok2plot = TRUE,
  in.testing = FALSE,
  in.analysis_title = "EJAM analysis",
  react.v1_summary_plot = NULL,
  radius_or_buffer_in_miles = NULL,
  buffer_desc = "Selected Locations",
  radius_or_buffer_description =
    "Miles radius of circular buffer (or distance used if buffering around polygons)",
  hyperlink_colnames = c("EJScreen Report", "EJScreen Map", "ECHO report"),
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{ejamitout}] output of \code{\LinkA{ejamit()}{ejamit}}

\item[\code{fname}] optional name or full path and name of file to save locally, like "out.xlsx"

\item[\code{save\_now}] optional logical, whether to save as a .xlsx file locally or just return workbook object
that can later be written to .xlsx file using \code{\LinkA{openxlsx::saveWorkbook()}{openxlsx::saveWorkbook()}}

\item[\code{overwrite}] optional logical, passed to \code{\LinkA{openxlsx::saveWorkbook()}{openxlsx::saveWorkbook()}}

\item[\code{launchexcel}] optional logical, passed to \code{\LinkA{table\_xls\_format()}{table.Rul.xls.Rul.format}}, whether to launch browser to see spreadsheet immediately

\item[\code{interactive\_console}] optional - should set to FALSE when used in code or server. If TRUE,
prompts RStudio user interactively asking where to save the downloaded file

\item[\code{ok2plot}] optional logical, passed to  \code{\LinkA{table\_xls\_format()}{table.Rul.xls.Rul.format}}, whether safe to try and plot or set FALSE if debugging plot problems

\item[\code{in.testing}] optional logical

\item[\code{in.analysis\_title}] optional title as character string

\item[\code{react.v1\_summary\_plot}] optional - a plot object

\item[\code{radius\_or\_buffer\_in\_miles}] optional radius in miles

\item[\code{radius\_or\_buffer\_description}] optional text phrase describing places analyzed

\item[\code{hyperlink\_colnames}] optional names of columns with URLs

\item[\code{...}] optional additional parameters passed to \code{\LinkA{table\_xls\_format()}{table.Rul.xls.Rul.format}}, such as
heatmap\_colnames, heatmap\_cuts, heatmap\_colors, etc.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
returns a workbook object for use by openxlsx::saveWorkbook(wb\_out, pathname)
or returns just the full path/file name of where it was saved if save\_now = TRUE
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
  table_xls_from_ejam(testoutput_ejamit_10pts_1miles)
  
## End(Not run)
 @seealso [table_xls_format()]
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{testoutput\_doaggregate\_1000pts\_1miles}{test output of doaggregate()}{testoutput.Rul.doaggregate.Rul.1000pts.Rul.1miles}
%
\begin{Description}\relax
test output of doaggregate()
\end{Description}
%
\begin{Details}\relax
This is the output of doaggregate(testoutput\_getblocksnearby\_1000pts\_1miles, sites2states\_or\_latlon = testpoints\_1000, radius = 1)
\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{doaggregate()}{doaggregate}} \code{\LinkA{ejamit()}{ejamit}} \LinkA{testoutput\_getblocksnearby\_1000pts\_1miles}{testoutput.Rul.getblocksnearby.Rul.1000pts.Rul.1miles} \LinkA{testpoints\_1000}{testpoints.Rul.1000}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{testoutput\_doaggregate\_100pts\_1miles}{test output of doaggregate()}{testoutput.Rul.doaggregate.Rul.100pts.Rul.1miles}
%
\begin{Description}\relax
test output of doaggregate()
\end{Description}
%
\begin{Details}\relax
This is the output of doaggregate(testoutput\_getblocksnearby\_100pts\_1miles, sites2states\_or\_latlon = testpoints\_100, radius = 1)
\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{doaggregate()}{doaggregate}} \code{\LinkA{ejamit()}{ejamit}} \LinkA{testoutput\_getblocksnearby\_100pts\_1miles}{testoutput.Rul.getblocksnearby.Rul.100pts.Rul.1miles} \LinkA{testpoints\_100}{testpoints.Rul.100}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{testoutput\_doaggregate\_10pts\_1miles}{test output of doaggregate()}{testoutput.Rul.doaggregate.Rul.10pts.Rul.1miles}
%
\begin{Description}\relax
test output of doaggregate()
\end{Description}
%
\begin{Details}\relax
This is the output of doaggregate(testoutput\_getblocksnearby\_10pts\_1miles, sites2states\_or\_latlon = testpoints\_10, radius = 1)
\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{doaggregate()}{doaggregate}} \code{\LinkA{ejamit()}{ejamit}} \LinkA{testoutput\_getblocksnearby\_10pts\_1miles}{testoutput.Rul.getblocksnearby.Rul.10pts.Rul.1miles} \LinkA{testpoints\_10}{testpoints.Rul.10}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{testoutput\_ejamit\_1000pts\_1miles}{test output of ejamit()}{testoutput.Rul.ejamit.Rul.1000pts.Rul.1miles}
%
\begin{Description}\relax
test output of ejamit()
\end{Description}
%
\begin{Details}\relax
This is the output of ejamit(testpoints\_1000, radius = 1)
\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{doaggregate()}{doaggregate}} \code{\LinkA{ejamit()}{ejamit}} \LinkA{testoutput\_doaggregate\_1000pts\_1miles}{testoutput.Rul.doaggregate.Rul.1000pts.Rul.1miles} \LinkA{testpoints\_1000}{testpoints.Rul.1000}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{testoutput\_ejamit\_100pts\_1miles}{test output of ejamit()}{testoutput.Rul.ejamit.Rul.100pts.Rul.1miles}
%
\begin{Description}\relax
test output of ejamit()
\end{Description}
%
\begin{Details}\relax
This is the output of ejamit( testpoints\_100, radius = 1)
\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{doaggregate()}{doaggregate}} \code{\LinkA{ejamit()}{ejamit}} \LinkA{testoutput\_doaggregate\_100pts\_1miles}{testoutput.Rul.doaggregate.Rul.100pts.Rul.1miles} \LinkA{testpoints\_100}{testpoints.Rul.100}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{testoutput\_ejamit\_10pts\_1miles}{test output of ejamit()}{testoutput.Rul.ejamit.Rul.10pts.Rul.1miles}
%
\begin{Description}\relax
test output of ejamit()
\end{Description}
%
\begin{Details}\relax
This is the output of ejamit( testpoints\_10, radius = 1)
\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{doaggregate()}{doaggregate}} \code{\LinkA{ejamit()}{ejamit}} \LinkA{testoutput\_doaggregate\_10pts\_1miles}{testoutput.Rul.doaggregate.Rul.10pts.Rul.1miles} \LinkA{testpoints\_10}{testpoints.Rul.10}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{testoutput\_getblocksnearby\_1000pts\_1miles}{test output of getblocksnearby(), and is an input to doaggregate()}{testoutput.Rul.getblocksnearby.Rul.1000pts.Rul.1miles}
%
\begin{Description}\relax
test output of getblocksnearby(), and is an input to doaggregate()
\end{Description}
%
\begin{Details}\relax
This is the output of getblocksnearby(testpoints\_1000, radius = 1)
\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{getblocksnearby()}{getblocksnearby}}  \code{\LinkA{doaggregate()}{doaggregate}}  \LinkA{testpoints\_1000}{testpoints.Rul.1000}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{testoutput\_getblocksnearby\_100pts\_1miles}{test output of getblocksnearby(), and is an input to doaggregate()}{testoutput.Rul.getblocksnearby.Rul.100pts.Rul.1miles}
%
\begin{Description}\relax
test output of getblocksnearby(), and is an input to doaggregate()
\end{Description}
%
\begin{Details}\relax
This is the output of getblocksnearby(testpoints\_100, radius = 1)
\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{getblocksnearby()}{getblocksnearby}}  \code{\LinkA{doaggregate()}{doaggregate}}  \LinkA{testpoints\_100}{testpoints.Rul.100}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{testoutput\_getblocksnearby\_10pts\_1miles}{test output of getblocksnearby(), and is an input to doaggregate()}{testoutput.Rul.getblocksnearby.Rul.10pts.Rul.1miles}
%
\begin{Description}\relax
test output of getblocksnearby(), and is an input to doaggregate()
\end{Description}
%
\begin{Details}\relax
This is the output of getblocksnearby(testpoints\_10, radius = 1)
\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{getblocksnearby()}{getblocksnearby}}  \code{\LinkA{doaggregate()}{doaggregate}}  \LinkA{testpoints\_10}{testpoints.Rul.10}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{testpoints\_10}{test points data.frame with columns siteid, lat, lon}{testpoints.Rul.10}
%
\begin{Description}\relax
test points data.frame with columns siteid, lat, lon

test points data.frame with columns siteid, lat, lon
\end{Description}
\inputencoding{utf8}
\HeaderA{testpoints\_100}{test points data.frame with columns siteid, lat, lon}{testpoints.Rul.100}
%
\begin{Description}\relax
test points data.frame with columns siteid, lat, lon
\end{Description}
\inputencoding{utf8}
\HeaderA{testpoints\_1000}{test points data.frame with columns siteid, lat, lon}{testpoints.Rul.1000}
%
\begin{Description}\relax
test points data.frame with columns siteid, lat, lon
\end{Description}
\inputencoding{utf8}
\HeaderA{testpoints\_10000}{test points data.frame with columns siteid, lat, lon}{testpoints.Rul.10000}
%
\begin{Description}\relax
test points data.frame with columns siteid, lat, lon
\end{Description}
\inputencoding{utf8}
\HeaderA{testpoints\_n}{testpoints\_n - Random points in USA - average resident, facility, BG, block, or square mile Get data.table of Random Points (lat lon) for Testing/ Benchmarking/ Demos, weighted in various ways. The weighting can be specified so that each point reflects the average EPA-regulated facility, blockgroup, block, place on the map, or US resident.}{testpoints.Rul.n}
%
\begin{Description}\relax
testpoints\_n - Random points in USA - average resident, facility, BG, block, or square mile
Get data.table of Random Points (lat lon) for Testing/ Benchmarking/ Demos, weighted in various ways.
The weighting can be specified so that each point reflects the average EPA-regulated
facility, blockgroup, block, place on the map, or US resident.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
testpoints_n(
  n = 10,
  weighting = c("frs", "pop", "area", "bg", "block"),
  dt = TRUE,
  ST_needed = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{n}] Number of points needed (sample size)

\item[\code{weighting}] word indicating how to weight the random points (some synonyms are allowed, in addition to those shown here):

Note the default is frs, but you may want to use pop even though it is slower.
\begin{itemize}

\item{} pop or people = Average Person: random person among all US residents (block point of residence per 2020 Census)
\item{} frs or facility = Average Facility: random EPA-regulated facility from actives in Facility Registry Service (FRS)
\item{} bg = Average Blockgroup: random US Census block group (internal point like a centroid)
\item{} block = Average Block: random US Census block (internal point like a centroid)
\item{} area or place = Average Place: random point on a map (internal point of avg blockgroup weighted by its square meters size)

\end{itemize}


\item[\code{dt}] logical, whether to return a data.table (DEFAULT) instead of normal data.frame

\item[\code{ST\_needed}] optional, can be a character vector of 2 letter State abbreviations to pick from only some States.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
data.frame or data.table with columns lat, lon in decimal degrees, and
any other columns that are in the table used (based on weighting)
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
mapfast(testpoints_n(300, ST_needed = c('LA','MS')) )
n=2
for (d in c(TRUE,FALSE)) {
  for (w in c('frs', 'pop', 'area', 'bg', 'block')) {
    cat("n=",n,"  weighting=",w, "  dt=",d,"\n\n")
    print(x <- testpoints_n(n,w,d)); print(class(x))
    cat('\n')
  }
}

## End(Not run)
 
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{test\_regid}{test\_regid (DATA) test data, vector of EPA FRS Registry ID numbers}{test.Rul.regid}
%
\begin{Description}\relax
test\_regid (DATA) test data, vector of EPA FRS Registry ID numbers
\end{Description}
%
\begin{Details}\relax
For testing, e.g.,

frs\_from\_siteid(test\_regid)

mapfast(  frs\_from\_regid(test\_regid)  )
\end{Details}
\inputencoding{utf8}
\HeaderA{trilaterate\_sites2blocks}{trilaterate\_sites2blocks - Estimate lat,lon of each siteid, from outputs of getblocksnearby() get data.table with siteid, lat,lon of each site (eg for when you did not save sitepoints info)}{trilaterate.Rul.sites2blocks}
%
\begin{Description}\relax
trilaterate\_sites2blocks - Estimate lat,lon of each siteid, from outputs of getblocksnearby()
get data.table with siteid, lat,lon of each site (eg for when you did not save sitepoints info)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
trilaterate_sites2blocks(s2b)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{s2b}] like \LinkA{testoutput\_getblocksnearby\_10pts\_1miles}{testoutput.Rul.getblocksnearby.Rul.10pts.Rul.1miles}
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a data.table with one row per unique siteid from input dt,
plus lat,lon columns
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
s2b = copy(testoutput_getblocksnearby_10pts_1miles)
s2b_located = latlon_join_on_blockid(s2b) # done by trilaterate also
inferred_sites = trilaterate_sites2blocks(s2b)
inferred_sites
plotblocksnearby(s2b_located)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{unshared}{unshared aka setdiff2 - UTILITY - see what is only in x or y but not both utility just like setdiff except for y,x and also x,y Just shows which elements are in one and only one of the sets x and y}{unshared}
%
\begin{Description}\relax
unshared aka setdiff2 - UTILITY - see what is only in x or y but not both
utility just like setdiff except for y,x and also x,y
Just shows which elements are in one and only one of the sets x and y
\end{Description}
%
\begin{Usage}
\begin{verbatim}
unshared(x, y)
\end{verbatim}
\end{Usage}
\inputencoding{utf8}
\HeaderA{url\_4table}{url\_4table - Create URLs in columns}{url.Rul.4table}
%
\begin{Description}\relax
url\_4table - Create URLs in columns
\end{Description}
%
\begin{Usage}
\begin{verbatim}
url_4table(lat, lon, radius, regid = NULL, as_html = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{lat}] vector of latitudes

\item[\code{lon}] vector of longitudes

\item[\code{radius}] vector of values for radius in miles

\item[\code{regid}] vector of FRS registry IDs if available to use to create links to detailed ECHO facility reports

\item[\code{as\_html}] logical
\end{ldescription}
\end{Arguments}
%
\begin{Value}
list of data.frames to append to the list of data.frames created by ejamit() or doaggregate(),
list(results\_bysite = results\_bysite, results\_overall = results\_overall, newcolnames=newcolnames)
\end{Value}
%
\begin{SeeAlso}\relax
url\_ejscreen\_report() url\_ejscreenmap() url\_echo\_facility\_webpage() from EJAMejscreenapi package
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{url\_bookmark\_save}{url\_bookmark\_save save bookmarked EJScreen session (map location and indicator)}{url.Rul.bookmark.Rul.save}
%
\begin{Description}\relax
url\_bookmark\_save
save bookmarked EJScreen session (map location and indicator)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
url_bookmark_save(..., file = "ejscreenbookmark.json")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] passed to \code{\LinkA{url\_bookmark\_text()}{url.Rul.bookmark.Rul.text}}

\item[\code{file}] path and name of .json file you want to save locally
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
WORK IN PROGRESS - NOT USED AS OF EARLY 2023.
You can use this function to create and save a json file that is a bookmark
for a specific place/ map view/ data layer in EJScreen.
You can later pull up that exact map in EJScreen by launching EJScreen,
clicking Tools, Save Session, Load from File.

***Units are not lat lon: "spatialReference":"latestWkid":3857,"wkid":102100

Note:
(1) The number of sessions that can be saved depends on the browser cache size.
(2) Session files, if saved, are available from the default Downloads folder on your computer.
(3) Users should exercise caution when saving sessions that may contain sensitive or confidential data.
\end{Details}
%
\begin{Value}
URL for 1 bookmarked EJScreen map location and variable displayed on map
\end{Value}
\inputencoding{utf8}
\HeaderA{url\_bookmark\_text}{url\_bookmark\_text URL for 1 bookmarked EJScreen session (map location and indicator)}{url.Rul.bookmark.Rul.text}
%
\begin{Description}\relax
url\_bookmark\_text
URL for 1 bookmarked EJScreen session (map location and indicator)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
url_bookmark_text(
  x = c(-13232599.1784247, -13085305.0249191),
  y = c(3970069.24597194, 4067373.582979),
  name = "BookmarkedEJScreenMap",
  title = "Socioeconomic Indicators",
  renderField = "B_UNEMPPCT",
  pctlevel = "nation",
  xmin = 1.1 * min(x),
  xmax = 0.9 * min(x),
  ymin = 0.9 * min(y),
  ymax = 1.1 * min(y),
  urlrest = paste0("https://geopub.epa.gov/arcgis/rest/services",
    "/ejscreen/ejscreen_v2022_with_AS_CNMI_GU_VI/MapServer")
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] vector of approx topleft, bottomright longitudes in some units EJScreen uses?
Units are not lat lon: "spatialReference":"latestWkid":3857,"wkid":102100

\item[\code{y}] vector of approx topleft, bottomright latitudes in some units EJScreen uses?
Units are not lat lon: "spatialReference":"latestWkid":3857,"wkid":102100

\item[\code{name}] Your name for the map bookmark

\item[\code{title}] Your name for the map like Socioeconomic Indicators  or  Pollution and Sources

\item[\code{renderField}] name of variable shown on map, like B\_UNEMPPCT for map color bins of percent unemployed
or B\_PTRAF for traffic indicator

\item[\code{pctlevel}] nation or state

\item[\code{xmin}] calculated bounding box for map view

\item[\code{xmax}] calculated bounding box for map view

\item[\code{ymin}] calculated bounding box for map view

\item[\code{ymax}] calculated bounding box for map view

\item[\code{urlrest}] Just use the default but it changes each year
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
WORK IN PROGRESS - NOT USED AS OF EARLY 2023.
You can use this function to create and save a json file that is a bookmark
for a specific place/ map view/ data layer in EJScreen.
You can later pull up that exact map in EJScreen by launching EJScreen,
clicking Tools, Save Session, Load from File.

Note:
(1) The number of sessions that can be saved depends on the browser cache size.
(2) Session files, if saved, are available from the default Downloads folder on your computer.
(3) Users should exercise caution when saving sessions that may contain sensitive or confidential data.
\end{Details}
%
\begin{Value}
URL for 1 bookmarked EJScreen map location and variable displayed on map
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{url\_bookmark\_save()}{url.Rul.bookmark.Rul.save}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
  url_bookmark_text()
  url_bookmark_save(
    x=c(-10173158.179197036, -10128824.702791695), 
    y=c(3548990.034736070,3579297.316451102), 
    file="./mysavedejscreensession1.json")
  
## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{url\_countyhealthrankings}{url\_countyhealthrankings}{url.Rul.countyhealthrankings}
%
\begin{Description}\relax
url\_countyhealthrankings
\end{Description}
%
\begin{Usage}
\begin{verbatim}
url_countyhealthrankings(fips, year = 2023)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{fips}] vector of fips codes of counties, 5 characters each, like "10003"

\item[\code{year}] 2023
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector of URLs
\end{Value}
\inputencoding{utf8}
\HeaderA{url\_getacs\_epaquery}{url\_getacs\_epaquery - experimental/ work in progress: get ACS data via EPA API (for <200 places)}{url.Rul.getacs.Rul.epaquery}
%
\begin{Description}\relax
uses ACS2019 rest services ejscreen ejquery MapServer 7

Documentation of format and examples of input parameters:

\url{https://geopub.epa.gov/arcgis/sdk/rest/index.html\#/Query_Map_Service_Layer/02ss0000000r000000/}
\end{Description}
%
\begin{Usage}
\begin{verbatim}
url_getacs_epaquery(
  objectIds = 1:3,
  servicenumber = 7,
  outFields = NULL,
  returnGeometry = FALSE,
  justurl = FALSE,
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{objectIds}] see API

\item[\code{servicenumber}] see API

\item[\code{outFields}] see API. eg "STCNTRBG","TOTALPOP","PCT\_HISP",

\item[\code{returnGeometry}] see API

\item[\code{justurl}] if TRUE, returns url instead of default making API request

\item[\code{...}] passed to url\_getacs\_epaquery\_chunked()
\end{ldescription}
\end{Arguments}
%
\begin{Value}
table
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
 url_getacs_epaquery(justurl=TRUE) 
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{url\_getacs\_epaquery\_chunked}{url\_getacs\_epaquery\_chunked - experimental/ work in progress: in chunks, get ACS data via EPA API}{url.Rul.getacs.Rul.epaquery.Rul.chunked}
%
\begin{Description}\relax
url\_getacs\_epaquery\_chunked - experimental/ work in progress: in chunks, get ACS data via EPA API
\end{Description}
%
\begin{Usage}
\begin{verbatim}
url_getacs_epaquery_chunked(
  objectIds = 1:3,
  servicenumber = 7,
  outFields = NULL,
  returnGeometry = FALSE,
  justurl = FALSE,
  chunksize = 200,
  ...
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{objectIds}] see API

\item[\code{servicenumber}] see API

\item[\code{outFields}] see API

\item[\code{returnGeometry}] see API

\item[\code{justurl}] see API

\item[\code{chunksize}] eg 200 for chunks of 200 each request

\item[\code{...}] passed to url\_getacs\_epaquery()
\end{ldescription}
\end{Arguments}
%
\begin{Value}
table
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
 # x <- list() # chunked chunks. best not to ask for all these:
 # x[[1]] <- url_getacs_epaquery_chunked(   1:1000, chunksize = 100)
 # x[[2]] <- url_getacs_epaquery_chunked(1001:5000, chunksize = 100)
 # xall <- do.call(rbind, x)
 
## End(Not run) 
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{url\_get\_eparest\_chunked\_by\_id}{url\_get\_eparest\_chunked\_by\_id - experimental/ work in progress: in chunks, get ACS data or Block weights nearby via EPA API}{url.Rul.get.Rul.eparest.Rul.chunked.Rul.by.Rul.id}
%
\begin{Description}\relax
url\_get\_eparest\_chunked\_by\_id - experimental/ work in progress: in chunks, get ACS data or Block weights nearby via EPA API
\end{Description}
%
\begin{Usage}
\begin{verbatim}
url_get_eparest_chunked_by_id(objectIds, chunksize = 200, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{objectIds}] see API

\item[\code{chunksize}] see API

\item[\code{...}] passed to url\_getacs\_epaquery()
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a table
\end{Value}
\inputencoding{utf8}
\HeaderA{url\_get\_via\_url}{url\_get\_via\_url - helper function work in progress: GET json via url of ejscreen ejquery map services}{url.Rul.get.Rul.via.Rul.url}
%
\begin{Description}\relax
url\_get\_via\_url - helper function work in progress: GET json via url of ejscreen ejquery map services
\end{Description}
%
\begin{Usage}
\begin{verbatim}
url_get_via_url(url)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{url}] the url for an EJScreen ejquery request
\end{ldescription}
\end{Arguments}
%
\begin{Value}
json
\end{Value}
\inputencoding{utf8}
\HeaderA{url\_naics.com}{url\_naics.com - Get URL for page with info about industry sectors by text query term See (https://naics.com) for more information on NAICS codes}{url.Rul.naics.com}
%
\begin{Description}\relax
url\_naics.com - Get URL for page with info about industry sectors by text query term
See (https://naics.com) for more information on NAICS codes
\end{Description}
%
\begin{Usage}
\begin{verbatim}
url_naics.com(query, as_html = FALSE, linktext)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{query}] string query term like "gasoline" or "copper smelting"

\item[\code{as\_html}] Whether to return as just the urls or as html hyperlinks to use in a DT::datatable() for example

\item[\code{linktext}] used as text for hyperlinks, if supplied and as\_html=TRUE
\end{ldescription}
\end{Arguments}
%
\begin{Value}
URL as string
\end{Value}
\inputencoding{utf8}
\HeaderA{usastats}{usastats (DATA) data.frame of 100 percentiles and means}{usastats}
%
\begin{Description}\relax
data.frame of 100 percentiles and means (about 100 rows)
in the USA overall, across all locations (e.g., block groups in \LinkA{blockgroupstats}{blockgroupstats})
for a set of indicators such as percent low income.
Each column is one indicator (or specifies the percentile).

This should be similar to the lookup tables in the gdb on the FTP site of EJScreen,
except it also has data for the demographic race/ethnicity subgroups.
For details on how the table was made, see /EJAM/data-raw/usastats\_subgroups.R
\end{Description}
\inputencoding{utf8}
\HeaderA{usastats\_means}{usastats\_means - convenient way to see US MEANS of ENVIRONMENTAL and DEMOGRAPHIC indicators}{usastats.Rul.means}
%
\begin{Description}\relax
usastats\_means - convenient way to see US MEANS of ENVIRONMENTAL and DEMOGRAPHIC indicators
\end{Description}
%
\begin{Usage}
\begin{verbatim}
usastats_means(
  varnames = c(EJAM::names_e, EJAM::names_d, EJAM::names_d_subgroups_nh),
  PCTILES = NULL,
  dig = 2
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{varnames}] names of columns in lookup table, like "proximity.rmp"

\item[\code{PCTILES}] vector of percentiles 0-100 and/or "mean"

\item[\code{dig}] how many digits to round to
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{usastats\_query}{usastats\_query - convenient way to see US mean, pctiles of Envt and Demog indicators in lookup table}{usastats.Rul.query}
%
\begin{Description}\relax
usastats\_query - convenient way to see US mean, pctiles of Envt and Demog indicators in lookup table
\end{Description}
%
\begin{Usage}
\begin{verbatim}
usastats_query(
  varnames = c(EJAM::names_e, EJAM::names_d, EJAM::names_d_subgroups_nh),
  PCTILES = NULL,
  dig = 2
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{varnames}] names of columns in lookup table, like "proximity.rmp"

\item[\code{PCTILES}] vector of percentiles 0-100 and/or "mean"

\item[\code{dig}] how many digits to round to
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
A long list of variables: usastats\_query(intersect(EJAM::names\_all\_r,  names(EJAM::usastats)))
\end{Details}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 

usastats_querye() 
#  data.frame where names_e are the names(), 
#  means plus other percentiles, and there are other cols REGION PCTILE

avg.in.us                # This is a data.frame, 1 row, where colnames are indicators
avg.in.us[names_e]          # subset is a data.frame!
unlist(avg.in.us[names_e])  # to make it a vector

usastats_means()        # This is a matrix, with 1 col, and indicator names are rownames
usastats_means(names_e)     # subset is a matrix        and indicator names are rownames
usastats_means()[names_e, ] # subset is a named vector  and indicator names are  names

usastats_means()
statestats_query()

statestats_query()[,names_d]
statestats_query(varnames = names_d)

statestats_query()[,names_e]
statestats_query(varnames = names_e)

statestats_query(varnames = names_d_subgroups)
head(statestats_query(varnames = longlist))

## in USA overall, see mean and key percentiles for all demog and envt indicators
usastats_query() # or statestats_query('us') # can say us or US or USA or usa etc.
usastats_query(PCTILES = 'mean')
usastats_means() # same but nicer looking format in console
usastats_means(dig=4)

# long list of variables:
x = intersect(EJAM::names_all_r,  names(EJAM::usastats))
usastats_means(x)

usastats[!(usastats$PCTILE < 50), c("PCTILE", names_d)]
usastats[!(usastats$PCTILE < 50), c("PCTILE", names_e)]

## in 1 state, see mean and key percentiles for all demog and envt indicators
statestats_query('MD')

## in 1 state, see mean and key percentiles for just demog indicators
statestats_queryd('MD')

## 1 indicator in 1 state, see a few key percentiles and mean
statestats_query('MD','proximity.tsdf')

## mean of 1 indicator for each state
statestats_query(varnames = 'proximity.tsdf')

## using full blockgroup dataset, not lookup tables of percentiles, 
blockgroupstats[, lapply(.SD, function(x) mean(x, na.rm=T)),  .SDcols= c(names_d, names_e)]

##   see all total counts (not just US means), 
##   demographics including subgroups, 
##   but not environmental indicators.
t(round(ustotals2(bg = blockgroupstats),2)) #  ustotals2 is from EJAMbatch.summarizer package
t(blockgroupstats[, lapply(.SD, function(x) mean(x, na.rm=T)),
    .SDcols= c(names_e, names_d)])


## End(Not run)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{usastats\_queryd}{usastats\_queryd - convenient way to see US mean, pctiles of DEMOGRAPHIC indicators in lookup table}{usastats.Rul.queryd}
%
\begin{Description}\relax
usastats\_queryd - convenient way to see US mean, pctiles of DEMOGRAPHIC indicators in lookup table
\end{Description}
%
\begin{Usage}
\begin{verbatim}
usastats_queryd(
  varnames = c(EJAM::names_d, EJAM::names_d_subgroups_nh),
  PCTILES = NULL,
  dig = 2
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{varnames}] names of columns in lookup table, like "proximity.rmp"

\item[\code{PCTILES}] vector of percentiles 0-100 and/or "mean"

\item[\code{dig}] how many digits to round to
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 

usastats_querye() 
#  data.frame where names_e are the names(), 
#  means plus other percentiles, and there are other cols REGION PCTILE

avg.in.us                # This is a data.frame, 1 row, where colnames are indicators
avg.in.us[names_e]          # subset is a data.frame!
unlist(avg.in.us[names_e])  # to make it a vector

usastats_means()        # This is a matrix, with 1 col, and indicator names are rownames
usastats_means(names_e)     # subset is a matrix        and indicator names are rownames
usastats_means()[names_e, ] # subset is a named vector  and indicator names are  names

usastats_means()
statestats_query()

statestats_query()[,names_d]
statestats_query(varnames = names_d)

statestats_query()[,names_e]
statestats_query(varnames = names_e)

statestats_query(varnames = names_d_subgroups)
head(statestats_query(varnames = longlist))

## in USA overall, see mean and key percentiles for all demog and envt indicators
usastats_query() # or statestats_query('us') # can say us or US or USA or usa etc.
usastats_query(PCTILES = 'mean')
usastats_means() # same but nicer looking format in console
usastats_means(dig=4)

# long list of variables:
x = intersect(EJAM::names_all_r,  names(EJAM::usastats))
usastats_means(x)

usastats[!(usastats$PCTILE < 50), c("PCTILE", names_d)]
usastats[!(usastats$PCTILE < 50), c("PCTILE", names_e)]

## in 1 state, see mean and key percentiles for all demog and envt indicators
statestats_query('MD')

## in 1 state, see mean and key percentiles for just demog indicators
statestats_queryd('MD')

## 1 indicator in 1 state, see a few key percentiles and mean
statestats_query('MD','proximity.tsdf')

## mean of 1 indicator for each state
statestats_query(varnames = 'proximity.tsdf')

## using full blockgroup dataset, not lookup tables of percentiles, 
blockgroupstats[, lapply(.SD, function(x) mean(x, na.rm=T)),  .SDcols= c(names_d, names_e)]

##   see all total counts (not just US means), 
##   demographics including subgroups, 
##   but not environmental indicators.
t(round(ustotals2(bg = blockgroupstats),2)) #  ustotals2 is from EJAMbatch.summarizer package
t(blockgroupstats[, lapply(.SD, function(x) mean(x, na.rm=T)),
    .SDcols= c(names_e, names_d)])


## End(Not run)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{usastats\_querye}{usastats\_querye - convenient way to see US mean, pctiles of ENVIRONMENTAL indicators in lookup table}{usastats.Rul.querye}
%
\begin{Description}\relax
usastats\_querye - convenient way to see US mean, pctiles of ENVIRONMENTAL indicators in lookup table
\end{Description}
%
\begin{Usage}
\begin{verbatim}
usastats_querye(varnames = EJAM::names_e, PCTILES = NULL, dig = 2)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{varnames}] names of columns in lookup table, like "proximity.rmp"

\item[\code{PCTILES}] vector of percentiles 0-100 and/or "mean"

\item[\code{dig}] how many digits to round to
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 

usastats_querye() 
#  data.frame where names_e are the names(), 
#  means plus other percentiles, and there are other cols REGION PCTILE

avg.in.us                # This is a data.frame, 1 row, where colnames are indicators
avg.in.us[names_e]          # subset is a data.frame!
unlist(avg.in.us[names_e])  # to make it a vector

usastats_means()        # This is a matrix, with 1 col, and indicator names are rownames
usastats_means(names_e)     # subset is a matrix        and indicator names are rownames
usastats_means()[names_e, ] # subset is a named vector  and indicator names are  names

usastats_means()
statestats_query()

statestats_query()[,names_d]
statestats_query(varnames = names_d)

statestats_query()[,names_e]
statestats_query(varnames = names_e)

statestats_query(varnames = names_d_subgroups)
head(statestats_query(varnames = longlist))

## in USA overall, see mean and key percentiles for all demog and envt indicators
usastats_query() # or statestats_query('us') # can say us or US or USA or usa etc.
usastats_query(PCTILES = 'mean')
usastats_means() # same but nicer looking format in console
usastats_means(dig=4)

# long list of variables:
x = intersect(EJAM::names_all_r,  names(EJAM::usastats))
usastats_means(x)

usastats[!(usastats$PCTILE < 50), c("PCTILE", names_d)]
usastats[!(usastats$PCTILE < 50), c("PCTILE", names_e)]

## in 1 state, see mean and key percentiles for all demog and envt indicators
statestats_query('MD')

## in 1 state, see mean and key percentiles for just demog indicators
statestats_queryd('MD')

## 1 indicator in 1 state, see a few key percentiles and mean
statestats_query('MD','proximity.tsdf')

## mean of 1 indicator for each state
statestats_query(varnames = 'proximity.tsdf')

## using full blockgroup dataset, not lookup tables of percentiles, 
blockgroupstats[, lapply(.SD, function(x) mean(x, na.rm=T)),  .SDcols= c(names_d, names_e)]

##   see all total counts (not just US means), 
##   demographics including subgroups, 
##   but not environmental indicators.
t(round(ustotals2(bg = blockgroupstats),2)) #  ustotals2 is from EJAMbatch.summarizer package
t(blockgroupstats[, lapply(.SD, function(x) mean(x, na.rm=T)),
    .SDcols= c(names_e, names_d)])


## End(Not run)

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{varinfo}{varinfo - Get metadata for a variable, like its type, definition, decimalS rounding, etc. This is just a way to query map\_headernames, which has info about each indicator or variable used in EJAM.}{varinfo}
%
\begin{Description}\relax
varinfo - Get metadata for a variable, like its type, definition, decimalS rounding, etc.
This is just a way to query map\_headernames, which has info about each indicator or
variable used in EJAM.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
varinfo(
  var = map_headernames$rname,
  info = colnames(map_headernames),
  varnametype = "rname"
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{var}] vector of variable names such as c("pctlowinc", "cancer") or c(names\_d, names\_d\_subgroups)
(and must be found in the column of map\_headernames indicated by varnametype parameter below).

\item[\code{info}] types of metadata/info needed, such as "decimals", "long", etc.
which should be among colnames of map\_headernames,
or alias like "long" as allowed by fixcolnames()

\item[\code{varnametype}] optional. colname of map\_headernames to use when looking for var,
like "rname" or "api" or "long"
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
See map\_headernames for what kind of information is available there.
But if a variable appears twice+ in var or in map\_headernames, info returned only for the 1st row of those
\end{Details}
%
\begin{Value}
data.frame of 1 or more rows, 1 or more columns, where

rowsnames are var (indicators like "pctmin")

colnames are info (metadata   like "decimals")

Cells of table are metadata such as what type of indicator is that var, how many
decimal places of rounding should be displayed for it in tables, etc.

Results can be character, numeric, etc. depending on what info is requested
\end{Value}
%
\begin{SeeAlso}\relax
fixcolnames() \code{\LinkA{table\_rounding\_info()}{table.Rul.rounding.Rul.info}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
 
varinfo("traffic.score", "decimals")
varinfo(names_d, "long")
myvars <- c(names_d, names_d_subgroups, names_e)
myinfo <- "percentage"
cbind(  is.a.percentage = varinfo(myvars, myinfo) )
cbind(varinfo(names_all_r, "pctile."))
myinfo <- "long"
cbind(varinfo(myvars, myinfo) )
table_rounding_info(names_e)
 
varinfo(
 var = c(names_these, names_d_pctile),
 info = c(
 "topic_root_term", "varcategory", "vartype", "percentage", "pctile.", "calculation_type"
))

varinfo(names_all_r, c("varcategory", "varlist", "in_api", "in_bgcsv"))

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{varname2color\_ejam}{varname2color\_ejam - helper function - for color coding excel sheet columns Convert R variable name of indicator to appropriate color for header row in Excel}{varname2color.Rul.ejam}
%
\begin{Description}\relax
varname2color\_ejam - helper function - for color coding excel sheet columns
Convert R variable name of indicator to appropriate color for header row in Excel
\end{Description}
%
\begin{Usage}
\begin{verbatim}
varname2color_ejam(varname, varnameinfo)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{varname}] things like us.avg.pctlowinc
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector of colors
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{varname2vartype\_ejam()}{varname2vartype.Rul.ejam}} \code{\LinkA{varname2varcategory\_ejam()}{varname2varcategory.Rul.ejam}} \code{\LinkA{vartype\_cat2color\_ejam()}{vartype.Rul.cat2color.Rul.ejam}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{varname2varcategory\_ejam}{varname2varcategory\_ejam - helper function - given indicator names, look up what category each is}{varname2varcategory.Rul.ejam}
%
\begin{Description}\relax
varname2varcategory\_ejam - helper function - given indicator names, look up what category each is
\end{Description}
%
\begin{Usage}
\begin{verbatim}
varname2varcategory_ejam(varname, varnameinfo)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{varname}] vector of 1 or more names like "pctlowinc" as in unique(map\_headernames\$rname)

\item[\code{varnameinfo}] data.frame with info on type of each variable
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
tells if variable is "Demographic" "Environmental" "EJ Index" or "other"
as from dput(unique(map\_headernames\$varcategory))
\end{Details}
%
\begin{Value}
vector same size as varname
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{vartype\_cat2color\_ejam()}{vartype.Rul.cat2color.Rul.ejam}} \code{\LinkA{varname2color\_ejam()}{varname2color.Rul.ejam}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{varname2vartype\_ejam}{varname2vartype\_ejam - helper function - given indicator names, look up what type each is}{varname2vartype.Rul.ejam}
%
\begin{Description}\relax
varname2vartype\_ejam - helper function - given indicator names, look up what type each is
\end{Description}
%
\begin{Usage}
\begin{verbatim}
varname2vartype_ejam(varname, varnameinfo)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{varname}] vector of 1 or more names

\item[\code{varnameinfo}] data.frame with info on type of each variable
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The types are things like raw data count for indicator, average, percentile, etc.
\end{Details}
%
\begin{Value}
vector same size as varname
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{vartype\_cat2color\_ejam()}{vartype.Rul.cat2color.Rul.ejam}} \code{\LinkA{varname2color\_ejam()}{varname2color.Rul.ejam}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{vartype\_cat2color\_ejam}{vartype\_cat2color\_ejam - helper function - assign fill color to shade excel cells by indicator type and category Use color shading to make spreadsheet easier to use, grouping the indicators}{vartype.Rul.cat2color.Rul.ejam}
%
\begin{Description}\relax
vartype\_cat2color\_ejam - helper function - assign fill color to shade excel cells by indicator type and category
Use color shading to make spreadsheet easier to use, grouping the indicators
\end{Description}
%
\begin{Usage}
\begin{verbatim}
vartype_cat2color_ejam(vartype = raw, varcategory = "other")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{vartype}] must be one found in dput(unique(map\_headernames\$vartype))
like "usratio", "stateratio", "usraw", "stateraw",
"uspctile", "statepctile", "usavg", "stateavg", etc.
NA if not found.

\item[\code{varcategory}] must be one of "Demographic"   "Environmental" "EJ Index" "other"
as from dput(unique(map\_headernames\$varcategory))
\end{ldescription}
\end{Arguments}
%
\begin{Value}
vector of colors like c('lightblue', 'gray') matching length of vartype
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{varname2vartype\_ejam()}{varname2vartype.Rul.ejam}}  \code{\LinkA{varname2varcategory\_ejam()}{varname2varcategory.Rul.ejam}} \code{\LinkA{varname2color\_ejam()}{varname2color.Rul.ejam}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{var\_is\_numeric\_ish}{var\_is\_numeric\_ish - see which columns seem numeric and could be rounded, e.g. - DRAFT NOT FULLY TESTED}{var.Rul.is.Rul.numeric.Rul.ish}
%
\begin{Description}\relax
var\_is\_numeric\_ish - see which columns seem numeric and could be rounded, e.g. - DRAFT NOT FULLY TESTED
\end{Description}
%
\begin{Usage}
\begin{verbatim}
var_is_numeric_ish(
  x,
  only.if.already.numeric = FALSE,
  strip.characters.before.coerce = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] data.table, data.frame, or vector

\item[\code{only.if.already.numeric}] logical, if TRUE, only reports TRUE for a column (or element) if  is.numeric() is TRUE for that one

\item[\code{strip.characters.before.coerce}] logical, if TRUE, tries to remove spaces and percentage signs before trying to coerce to numeric
\end{ldescription}
\end{Arguments}
%
\begin{Value}
logical vector as long as NCOL(x) i.e., is length(x), if x is table, or length(x) if vector
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{table\_round()}{table.Rul.round}}
\end{SeeAlso}
\printindex{}
\end{document}
